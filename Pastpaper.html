<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>DPBuddy</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #F46C36;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #F46C36;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #00818F;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">DPBuddy</p>
                        <p><p>Check past emails for password</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Sign in " />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca0e75c1041064bc971ad497ce4ad3a5471af261a74c8b30a252785e89daba28d19d8c6a840739007f6a75d97f987507a0433a4e22621ff285c42aeb18e2070bbeb31244b73d540efb8097e8f834a98d48afa6fd39f9932c3b9930c1a4294d4f2c9a21cf64342fb31923fbd82f248af7e172c032a8c851255b988a8393416faf1d4bc186723c9b0bd322c5f27b6b0404ba0850c39689cfc5ce68822629bf256c2b7f58437bb82a5eed58b0150593dcd766f02ad388a24d02ddfee6a664058116c45a1f38504db6e9476996fb34936833884ec6e2df364a71566635e21b991195fc9a40c30ff7bdb271fcd3b1ff2c47de8b253eac5aaa7b3d1d5b531b3a25fdbc4bc20c81cbf9390cff6f8ac1bf28fb59ddfcf66acf853b8e23ac3b6b65925495cfeb8ef7b720b22d5266b6ad5d54d0b208cb5231fa9a0ddefc1c7f0bbd99f6b5f2ce2b629a5836b4f450c7c233ea0d98f3b72a461157c6b15982a15d5da8ff6754ac390053aa7940ebfa7a7b39dd1bdd6ffeec7f9444ef7143e62cacc7a64e15a7fa707997eadbacf0eb866faae5f34ee00fbf9aebe9c97f37f5f3e807e8517cb49e3bbe67fb074e8baf48853354252d1d27ba63b33ac9705e3bc75fb796bd15ff06cd087d2f212b6c274bb15e803ea8698cd741a0bda5253fca8be8efa68cdece46d08529f8cb5b916c262eac3106538a1d85005844d39b69fb3ac2879a0e347ab1711c56fad71dc7c3d475ac68e4111578ac5dd1f0bf86f1b41310388492c16b255f99b54a0dbe1f02d2217eac79cf9f40ca4dac9908298ff732beb5edfdb335565600639251dba95f81ab382d41d7cef0abbb0e5c1899d445fcb2922300427fab26b901dedeaa86c71d70b817c8d1130b97efed61e42d1337cd3d7e500539bcd42c4ff4656dfc83f19f5fb717395f12cc37882e479a06fdf62d2ae77cf9c716196ba622f080b08763b007662676fe80878d827c3e24cfe2761d73bc51d2f9ef021186d052dd323ffd2d2d6caca262edc030a9a19c80a0060e036daaccaceaa13b6ebd2567dab3b309cdc7a260f325df6dd66b4ab8ecfd7b73cbdf1cae637e007db5b75d49f31d4adb939545ebfa7d192da50e359a1745831fecc0a66b9e7999a8b0e47c9b3d0e0d411ddb9dece0d999051a219bd2cb7036a1272a00dd8fdb71180542d3d59de51d317912f0300990cd426d6d1bf7f64a39a4fc8a847643f47755423ed3c705fb4bc800a8699dadf4b0721749287a47c62561467f3d05de3236caa5a8c6ae8c8ec76b2551a2c4d500c8d05ad1a0b8170b3adaeed28ed5d18918f654ee739068e898604fcd94cf5544d8c015f698b5bfde613cc5392cb3cdd95bfe4532926c7819464d0e874e1129dea0c75f1c44191776c232384d243066bd865509885bd0c0ee8da9f176b7fe3956ad69a75339680383e178dc20843e7d37584b4b2a17b5b2d45347c0c84072179569054e1f7c255682de529193cc68ecf57f6ee81abb346ff02c4c795fca93144a801bf142f476be623f0d7b2a2af27207b1b96c868dd372fd958b57e3133dc696c12e10a51027357ce8f99dac0a29f3bbcd16131a9f3b2d8967e98dd917ddf3f64a494f705228e41e408823390a11b389379db304fc135040a9b99de2e6c44ea7a80f4ea72fadcca434de6b96ca749129030fb3dec477005093041be907ae63515a809526c847bdd51e8fa60973d95dec0564d92f95d058179d2d15d4be6444235595170971fce98696b98159877cdb23872c6251197907038c2a824b508a9761d2603182754558b71b332a240f767618f136561a473404dcdc1f20ee23ae3e4857fee5b54c58e943a072ce9d57d9f7b82f7dfac7ca2c9622b4774183108f94c8c4b98150ebe0432a575196f9b596f6a7f95145c5c9a2097d9787e7793d934c665f158ef3ab79fc55d9c363389c0f293e0fcf92f84157153188550feab30ff004094138b5759000d0a65f0f8aca6082eb45a5ef1f50217800d0749539fff699a6111c6c4127fd25d7299d96b81ba9aeedb9a4784712658fd505d62b77e2ab730fd20ec9542e8535b315454f156b4bcf979346c70f6574381fe0835ec8997cc131817c3736d9a6f4d0f68385ad4844ca7da3823a03b440b2d01de5c77ac64c4632843a1ee5831e9edcf17e1107ff15bf9a70e44269940bdd8ab40cdd497bb168539a6956c86295a53c2d9206fba7764c6f061224fe5e841519ce08a3dd4215e34ec99f3459159bc6c976d531af69e5f6afd2cc950a63480953136c93dea11d87e6b0142b46e123ad8f901ec04b6402d2f97bfc914fe977773bda5ebfdcee6bd5e103b33cfe90c10f3635673f35a9b0768051ffbc797a3c68aaf30375263adfb4b68261fc7c00a6af5d5b4a7c7afa4bf60bd0c57f2c76d30700d351b56c9cc580cbae88d3dd4ad9b428f5f2f0de8e68de89586603836ca83752ca8147f0b8c81379beb940df6184af1b04e7fa37a354c702ed24590f15f9053d914d25cf950d71f72cad65ca716526cd18123917569d97fba5503f76c2095f6dd3349aa322226b38cf1f68d69754c8ea4a640a7b4660f6c54b308cb3e0ffbcd9d90fdf1003053bed1e9a98f9c0c93bb4a087dddd42759df82c407dba4bbf827e5ef0286e53ce9679f3a7caffecb55f4d7b6047763dc3d504178f497e8535fc8cd0cf20f2cf441ccedb0c936733cf1082a1b8d58e8664e979d3f36e67c62f4166c9e8a3ddd7127bde42b1b4172eb64f6b566d49f5ffb707da382866ead2e01071ab1a6c2cf96d7954e571931f292f08283eeba08dc2ba11d9f2a8f09151dc9242bc501d9a08ca6c583c9efb111762f3319e612560f8ffd1c31b97e5e07e12ca7689c25aba55c9225ee35d6df1ce9bcc310b7f25ae51898537d4945b7fbccc5a8397d36d3ee98e671af9fca5fc12e2f7ee5cac6f5bfb3dde1f86466b1b1efde4f451da31185d4a5f858eb409b61ee90fe86b20e17ee6011a5313766dc237769adb636eb1a665052cee3d7ca357307c54241cec12c113dacdb38bb967410ff91fc6d5ca05030303ec8051c4c12d0701ca06e087674db06935ca20409d2848accd34ef6a7e604e7f6869fe5caa109d0dc750db29a67bedd070ed5a7fc40ddecb9df3afcbd5fc6fcc64a73f28847511aca952184e031973565cbf72980af6d773bb975e193caafec583584c6317718cc6e707577ad128a9a9280e4795cddd49289d6b468c53f4a740241398cb590b28b6d1eaa340618ec6b3acac4eed536a3b07656eccc1a6d03cb5d8c16130cd354594a29abee0ccbff2d13964c4cb96ae86b1a1f118a228e3bde5c8b3d32008ae37065b966fe1fa3c3570d09184c9c156cbf3e8f3c89c26333b94d2ac5912229865a710f9f7b4a44f79f7fa9404031155117bce435ec859cbadc0af6b7d2674cdc486e403d3a340900d6b0116690439220d0ee72b46e99a2335b0120a89bd3f5066e79165556734ff0d18c0cb45d5ffdbb029923ca026e77884d503f9b7b1adc4db1380057583158dbc9c0a0b775771f7325cf2c0b92b5d0bf2a091d2bd61d2f93f75709fa999a5bbdb5c6c5bbb7b80015d2c44effeff7f84981ddf0c19a3a8f232ec452570162265b50777ae48fa7b8c90af9f06c31ca305807fbfa1f3654bcfd3f92615c813ea708aa4a79f8aa5bb1a92e19e3fae6e091f938711fba2b8dd142aa8492bbdcd9448a680ff7b8e9e5eac1c8254ee8c7b41f4a66bd9dcb694020c7f2f8f6673eb5c48dfcc81816bcd0e2275b140fedd870d21ea6c1cf77c4e73645be9a003614a19e54760c8f2d5fd60ddf92f7c58fd50e5724c6bd3f17e1ad548ce80f59fef424e9bdd535dd8969e6e9020c3a6e4135fa4aa7701920017d6621e7a58c3f3122b5102c193a75f34916b1a8d5dd36ddd07b6987f84d5cac1fca1ffb8c8d50c92eab9a8b7fbe3a3c00d3779e81ccde64ccf458eaee1912b7e63cbb5f788fbae4950b66ed95b161582567de48f2bc615c90c29f71247a0ad01b0b8917d5634cdca585febd44cf3b0ebbc6c32cd97e7795da5169f3630799877c38453f9fa634fc670be391cf4f92252717af52ee3375bc78da852a1114124b16198be46beef069ea0d390ab85709074fd03d90b20019bbedbdc8d99cb9917ef7c90e2754c84cc8e0292fb4906ea5723754945809ed7dde932594020c73ccf0c8bf493e9cc9fb73f68e25261d992f87b6624b7b6a09fd3f0dfae69e93b6d0f92920ce22fdb017299b5c312ba7b12e2849aced0dfb91fe16eae84f8db1d432c494fcba3d35839361e80177da68ec1c413c5b10d18f6aa6592095cb4f7cee24dd841191ce118f855f12ed143608d3233d2587c5513f04497d4dfb6f219491b065b5d25b94e6612375d63062fee4527e45b32cbc3dc9a1cb5a62d4a5b5c2ef905fdc937bca68111b17e3de69512135ffebc8f86c86624f9d0b4a5bfdb1494c1144968327616e6137b2e3743f30557a71eed409e89e311a9ff820686c7e313bf5f6c08ca0fb9ce66558786e68c699d9bd57a1b9414a75419dbc462a7d5987c165d7c09d2ff491c8ce5739704ee88774afb383b9d810b542829abc279e99261d2bb969348aa4dcfd2d13f8a8544f01ac6387b721a5c322e20781e22e67a33032650e461da1bf4a4478685869bb972faf1414c31c36b7911f75ac985b9626f09702193e656337572a354c59bd357b018cabd3290d30a71b2e119d06cf11c5b58f774411df6f0d2ab001ddc999951752900f5c83a436346273d5419cd3806edeadbb889dda246700c051bc371828bf6a3fa23e2aaf3c2d13734f03cea13aaddce2ddf0356cabbf38133b2ed5b8740c5c73937c3ee25cf7c45160b195fcb0cfb34b48d047b5001b0eb475a5a0aefb3ee4431e92b6c1951bd71729ff6509d48bdbdf8c2625ecd94bbefdab130e91eca5904d421cbace2c8d21da747a5221479bccf5267cbe7278b58ed910f59bec5e8b0627ab2ce7b2e82b6625dc644427b592bf62c430d0e4efec0fe32b11301266c1164e57eca71d6c0704e20197f26cf61feacdb73bdd9143eb5475505351039c84799f3ee0844d3e82a28da686b1dae69f4739a73da58c7134d8e1304d584ed29b6705adab8e76befb9c39da5f9065458a6b236386f59c331c5a97a4b0ba3eba2e8e1ae68025347b6b02d96bebadc86a9a5642a46cd3bbd6c44d883e451bdda8a294ed235ff822f4130616ee7f0190917e518dc13dab76e2370df891c0c9e8ec95724bd01d02b20719efba14b4eacb4dbcb1207ced176325bef8e2d9b98eea97e012f291d559cbf65ee63bd9e57780c59a6b15767ff62094d959531034f36ec7cd0d81df7105cb29c93a94d28c3f312d019eec7c1c9e448e073d5479c7a5d12a355529a9694a10bd83c3c1ffbb8de4d1c5b2080e0d5e62d48d6e69251a451fdde9803cec0b6974cb02bae7da073930638f0bbdf9042d5cafda827b4321c19eeb232d95f5bc6d000d8db447c074bef34b885f075e8e4ec99b2b350185539ef8d4fc269907002b358587e3c7c14ff3b07a1f091d9f9b1146b95e8b49902bb54da546313ba84a25e51e1a01bfd2a0095f27030b40e30d9499cd4b3692293a68f6af90ec819c3f9b60b1562ea5e526571c56b7c702d733e56926a0cc840772c70d473bd635e308007f5a09a06a4f4e81f56bb337f07fbdf739a12ba1d6cf021354ff48f8b67b4f472fdec792aee63b75637d8ed5673ae1d2bd3e6448e1f22120f625043599c091c0e6e6d20979cb590a31257dd456b5e14b133f43d102d1438e94e0343b8466074b9891367f19020772ae79f289fd591faaccf05ffbdd951f8e9e946cfb2383e9beeee0eef47097c2ea35a9e3791a8325eb7de6b9922cbcda94ca85dc114b550630e88abeeebc7eea5b138b4dc4a9d46228a0f2af2818937861f31d85c2931c38847e096b4b367545a0fcc4a15917275732a85a88f9b488bcd0aa735b7a0e031b0de2db7432955513d90607e2bf7c4f3e1af4fb5f22e36e66666b5bbf71f36198e79536e0df268a27f4c515079de59483a3eff567af5c66e7ce788c8c16685e3fa9757d350cff829974b3e062071e9963576222330ec07e19cfbbc186bc992fdd20f08ec3dde191d5b939a82256b2bad46755b3edfa2b742cc01d2f69223de4747eda065424015febd307b4a01b5b7b2de0a598af4cb71f83e9f4cf68bac5e103a1bcf41cc24280626542f6f5d08fdee6e6a5f27bef980d22137aad8ef4418ddb16ebd0352f4fad775091c1f826066d2d37a816d6eb084365d1d81c3870b7542d5a2c5bdbb26eabdfe2bf3d77469c9f301174eb577e6389e6549d4033aa9c4fabb7b06e4d25a304f6fc06ed813be47afdcfeed5213e2b7e920a43d0b1526a3c56147fd3297d3124ffbe08239ddf8a57965623b9f6c4bd472761efdba6ec0edb9f224d26fbb809d3639ddf17138d7a0cf6504a5a611f0dcbe18a5f793cba1350b4194c3541a2581bb418e760cfe3f87bab7432a5d0b6876be6fe4c1e452bed0f12e3b08cbab882323f6c5ce054e156d31692757007ededbbacf85b103ab7f2fa8e735e7be0a510e34bc5c2a56289ce4451f4b1790bee0b180b3e5f3d313a4e2b19bbefaf1906791e891b9a950e287254942ad7739bb4f51d089c4bd7ceab30fe9291848d438e65f451e024256e11b53cf1e007cbda972884b20f6a1ecd2c8dc8ec1fc27efb4c348a834fe5a2dc326fe3b9565b3552424be5d86ec45ea06bb5023dde48d39c0d10d0cb1494b2b3f0bbf28978ccbe38639f4ed4bfaec82af253b8c20fb5512dbba17bdf62b4c3b527826cde444782e955b4684499eb49c03ff7d2b641e05924cadf73a1ab702d76ba4978372beef07ae852be95280b17128d62d4a2d3cb633f7e44544386a0c03f9a92317375928a7cf34d385eec0365cb358a9e185ae2a11c3f2b0c8ef2a78a18270b8952df70fdd28f80e3bd096a82b466335b136e88c71ce5087298a5c3f3a5b6d3cac04f04514edb49fea03207f984f91d422d4889d35a6309b1f0706800484c7d8a6de15ccba515271c35b5c77ca8664a5813f8a005cdee0b3d97f7336f69c3d5ec36c821079bb578683c49d737f9e93f4358d3c359288a44ed8ffa304a01fa60b07c569279e51635cb2f8d8825aeb0b4dac4afd5b1a4a1bfee930d11762e8cabaca90b4cdb2a66fd99aecf8b4ea271627c7d2dab75d8780882e5ac7a29fe10bc8dc6a74228c46aa150ee21492a7d2b843a5a0a98f5672053e45d0fa2bb7e85604809e8d011876c507ded065f6025305f1cefd4d3cc70e56bf7827004a1feb88bafc17826147667af50b7d8844254709909157c076c3924520ad5a89b9b4428a7c1eef6d6749643c7e481f60ad25f5949732044f0b8e7487a898400a4a68cfbe65a9221f8c2acd6cc3ad94aaebad556407f5a3949e4660d14e52fa9b743d21e6ba4619393518b1b0d9599851effb4283b9592b0ccf97185ba7bee59a3ca8aff05d8bafb8dbda0a8af217a4615da2741ec8c7897de663f962554016abcd030becdc50981239a6c6da54eb38881c54ca4e4a66bce8279cb63d817c32b38801de11461e787cc049a1bc6fbb072eead8b5a2bbd85024c91700d37ce38403f17c85526dad4958ed658f290e987e1457067b1734bca325e1fec2d0654160256261e5ca54a27b8a0943cc9c8cb4d5dc235db945e6789d96d1066e54d2fdfd8b989138ae3f7c2dc4f660bf9ceae6d5baa026dec5c0eedac8ebbffb9dfda7fcf226646a7c2ca4d71125eea06f1669bc3349c6ce51d636e6164c4caa56fa83e79ea6cd644f05ea1499478e71122383597884ee34a3fba1226e89e90f85199f653aecaab2cafe9e943559f5344ff174e2561a681a45a4dcc92ec11f8932e013526f3c50bc0d82d248a6e48eb34b747f82bf4a6be5a7cd2d3e6c054a794692c7dd5f2664a74cc22ab2a79c43ce967259467039649dd5646d77de59e915d735cbe60c1d1ca096c80ec28e8e934daab17c2e3b1b91f247145d96aec62de79fcfdf7cceaa821095bb27aafa61c89d6c2eaccebb2950841221b650f7e241adf503d4ea45d65a4983eda9ad2d0666b7d53a68ddce085d38b424ef7fc53e9176d8b81b17626c8ea3ff3317f324562088c5183bed4c8d768f60156cae9230ee821460dc9d87c4af2d664db8d183351b5e40e115ab4f18943ecf8fa5bd61abd4e43af266f2af935d9cf67e689a75784a91088824db1cefa2bcaaa20511048a9c8efaca1917a065ec1ab6ff539b4d2665f444228162e73ddb766146e8b6bc0ca4238f4a7d4ed85dbaefcf90d1baf93649917680cc6c8f0e526a7860589b754d1d15cd19f1aebc33f00b4f3505ac9a261852b883970085be0dd927831542a1db8d446663dfe457d2ef4ee7fd7deacb83e366f3aff68dd267f1fd5c295d2560f8afb1785fcd6afb4daebfbb9b50100e41d18a1e94291415ea6eedc19ed053fb5b59558bf95580984e319249a1a02155a209bb703b6c9c6dbb54b0a9b99b6b5bcc927ce2948deffdcd42a67d741ddc9453cb38fdd65167cc308a94a48637375d14497e3d207b076fc6dbe9685864bd8f0bae48bd0ab78dad48e8449b78691eea66b9ac0c2446ff1a73fb027b0a48b328af55cfe6648940c2396dacc23686cd4b3824607f788883209676a9a0be38b1338e1c5e0acff81944f204276ab1c7e27ce213b8605c98a85a9f8425ec65655772e44b69498910a59c97b9ff0bc455134c130a16419959081722fea6952e9b62bd42664e28413ac37e18f5d4a9a67a547294df186deef6003f878a7e956d55b25512c0ab60690c89d3a6b03c3f5150a51955c440a5cb974868cc66841f5a681a8d6eda7b2de8bd63147854a5a828b65db0c0abfdba0091cde6eb626be880e7700cd18f5ea201a69d3a3c072dfe7aedfd0398d9680da0ac22fdcc7c2a17ea790213aed74f152ba3c6a6580061fbc05dae92d4f852e2016fe5d0fa94af0aead4da08c7e88468db72efb0b5cb3c9bb5685812fbad7a9a3fe69f839b8ed3bf29ceb01113fcab4b1e9de9f0336c668040555b370c967b94956a25154dcdb4cb8a0ead135739ed6eb2c4fd43914bc50085b51fae92c749bdc8da7d505d63a34d3b7984ea205310272a62edd330dd64beea32b9679269b50dd97c96b62eb6f6b15c3d41d5cf93b8aeb1b7e2be47864a1bfab517275bacdf5fc8849402e4ecac0221a564b9ff02e572096f47aba6341c7bb130e11c271d8a16278ea1173b7c04a6d71d42b07c1e000dfa2e045d3bc7d0439cd09b405a54208dfcce9146ed3b633be2b83f05e73b9229f4f571ad236f1d4097aa82c3b912483d9708f5b0e52115dba3ced7222a1114013dad746ec29e5c0181c680ff2303950478501a00600f27506085d78a627b7e6a67f64382e05ec3eac89202a861e7ffb11c0075fa91e8bfa9037f95ae81360ddc2ea2102c0cb82fc2a31bff54d8cbf5cce3a3f9f500c18a17c2d2c6c8476113caad20b88bd4024264205fa082a984b7662d193910e7b9639979028d3876b9b93db00a5bfa376dc4c10615744e2d802d7c226d481558086136161a0dc9859385247e601bfa3f48d78be4495cbdb96bdf4a30d96ea0285bf1464dfb6be19716df86271b3e712dada49872df16a7362b4b81417d8448f2e0974cd31334b1a06fe52ece11312a2a68ed367913546fce8e29a8abf16e94efda2eb9cba49a0b6b53c130faee57301582d7d6b2cb10477b15825c4102393e7e84b0de755eed21e35dd1635e0777d3f6df6e402e2cceca489cfef49ae47d68899369b36f996bb90a99961bb55adc1493c6fffb4ca1cb0f49751c0acc292b96d32810fe9020e5c42174ff418072082c4fa79b3d410c7986bf6cf9aeac44379144b186cdc7b991d2542ad2bc5a01680b05b0194f44be8aa29ef959db925ddb374f31239392b161731f5bc44fbe615799f338cb38d4e80e800ed0065b4a1c9212ba3cf2a64f1ef0ffe01e9936c1e845c508923ca258eaf044b7fa43d0c8e7a651cf1e1c218762779452843b87362efc4ea9b252094129f4647269fb812dcf388783d29df2111cad9423793a7210b493bb418a54a6036cbc0367a55dc88cbd1e604aca3fd08b3a12110dbc0cf1e19fd11f77ceb6bd5bf06d54740d0d3d9187f01d939e4ccfb8debcec3494a576d3150ccc16d85ce6748f2a391f5b7db19a3980d07c83817e3c98312ed4d9983cd909b81cf6c7e1a58d0e3e879f14f20ee5c7f92d88fbe499e59a66e4f2b55ab4b9d594d3c238040369dc9853109b8765d9d801793d2ca1da580a139c482ce248d4153ef9f27a74d5324088dd91e7b936a3b190dbcd781f93b52d7b89b7b6cfd60686017891c9953f9c069b9c3c4c4ce2417b10ff53142a2a97674e4f7df1bd3489a51bd4a46e5085213c9bfdaf7005ff1fc81a6d030e4f2d6a07bebf0df48332cabf03f77e254a5d3190bf7c9f7f8d17859490665de3837c5deaaece25255413fd70f82eb1ee7997a8c75575e5e2df6dc279432786f82bf6655b16b31474100f03c39004326af628b4df47caf69b06702c9155286805f9e91d540faf0ea7af8c4b70d814b8787761c5adfe08005cd04802901eeeb640d6a49197615b71bd1f534850b6149f662b417de6e9ace89a2d437df7c1e761fda3421382b3eaee0e6f66c5172ace2016c3bd9b33484fae26136e30f7b34085d214915a60add338ccf0ea6ed2fc88238f60141290baf9eeb2d48fa50e92a51c43239db9e0c176b7e9171d6c02b7409486f044068d3b62dbfa0204cbd6ba37264af2e9fa75c4ca9d35813a2cbcaf5de87831781c1b4f97294cac9e6d39cf6013f20f12a9e6fd566a85dc84238a3a5cd82c7c7db23a91ca6e2c24f90e7d867f088a5406be9db6fe53c912a4971de87dd82f15ab222a68bbbf54c4d8e139c468bfaaa3c08bd6c58d17fe64a86ba634aa09d6ae877614f853a5b2035fd0a04ef2fd04dd80f604495df033fb0bf0a85d159fdd4ba0a3c2a9aa163ed38d12c5e8f4ac4d72a5539d69d4f4e3accab379feaf5929e1a05b663f4770db797d33180aa69936637e3b346c23b6fe96ab2578777a5a87fb99c3c7827642aa8b7aeaab47a08a2a7f87786ad0476be68154ec2513104a795740a3b616fe05ff040d9a60c6238caef834e5e49926b7500e1be9cb6f01ad72320d2956be05e3ba60d052e6e844ef3cc0dfe544af2f88801461cdcefb65e9cb1f3b15e9960cb23c715f5862e50b7547ef77826d7b1de84d36dc52fe3e942f9e0864f6669a30f683d72ebc355530f126bdae1cf3ec7bfbe6ab43f7af5a1f4a2e35763c2d78d88fd0e399d1a89b655bb8e46b134a2e7e24de8f3d77107d7614d28fa937be881f6c61ed2270874e4e6866d9ef20972bde7967fc15ac93a0b6e68f73557096d890142bbe92d6072a4c431219aab8d171fb6415adabc13dd9138b00521109d680008eb02e14499f5bea9b530841ad75fd0c72675d4f7ae9d9e55a13747986d932cce423e524ad26e248a9cfd160b23a5b421a7e9c6f23a9d07d6a0d9e5c862dd693745a40893f6018ea4ab55fd7685e4f584c5bb31cf8cbad3899510e056e5665afbfd81e65ac81045fec8b559e5e584be6fa5e1b3663234b69cae1557c1f71f418ed88ddfa6ee083a5292850b4660e35075952665a6c3bdc9495cce8cf9997a1bf1e96bbbcdfa73bfd954b8d37c2601130ccd35129fa8044faedaa41d48c5982a9eb864e2aea29f8d6c4ceafe52c9bffd6f83ade5901a74fb0f790f3e26b39dfb58853c7467f486fc3064c621eda1556298427de81e7a1baae3f9e46e57f2b373a8c703ff637c5b1968a377dff1e2961070dfb2ac140e3a5202b7673f6fd59c54378d5792180eaacdcd79bc8509bddf5105d1ae10a0d9ba064f27142cadcaccd0ca8ea9a7f3cdd8a2bbd054e26d7924077d393968a4d27aa55193c257f83758844ff70c5c4269148da4eade675c56ccff6f00384a2ca7df588e3b99a938740e584635e4bfc0749a653f67946c2349585273a71c9370b1c17d96b229514babf62df6f15f412553e651c02b50acd07f8978eab1e5740cc3d38d7ce1eef4ef7402da633695791b06dae47c8e63fe6a442f3a07a3b8a05f2693adabc13f99315725fba8375240d8ebdab2e9d8ad5b43c44231761a9747a7db1d13561bfff4355a05472cf93432dd03442cad9a7634668b4873d2457591affd5e4229b6ca3bff6dc8ee4ad99370582e00c26642e3a4d26a4063fab22898b933a1fae8e28b7f9c5aa0b6f4daa5273c10f53c0a99d4dd7ed016ebd68d192231849838af702dccfbf98249d9d2c6c1e95d19427bf37ce0a3f6ce073d168275116de9e7f666dea8ffa3085f958c7080d5b7738556cdbd784798093e1698dfbbc23db341ca658ffaf608b44f6474ecbe770d64df1a47412f5cc77899ac95e637383834a2253aee3db3f5fe8401ef971df4286a10944d37f6d1d0a603b477eba4af3de170f3a87eaaef8a01de13dc86f7dc2267b1579016c50effd403c7e49f6b66d04b56c23dcc2235ffb00fdac5e6c142c74fad48a9d362d2587ce80faaf63b0f7f457dcc9a552f70bf7084685247dfd99c7f48b0e71d916af35391451f0c8b527184bcb064e1ba0f42c59248e8f761889fbaefb4a85e557599c9c460a7c362a49a2ea617868dfba43942ce48c8b51aee105959c9a67801c9ce33280a7fbc0ead8ea1bf7c876c118be1dc4c0f997bf8f2e457dbe83768fcb5efb55c3db3a6539d2f6da48101dcbb315451e56cba57bfaff75fdd1d1eec3f3943a6e28a6a8995d91874dc9112ede00811181763891d129f50678c70397e3551d74fc9e5e844bfc4579854de5b777e0159120701119743f6961eeb454a71dcd7e76225bc5023362dfc52e41dd21ba3febc8d6639a362f6fb01b2a935730e27214c3d52ce86a6985880925f0af5f2bb785b9eaa95ccafe54f0c601307c07772585dbf189b29423a23e30614effd3110597016970f4e22a3d8669c28f5930d74ac6f2164b461405785f3c6039a7547231074aa8074469d35e4b07030cd9f26af00a917598256134513e6c271461b04713b91554fc2bff5a12f43ea3e40b2ce6e6fe16fcf1b13f3b83ba3d3cf43a8f00f124abc5d6dfbea62fb39f20adaebfa5d357ffac1428f88832bf03531b202dfa72e3503a7caa9731308d3e79e888d4174c3d159742a0e45bc7aece734afcfd5c7edc68e20793b2f29c5a347223db98653420887973e60c028649428add5f19628c426bdb0cdb65670d435e01355bb4674bd666f12c6df0e55e52bfc9d40fc64bd5253477ed01512bcee96dd0e762528e63dc5b5273fdc374e2df3d281e90bb3d985b327bccc292a6e91c11fd179cd9958cd18a8a8317a5976de40aaabe285066f2b94991916fded3cbe01ccfb3e66ef63e544f8a294dd70b305521776104172cf65a4ab3fa5bea1beb85ae7d6d66f2e1413c9ceff4e1ebdaf01f86ef91844db9d10347c653af11bfc5bd84cdb6fed6ac5b4694bf560313111e6f6a7e2e12309b1d94b88b92a1c4c78cae80982c1691e810e5031a5507b0360f8adbc681c8650173864cdeec2319767e93a8fcf6d562549ecb3a7e85bed1b4a6f2864bf85d25dbe0f3ff33b509ed3c1ade14277fe87a683b13d72d7c827cf4f6954ba2a2e13bf46c5e3edfc7a34581d6b5197ca8991544ec3f27a475bfc5d55cc9a7f3edf006db8c85092e86372ded65661d836582025e10d9aa4418e88e7b1a124dbb6ab43cb2e183149b6525a1de8e411cd7a0db6a58c2e14bf95ebd2b931263fbbfd13847953bccbf53512f50b39ef8997bee3b830084ad570c8ae7c6b8e2d10667641b397e20d76a90643d4c669cecf76d4d71348e7353f586fe0c9e8298f8cb484c84e378d1182662ed21c67cb711bc43d9da3b7ef23e553d29d679f9e1edd1a9024bc049f004912c1bbd10dabcbea6c57fb12eee3e97bdc3a80e7dc5cb172d1195ea4338185828fbdc8c18b120c142bcdb6a7a181e791dc9fdbdd782e5f40f2fc91450e2634ca6a84453daad27c0b8ab2064dc00201511319ecb406abd0ec14111f7e2f1c39d3b96e9c3e5d2707c7125f50fee542d68ea00a60dfb04ad61c486c72b833fc28ec77ce599b25db9a52ecd42193630ce8661fffb9bd067a8d37d207ed811f0b5e506ad4972ae30272deee130700d62a824e7dd5fc7d16b1f290f4dd4f009a944c9b19a57079bb4785e56f22c2c3b6048cf5caae5af3d09ac5c0840bb7bdffa041422d1dde6fe1646cb3db61aab822d3f6fa3b5cf75a5d3a4fa3b8234bd4e2149992d369873463a4f895b151983c7144061c81a1922e6b405a48421e116c8227d34e38ad1a80e2d25aa72d73bb4c5f0130157e6990cd64ce83f39c6948e07bb65e7c62e655793e4a867262a04418a01339ee346ede8cffae3ddbe7bf79a8927090351d4ef5d5d390ddb0330c38d57229df232292fe1baef12594256a56030a5cae8463205f21a9e49f46092bc83284ae0f8602ee27c4ea39c35bbd3bfb04ee93e700346c96ab9a8deb30f547f0f86631bccaa1d6deb684f30a1b4189fa74f762b0ad808cbedc04dd81e1a4044a5d91d1f969207ba87f016b5982f601f84fa626745208c292ff377d628a97f30471df302dfc9b7e6c73ff76c629e73d264dfd5d7d8de0ac807b670628be1fefde3c831183db8d9771eacec749e90ad67b1dfd07163b7c59fef5a68773b3c31893a3e731c9d0eb060dd4c1559fc8f51c6a701ff971dbf623c8adecc1169dde615339d4e71ab85fa0d83e6deed956dcb3a621ae72e3d86d29fc891d211c746972d19f7552d4224218d2070e387075f0a9537b8e5fd93d815ce207baf8cd61c993fe957f33bff02faa84389d55760f271c01cef2cc0b20377c9355a0fc965b947f27561eaa9e58452f5fc8cafc4c717b65b423ceb4aaba6fc0219960172dc2f1be43d734922c52aaa8a110bc019ce5c69eafcb84d2241a072c9208bdcfd42cea909ace6a6407df5bfacc472963a867876e6d1f14468c89335944a6c97ac3f1a72c72ccb2a999b7e9b2b7ae293040787db2c412d4a669f70811f24a4fd69ae574ed91c6d417420d453af84ff591585284f2f9ae536fe8d6ac620ef4f32239ab530bc3709db00cc82b33654dc03449e355a71c2da42bffa93104e48b19f61a98639f934112dbd52dc67df24b1c6fc02a7b806a871616377691facf170e6b3a20ab86561baff19986ebd4d7c4b782b5e69af35a5271c57f0069a0e09ba775d4989f29b2abf8f0dcf3831a34c3972be648060902aaa165a52e191d330a3e67951313b6f9e8128d46a7fcb722ec11b98000ba0e5d15415fc70a118388a31f052552030203d9a55a1d8eaeecc4be47d5c61cb1677ffd7c42b00013695286d7b0c701893b711e723f31db11752fb854ecfe28363937784f93967ac65e2bf5cfb21ed5bbacf236fb384d70d118a1fb3ef39c4645d19b5dbb3b0c2cfa106d5e909223a3fed7c9cc24f159cb1c2fd3b2f85af6a8bbf29c296300a078b64489eef5deac9e6fa30e5c1bef82d7b4c44e0713d0693eaa31f2a48f2e0bee3abae2ab415b74d6800e3f49504addf4ed09dc62871c2f80f5824589e367d9dd19ab0966bf8595bc1d43d6bd3a49759284c1b967adff370a7d14b71b13e02db38d92c19db7c3275f31d33f71527f8b66e0f8fadcd1ea12b00e04c546b5a01282986d291959545623f0af648a77592cc799037d60b60652bd4bf4917a349a5dcdaccb415a6556443436ebbe556c48b794aaf6c8cf9230ec5349feeb72f17c93dfe5338200da789df6897593d2a7e40cfb413ed0996223e28ad9b18b3533e18ebcf5153545d8e0cf710f6dcc8d57701d16dc71f275d7959abc66b28d8911c2dcc146da893ff7a0c2abb3c3868bdd0213da8048a1be4f6bc2ab0d68c2cdea5d29d6965741d9b9ad6c7fe028dc752a1e98ad1f222b5fc8b04b7a3569cb8157539e569b6e8a47fe01ace84506da8f5e9a942793f453382100706844fbcffd3f4d5250c28418cb3e7bc939c4cceb75c57eb11f1ab7c7c7a34ec8f8e3ec356225b26edc81024a2e445399986139d773047ff135017fadc1dca0c787addb4488617f5fb8c12fb84d0c5ed685a29a620aa9ea2fdc9f2b7aaaea4e4d240c2e9237a3cbbaf9bd32e1542b9d0a473465c755e5b2346ed8ab340c41b79728709fabc659c98cfa7048b338e4aec2d9743af26c909e27394fcf92b27dc63a4cbc8491b5835108e36175d679f18c01c449243a0b613d2080724e1d79e692e4c66c8c03e08ba6b113d6303978e1c954a25f3d342c1781ada574914d23e889925c9b2bd847af372f8ea14aed0bb2346a2bd4c7dcbbe83c6fd1dbc280bcc8eb2ca0e7550d20d5e3d0c03987eafcb1f418727006c47655b5bf261a27b7bd29ae557826ccda17a675357c5f8d0cba7a288cc6b7086de154a43b608be1bfd07ed789a2bcb83ec6903b6095b47b892458aaaba2788350920846d601605e36c561c5dd654d996d22c2bb10a7641e3e14a612263d4e80a6b28efae480d3a2ed5d47b2fb00fd7e96ec290a72bed748e09472e28f41bc7830cb17eb506c93976f851dc2c9ad9be3a7f9f477e07bbdcab343591ac3d451af4fb3bf40daaf2de502861b5b7b458f2ec01650c121f41da5fdd7459983c98e79a3f0177d1291ab11ff5174bf58ec767cebf7aad3a7f6fe6da0169f36f9a5a9c3aa334c6edf7e933092ac05679754bb10e249fc6a6f031ba6dda691f687c4a918d3045a16cc5b9bafe08d534cdfe132d0333d58d45ddcb4d7d6b65fdd90f213a0e9430df271129635c1f80dc1fcbe31804df9d9a23c855923b34d767f35ab22099da1893ad066fe1445e586bce467e888e8b18d27b9d67798145ca94e05c3bf4b042b87f4f0f79f1ac578e344454032bfe3aa706d61cc5919fb5288410d385be968f49f7be4505aa73fb1bb4a7d0c9dfabe86762c3549b1cbb1fdda75fa6e7902b63d7678023345a0257b16e5498b3846c0be55af1aa6dc4538e5caf43e3d5fce9082dfd79c15d7bf49b085596d37db0af1be5c0f5ca347887226ecd78359e23083a6ce85d7d72eaebd41142c0f8c84b5f80ca456a3752d834a8c3c4b58f87847e83575413d3aacc8e3d36a0c63e92fd35540baff311593a34f8ec795d6ae9e205d75efb62c11a6e4391a4c51d00f4765963792502d0856490bdac5a3415d642030aff19150774529133c6bf99509065c85575db2e36b73bd53a78f0b137d121729691863270fb1e4c25bec9613beb4634131f09464951e518164f80c75a686dc0991a46409f59931ac53eea892fea66d14cec5687f29a528b76c921ee20513917b51c5c6a313de8b011ffc5abb01e2dd2e2770868b550f07b3ae0df7e4b378b77f47d4f366c459baeb09c196d63a04272ab1b8d6b332b3cd3e69228d0b28b143b2c6e0c44aadcc35a303bb3789a1ce9c3421e724fc6b60517611b5d2f93c1fa0e58c487f77789ed7abeed135cae344563e28d6fbf8fcbffd81f255149616dc370d50149402136a3c146dc91629ce76c0f5213c5953a7eb444d61e3bb5cedfa6f7ee93b8e5b830768087cb56a89bc4635e17bfb18deab757b172f7a3171580ab2a2fc2f4482f191fa728bbc0c579646cb2d5d7bc05a22af68a3940dfbd2962788c0777c142e29417f00d4b694bc085809d3e976cd40f3b684adea42335db82aa5205d21de85ce7a9ea870509a5e08516103f271415b8a847dba8bb89d5fc32d2ff6e2bfa19351ffb95dbf229959bd03293cc5c64189cef121f2ddbdc233852c3913744203fd3a65bd0f958ba4e49d09c3698a1ea065004b104287c8d65960a0375ca6a86bd7d728e69b75d8ef3b95f8623d0411d87362d54cf39f47772e3da4fec716976cb54132730a8bb229ec41faf17face5bf2b65451800e38eae36dc2ca51bcedee9d075f77418fbb8b213b81db69d29b77ba0f1652ab833a6b078a69f04b11a1068f7613a67ee57a55ea4c890ff8e19de30f7afb76981ef8255e01307f26d9c5f9ec2ae257a853c1c51b8e847d2b2dcb04fc40ad6a2e265e9ca523df1f5c9b2da987d632afdff688a6b8cc2e1e50508f3e904cf480546fa82d1bf6fd4e7e73f3f34d2e0b63d84b4307499c6e4c835b0e4034c554c4be23218a76ada2a1faedff908006821c589e693ef668638dc67d8a8ef14a6685f2d59b7b3e5ca9c0e41c4fc66b77779c9fc0cb20daeab4486286bf9d267a9a4717837e560ba5a9b8ac20df8b59337ffed7337dbba2a1268910f324edef3d837b231cdfc64bc999f80675e79234285ff78ba75b48e1d240730850b3f2f000baca18b34333f7115c54cca4ee4c54bf9d6520c4ecc0c9efc7281b94aef0472ce4c1691724931a1ce66bbe10ad4c092554a118c86770428eed67cafaa58b72bad82f7c8412ac4513b65f6e601cd643e643a8e1102942ef4cfb01e4c95bf66a3ce5285ee96a12562dfaa49f49d99b82219f49426615a8b2e63823789affd9a0d776e657d440fff54a2e6ed15150f091bef9a9d7404f06d695871d0673adbd9d56be9d2073d14715bd7631b2abb2679bd1cd1d4677a3c910225850cb3cfd28ff401459968df1e67fe8374e59b3680f5ff676c5cb42eb8a37a838a78c936b1db515cf2a315c1c49f473180954db06441bda81b3960c8fe80c0d902ce5f8827a6d061d20999a14e227c68a10f669594102ca665fc0115dc63540cfb1cce1ed15b8adde0cce0e43dad3435f5d8a14d1729ad19b780f2031929700238e829adcf4c3755e29f58192fca9178d27e879a6cda5adc5819b67b2290384bd052f905662dfd25879ca6fa6fab06bd73d111d0611ee7d4cf55b153d4d00b762c6bc83d3adbbb8db618ab8b244d9edc276495b20c5c364d34d00be146753358de77910d01d7b2b0915682ad52e3236c907b568268908d852ba19f4ba004bcf8c073d2ed132def9e0412f1d941a5eae76ae91be930812c07e5c6209019f69707e0a797527c05dece95d04f640a71ab33d1ebeb8fceea70210330005a7ef7af8d9013ab5bd7689093cae700918f0d165f9c34cb845bfc7241415a4f701b971ceb62818f8fdbb3977ba4b5c4a9fcd644cdcc45eeb5fc3a6dd5099ac8af0b73abfca51b1e2dbf7a19829fb14ec46662a717870d9f7b59e9134c2bebdf3f25cb0ad4ff89b272371b5d2ba433adfb4a926c4d8d008e6b425dc4fc469639a5416b21af369b625901006e9151ce64c04a45f3caf1ec21c5909b4116c0de44c35670c0b47d10c2b042cd626950cc057feddbbf1bf8b5fda0169b899e5484f2ddff9c7a2a07cd5363dcd146020416e740e95334297ed3772a6c231a05b940e358cf573e37cefb039076dff2c206fc7e86b78704739ca3c6542d4ef806d2dd5fd6af6c883e59aaf3ec5b01c866cd4e7115223ba411bd7b3336e1e2f0423ef733c0784740560d0cd49d52067ae16b9bde9bef0d848aec8a3c3b7e844f65a08ef6f9069809fb23dbed3a24c06dbd39d2fed9741b56a393ffc1cd42ad7edfc399c0a2764b8a58f888179c3c585e3646effe02e1be8f45d36f6bc9eef47fa1ed7f0f2e188761371d2777d3863b545e5c73443590b16837f3c2a0591fd64c52dc43da7a51bf981ec42475d600141334561b4c0a3f7fea5e5a888c429849ccc16d9e93bef1fb31754053e1776ae3e8ba024672ad5c0e047176aea576fd69f46b546e887a2de49089208d0cefd682bb3fcd41539dd13dddaa92fa185e53db4f50ffad29174844b37bcb762eeadb102703a62d764a63e79a9979c1fc6a29b28391edc66a07b1b3197168fef3c75530115862cbe419d1b7a4567a14782d4cbe1ffa094aa993a97e42e908c7879cead8e467dc1c38cafaea14678900f247dacedb9c3a5933db2c99e3564bdf2409db0abca27","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9f5ff0ff6ee2e87f5318d50f61aba1a5"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
