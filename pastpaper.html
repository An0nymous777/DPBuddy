<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>PhysicsBuddy</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #F46C36;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #F46C36;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #00818F;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">PhysicsBuddy</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Sign in " />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1e97b7f65f42ef3242db8fdf06631bd1a1e49bd17066c629ae06a934aca26845187f84a135c0d0f69f6d94d78ce9ad15b11cabc7b811b10c00e8a2db79396844df9681c848fcb3898b92e2144d6707ab7b38f4974f4d92b21541469858235f626e534b1275f4afa46c24a8e710f49895ce4f11958963ba9b2e85f95dba60e389ea687217a4d668a186b382c01a5936fad5f5c26b7ff1255a02897b863c93d0801efb6ffc5545c40b4878ce9a2f884796154285499ff5a5a6fb6f8e6b9655ded58b5d64ced53865b55f41269522a29c048a2503db40fdab7887203aeb11a35082fa81c73d0f3d44e65a8d1fb8ad721b076d714305d104537bc2c94eab88c885516a97c33046c021fc39ca1ad2341add578c0bc57c10becbf0202b178feaec8f1165bab8db5823793819a0ad4f4db0bf2cf868f7c2b5427c316876e656439226ddfcf395637181a6400670222c932643fbbc89b1928a88a47e977a13fbf704a45fd5ded4be9cfcd575895d982cac912a38ba455273dc08c89b56cc751e31f64e94cdb7a3243e098f96412493a7e3e281385ca9330dc282e75047f26380e0638a70fc8af75b07f74a18ef997f5f072d46b2640891c80cd849d25dbdd7e6450887c15a14d70e9b3483f8ae5ae5790eabe57035b503b6f8446089b855ee0d8b620ec7e384c316c7bd6cc409df2a6bf4eb5584b5336ba5531f12125ee89e509d23b72b2c4890bccb1f42b9ed046e42daa95bdfb19cfce7723ada5772f4acbc4fba10fca434de984c8f71f6969042187e184a92484c9bb73e793aab5449b79d9bca17e4f50cc566a6e9d374d89dc11f9e91ee5d313be8e5be7cc991d0534877dcff478c119124c75b7589a612a50de8e6aa69f2f3f4af79dad2b1fec828816ab58dd6881b49dfaf2c3f1e0fb2027339ca282fd7d1419284ea4f949ebacfe021997b0765f1d0791e88978eb07f5f4ea1f351160570282a862872db76988da58bf557bb1e800cc6312d22dec11ac5b6b14d95cf71fe56f932187cadc7f9db7a1c16aea3de3b8a0890dffe2b2e0ee185fe66eb9ecd9dc067062fe89df25073adfd6f710b1d0ed584611c37df9ce7db64b3cb67433d4a820919bc9792f19dfb0cb165ff4cb7d150c57ca2257317ff048cd2d7364bf20393ba01227d501fce0940df9f2560febece8d936a0c7c942dbc269cd84e3defb80dd8530acf219a3750d0dd0726166130c24ff11775237c5e05f58240330121565f46f4a00047447b4c9325123d8e08d06b017a4a1c1b0a69e6a9cf6aa3137363509796f8ced2600e30d137d3b93d267c859a28c6139db2f81aff4dc2a19aef654862207051d3182d49409b1aaa2b14a51b4a21a13aba76187ac50b81a5a1f219f4928b2b9800fab4f9587b76d2c6bfd0eb5f00171bf06c8f325a2d6326d5ef00a71539487ef59c74150237f9cb93268dd88790f82e77031c678c857303a70d996cf7b119c68d15fa1dbebc55b485120f3ef2ea5867dbe6a039c6881e7724d2af254cb5cd02c10cf0ad96fde84d15c356897afb96a88263218f0a1b84aba7c3b790bb078b599e2d91f7d382e5c80f40f3606cc529ed7f7607151322d70f06d88484abc10e6aac5f0b29be3bcd47aee1cd6b0baa0658a43982d31ef311d478597cac96ca9e6a61b2e91b48ff5a4b2f58d1877ac445d9dd3b9aa386e9a14a905eed3035ec02ee7a21e891843b45d42a39582306b9f03cc2676c129803d8e5d0258a8f164a1846bafaa036e3ce638354ce81a674b16fa7eea2a040783d52dfd01cb64b68dff6de23752a27ca69e42a35cda9d9395d6ea7c2f4968911af5657b47e21e1e351562dd63edd02d0938c2bca064253fedf91376b0471a1327780ad142935b64563c9ae97fc3db1caff6c83050bb2e867ec1797fe99da76104aced6007ed3ea75b79dc3e3d35f1a839f9e7ddb1688450dfd24bb60df50211d5956f6ffc5f7ce1d6ac4917cab738fc9c0e8d761f4cb74fcce4a00aca04b8ceb935bddd92008220ce60b816de8a260f242e8c120cee5c438ed656b347daf0144103543b84844d5fee7a5dbba1ec2d02ed1d141450309fec5ec2a347ee6fc0372079f7bf0325324806dd2ffde492716a225b122bfb3b1c2ddede086af26f5cc07f83ba386d83b295474b0f54e47f17242915aa55064d17ccff347744e092cf109cde343d1a6f44f74e17418bd5cb4cef88e668cb0030813733c34f84599ee6589296ef9c6379de079a5835c2db9a3fb0fa0670379e6bc80f4acdb79ed0e2e6df3ea8425b2bcbd851b7c9c1ccb1f0f35472d8a1035b91ee808a0f9c6c5c91d1cc897cee118621de277b9fc64ec90bbfe0ee42c11d8472a24d189dacf23a9e4f8f3d81c3e5bba14e3a44e4880ff4efee0b319c59974b31bf743502b9dbef13a8691fdc471f86423bbbe33fb142d0a4848648b0b68640135af9cde36da0a2beaead264f299dfd0624698a834f0c5dc10a06616561497c380c61d403c7a13a53de1d2c66b9dcb35b401c3d6579cdf0968800e4e0b00bd7a0582372996c7b1cddab25b36641b0745d7c95c2b169e33b8c42d183067713b28ba1194e6c4b49d6ed394fa5e76c70cce3f14eb6bce5a5acafac53aed5274ab6945d1627ef389c7685d09ad4637228404fcc057d63d3f47e3e1c8fffed45c82ad4753c1b4056f68099559186122bc9c6d3827af281f6de9306165450a4c5ac25652da0a10d3c7a07152cc8232cc345891d898979a2334df4d89e3938ad31c530ce8d63c6d3296d8a8ae710653a133a381a38c97f006a0b58a2bc12e3bd747259e29c9297bf6fb08e486f787f0938d44f71676385c2ed83ff9740a6e2a3266a0d040a498ffdb0d0f72976467c725e7e4c231a280ebe56432359e469bb637cf47a9264f634cc4dd24860d3313b4fed81f07a1b0a8fe587096534a3e778a569c96d77333c9ac8a6014e3a5f3d34268635517d095cf458b81b4590c62918b1df5381135ffb58559fdd998b909c17b203e3bfe6a3a2308e76dbc5a2aefa0a827002a06d86464548f2de5b7f70198c360cbde5c20ff5b80b1cff0e98dcb8ed7cb85fe72d5f892e525c9dffed28f20129ac871c43a91ff942728b4c20b0652f1888cae66c46caffe68c5e2348aa9554571823c322da4b26d177b05644c2abb2da12d21f54af42b3d8a3e3fc575c0c4884d0b1b93393ff2cd917ad2cf2b1ea6898ddebe2180f10edc0bc593d36542d3067b64e536719aa9363613ad9afacba2ec81813d564107b2a169f290ca437ae8b6cc2edebb8fb86ddac5110d5d275c574c33ff2ece92328ace57067bfb39d64e687fdd7a962764e018e0415a0fe71b4a624af5703a4cc6724374acb3e82a10f25b4943811216aab322e2e6d5eb0bb94b7dcefe373eb535e869d4839914cfdba6cc829dedbc295ee3a0bb95ecb4ff1072c72441c8cf17d17698c3effda00e7483b03cfc77b06ec15e9020e387622bec22608610a0ec073a94dd348cf666037354f964c0e701075850f697a42bbc3e68771373a15451d0aca76cbaa34a155b896690b0a36d400d4ea7578142b39f60e8b7ac09205178c54dd57ce0a9f238f838a2a5d808dc45f237d7f5371d2cccf0c6d4419301960dd716afddedaca694eda600fb8194b1f58e9dad71185d0738ca392581714ef68be0b4582337bfe449abf6d203452de6690b86f13a8260ffc24db2ce9d5c8a46230ee7e5ff60a15a7693b222ae414e3ebe13bc38ed0062ef1955f0bded0ababb18697c653abe650d4eb17d7326737dae93e9f930f85c5b756711a76e37ed8c7f6fe9f738817062d89850522f9037f6dfccf4792514e80c6566b803deea48245406587c1b703aa0a38a31f65e161a97d833d31e8f2b9e2b8460f5be89b33bb0242231d9877622991b2dac3386e1279b74bab158c02d60f803fc18453d3599f57736be837921d49d0f739ce25ddf6640b1797d8cd699d5a5962c15461415f953fd6219a8ca929ae591f21097b59163488aebac97ba3ee4bf48de31e1f7472a01e943b3dc9eb60b184f44951997dedeb66c2d44575b9e992646bc6c5bd9edd14a131b7db1ed786f99045322ba931b5764c87cbf5499e44f444b0c1a55425a04cb232d9cc7bff49b43e1dd7684611e266f8effdc7cbf30ed593430a4407dbb113061d6e1bb48c43397e54c1129d7946596a2f967fafde8d519ee95a2cccdfc81c5a3ac3a8a92dda1d4b981173770b867c1ac90fdc23df36835fae6f343fde76e21c7eb1bcc40508edfc80d91f41649f4c9c4e74661dc8a9187b9b7a3a4c2c23fca9c70abc64e3cb3cba324fb6c247f3cb50a794444e588e2ea11979cd41eb100ac655d9c230060aa43cc1a9d2b7551e358c38efd508aff9df44f97796cf75292a3d3005ae83a08fe83cb781d301a132e4a73d5386c0b138178024ee46f5908c5a6694a05276f44135ff45e6683359d7274144ad3a76ba4acc6b19c64ffb6d22cbea7844529776a9e42719887eb42a12921e1ae6c71f5b2d03bf95b4874765a475954a7b1ad1d32c7e4022d7251b539cc6bfcd49084ab1d485efbbefcfa6f92ee4fc124c2cc790b550f347fe55e7b75f711604a7f5261fee69d65c8e122f211d47700e4a54e86a1fe505bab5a268654cea9b03b5fa86b7021fb473c2d9f1fa76a853ddba258a09f82afd814ab4e8983921e7fdcb7872370bfe519c534a1c4efcff40bff1dacc249b93bddcde6de9fe0e0b9142b337529b6edfbb117d132e96ed4b1ddfb58356fa62f4de80cc374f650337fcc02c9a3383272e2b650074a7a9d5564421cea0c7c2bb88ee48450c09b9fcf9d99277578997c17b4d5a59b2e8215e18ace284cdd710fed61aed738fcbeb044a8186e86dc1f1bdffb7a76f461f05608ca50eefc4ca056f1b44281529d55ee13932d3eae2c88b3c5901b07bf6b7c59b103bc4fc002248ebd14f046b43dbe860691f6e5e5b9b563b61514e789884f54c993e0e311252fcdfbffa6e7fbaa8e73d485d24f39167c6a27a9003eb0df23b56e46df31d8e78ab9c1118dd5bcc0ae6e4ee981ecbf73d4169c2c6cd3e499185d656daa2a83930daa279644b49517a5d4691176ae79e8797b1708f47869ac9d126f641db042503db47d39b3726683a863595111f8297cc007e944e767a96c34454ccee38c705d98c97d4ca94fa4b49af50dc7d94ae993328bf3883556e77b5a97b61b82b676944299be710d25f69c53106d95f9e818ddd41793493ce9a53bbb62458a04fcbdda7497b9aa9ede08536b2ca26a5b80d7cd6dd0c9b69b72e316964d5b137f6aa4a224851851ba486b5588f3aa75158f7126f5af2eca14ac470fbc7ae2be93157ed92fdd5ffcacdf1b8597763b71790674d19c8631e8c5dda0ecbcee5d16f70b6dc213830cecd18ea4bff5cfc92b64d1b79fc6eabc24b7851ec99c7db82a831ad1e8cb33b73857c307f4c0a6692de14f792f9dff7717a15bfc1f8c2667ca4fd43dfc0d7644408a30158e2e552ead03d83e844afbe2073678a85a5d4d658b60533ab6fda68f01ec7c7ef8afb03f6fe85fe0767be1022b85a91cc542609ef534f9cc39eb7f3ab634150ad1b898d594934a41304e2c2628970c9ffc7d4eee853611ff3ee84566aebb2d18692d6d1c0e273affcfaba3b98c44cc5cdabc140646b432e1ff3898112b7d03cbddebd1255cb9aa7f3b614047c5bf1ed988393bff4c73cfc463c1eadf10c43d54bbdfcb9ad5e820b0e7c2c0a20230471a52f21c34415f7a5fb32801290774b09852366a5c737e4077768df0d7c99f103c023137edd8b7628a7409ce9d1a1f34c3c6ff30d938707e0ffc4e436be00fffa77d67bc8a107fc08066978b2debd3e36193730ec890180e1c9840b31ecf5c745a849045903691af81aada076ad18715485fc176d74452330d8ad58749cc394e5ff836a948a7733b403219e9665ca8506795a7c1f501b9ba35c920deb99c402452fd66503c2693d35c65ba73cd901efd1d0d3fed6294411f2e33dae2f48745f6503e793243a52a45ac3f817f950dd5722271014cb9a9acbc78f2247f563ef6c1ea230bff51b98c9744ee8c54b2524bd3fa63a3c8d70452a32c0de3988d5b1a67625a6172803554cdac6fcae218243af1ea9fe6e7b5da48d39df381b18722f3aa43edb215380e4839dea506ae47450f1c638adf6edb4483f040306edf307d5c3d6ce78eb25842a4d1c08c5aa2ce7d2d7e25d8a02caa32d787084316591cf3c5a36ba3047d81f76dd13653366edb2a1ef569baab9fd323f96d6abb4bc9191f9020bf46f1d61a5d2d1f714dd4cb6648a4c6c280ec812e359510bdb9ae29a3d1ce990531457ce8eeb192f9b92c69a368426e43541388bf1f1575329dc04b4af59ff6ab579f7c8ddc87eeb72b8141db4a36268c7528e4b6d804b92bfe6bcff00bfef93bcae9ba0056d5a73ec1b6ec96fe4a259969be2860268aded306d2ec5c0e27a1ea3bb0b28b187ee513f62687c6bbfc3419549eedf03d346c5a504e9c5fb299f47ce5d0e5c40b57ced465c1455712d4c579b5ca902e9b238265061fa78e5c876121b52229f5bad7dbc56d24f115ed2d900fa3174aeb64b6f1c3e1e2573bcceab46925f2f0e92960d2a7ba347ce73d17d957b67f48b4e2631263083d777ce394f0ee87f4e6e02fdc7293593b0f3313dc4e380bb6674419b30bab0b82e7f34dcf1064b343cacbcc1538fc84b899a3971127bfaab94d536f2919f881021f7716bc5c54e949fb628bd5deb9cdf35b7b8a982767e8e344034dbfec7b9b342e85d0676fcb20190dbcaeb3238e33480a32307027ca7c38b85ea65188179f5e38cc247067e3164858d1e67529edddcf02edc397d82de020730f38e1ff9506410e12c2d0e99b39739a4a2cec6ea559a62b67891889c81546f07b68310e8ae23841f535f2ab0776eb22f978bbf1b34b1fc26e68b83e2d30f8cb6f8bc33aee915ac0c80e5b3deb4428a9a43aa6d1c57667f26ef69f56e83d9eb045bc1527dc37d245cc211d512dec79786356e87314b2bc7385eafcca62bf2104874423fb1277974afcefb7ec7f38ea92f2a9e1257eee6f32338cc86c6510b06e737eeac478d6f35bb7623b461b6fb5f8d22bc56eead04e1c0647147bbb801b37c4cb67dbdc6db6b73def32456b83afe6f479d55c43c4deeaf26a7c268aecb5f1d61cc56636f25300ceeb90dbb1f3d7fc2db79e9753ff72a793534613c8e423d878e79b228abd1f16bfc4c61cfadc1403d60d519fac3161d56a45bd09a56a4813cbf84f26fcc8d26a7e4df13d9eb174140d6388961d2c8e2c91359dd1d6b851c4ffdeed7e9b1537dcc1201c4a4165f3be5eb1a88061d8a2b0a89ffe9427a81a7d1f0ab4c68ff66601f12bc0a11529a90c8085d73342b9ec262a023f5b63a823490098dda6d685070faa79466fcb0370795b900115e37b0238f700a8960ff4bd288616832c2121f05ab6f0d79ba1b237c35f5467a829afdfc0c21e2d0db00e80b9d67dc94fdf801d60abdf8a252d87d68d43df7ca3dc969d017f2b29a70e875bfb0d7eda3395c4993aa4d8e156f0f8d6e9591b5c8b67e37f6e77001584dd2372d1a05559fb5d0dfd0e5cd7776ccbe5530752d0c7ebd5f83c058d67bcbe39243eca453e94bdc9623ae73522b9ffdb8e2bdd4e1ed5b3662d0ed981c76fac79015426b1941d3ab3488638fd81c0ef4942308ae85c9f0be214447066d17afc728eb90b85df0fcbb0102bb981ee51dac522ff3d041d1325edaa319adcd0696f8782c7a62fa2e5b7e1ea3bd88be40fd383f7d7c286d856bfe863d340aa1e66d6e8805ea149111330b2031376575659928869c98cf3b431460967882197951db4e9bcfed128710b0371de988eb96461f6e3a7bb7a381cd651af58332c2cb11039f8f2f11ac4c60b6fd102266b8605f64ad8dbefa94aaf43100ef2384cf21de230362a3c09083bfcfc9489a8cf5302e93c4382baf1515804e2307b90c21e7e33dabe0a977d8ce9ef3ff23d93af67ee4e585d60422284376af0077f4e95c553b2cfeaf1df7821092f45c1d74ba0641710349f5735c43ca4029d461af1812b922a261a105ca9321b2159bc95d74cd92341ac77947f83587724e63b0c2c947c2763cca5d642e757718b0e857735acdd22b14deb413dd74cc69b9d3bf2e0551500327ebf0fa0b2086443a581debf6abcc998e450565e6d6f374b9116c2ac433178cac0eb58aefce22e86fe96b99bff587560d4ce8cdda19595801bc3b752b24fffeb0d8bd8c9ff8ce533c55ad81f5600e51f8cd73dc4b0de3605bbb766f3d5787104e9509bf5a1bedc698610f13e1de45522d3d5d224f9ddc8489ab43b69435b81a101608bfcd080244fc5398baaf723be9ee18bf8142de30d32411167d07a68bfa8a548fd1288c5551dedd9da46d93b02b1764e59a4fc88b4f18e524ed8392c94f7f49b29e5752cdb09a9391084ca3e2534f49aa2df8822e5d7a21f79fd5896feac1c76f548ae47ad83a05444cc12f791d3c2586ba20deb82d39f0f1e8d1a594d67cc87954e750805abaebfe9ec97a1c4338eeb468551ff13f7a2f27a1ad66cc85f52705dce815281e1e9ed279fdea4356beabfc2517a1a466de26bea7daf9fd8acd5b7e6f02208a670aeeaf0c95ff6759c071fd874d377f3d3a4a054bf5be8f8eab51976c368530b4496eef18db5e57699389c4ea943bf41234ff591a09901997ad6ab8f9bf32ee5d0abf86cfc3bf0e48e92d6b8588999ae0adecef1f451e5f17837dbb9d503f32a375cdb19e8d379ea2758a007c787fe5e53e18effebbaa3b5ed08cb137c2577cc52400596a8e996e6b637d4d3aa1a2ce0b20b76fee61f2f7ee5067164e41ff8aadecfff020ec2787976023b0c87ff5442294d85f5d8173b3719f15cbb6fab0ee06fc0aa4a914795d27b799e86e3ee2bd2d0c75ce260a03cac2cec05e9ee66a8fa21868a1c4c1e675b439cc3b708e6d9afa0cbc11d5d02a88595efd2ba6d19b094944530c8efbe426b70d9b38c1c085322bedefc381f49d24f83379c204d2343981ac3f5977f42787b261e0b91cbe4ce6bfb735fde1d16058bfdaf6ec1e7e171f0a316b46401e4947c60e67c8efe1929d49973ccbbf42fb9511a5b05f603b71d974be71ccea9e7bc9da7a8a0bd5186a4af243a1cbac3af526b23e91490d7d168371f5b00cb60ad591cad55c1136ca1637bebe7f039141d486743ce81b77bd5396f947b49aae5a66b93362a6bbda21aff2695538dd7f1cd29ecc1adfb4e7238579ca3245eb9e71437cc37cb56702904dc07fc18f0a7296b41a12225d433d939dfaed5a4065ca6e48e45603ae80e102819c94d46d87549cf85c545510d11e1d28c81160d604204f1ffa1598910ec00252370328339f20511179f4aad4c8bc56d60d9e44695f679fdebaf339e139660e055255743ce98e79b92771173928528d6215f6da9a289f3c8ffcd440724115f255c143388fd600f14c8349a85c4bd35d4f420c3df7fcd68fd9a7d25edcc9731ed964a410fbb5534b6a204249f6acb9047be86cca7d7761f7e261d59826a7d207717be9cf5ab53ffc3666258c7f62ea9117060da0f2c808b8898f2176816cab9bc7f6329829071ab64bfa6a8b0d0dc87933d5996bb7e0d99a2898e4fd7b155c0635948f9ddd94fdc34afb4a15c33ee1279738f8228d63e360271fab055d56d9373437e1b164632c4a2cc5077f783e08de8e1c46bdc11a06453c9279c21f91093cb67ac37973778cda8870f332934742c7882f72ee8f9fb7e16036eb06fc9ae0e54ecc14b91e968a6505e3aec7cf96361113a3a427f6b43af8ff071429d308ae4233cec468e127d047aa2d2b7a2eaa2373bd0f5bffa0bb9acaeccafe2ad679286f4b98c5062dcb05a2fe41d7953f7daa2f5a2a9447e82175f4310d12c3a9e8d737ff5cbd41b0dd2c115b989180d2948dcfa66400134fef8d1fd92ae015778d71201182334aeaa2b9af856a8b32d2b2007b5315967c1ac0ded314dd1bd6286681385ca27b873a3e5c58b401c7c051ef1e6920cbd0bbfc5efbe53f12a136b2e987cc3adce8f7579ed84c8d09fec7a28f3a2c742249f28e9e4da0cb2bd74518ac6847837b29184ac3d65f61c632466e526a82fcfa5a3fbc03335d718ba5ac4b5e2dd7ffd38e817ba7fa6fd2fa410aac478356d7d59ce231a126f7c7017ee98a15bb5b569d11a17ed483b12865bc91a5fec1e1718c30b5fc7e8670f3133ea7216cc5120416a2371e04b2bd773f907819c3ff56f0667d47221e35bb39fbc706f65a7b583df7e4f144b995bbfdc0bd0d516bc1d78a81599fd01021849028e178429d24f0d996a4d96ff957e650f550b228d7f0e6dc4573a087a7463a9ac7f62f89c10295a6933611cc22091a2a27db37c8f91482911b3f69b5a2f846d75a2b732b9262aa5b893e55ee48dbcf83f132df219cb0819f0f005cf09a86074d0ac5f995f9823a9905cf1e79e285dc3dd6574a5f67f11b7e6320f2743554685ea0acba417ae410957dfe412a98f5223d3fea62d29330f6f9e8cada30f83acae05562733f7826f61f74288d545dd5b594ff5bb19c24c3098b3f8be75239c9950559031510e6dc6c8ed2b6555aec4ec7cf1f7820627d73782046463db239eb02a750005f82aaf2352a9975313b677d50df9da2f9d40d4087e7d8406f8e3db53678eb6ab46186ceba46e3abfece0c3026f64523fcc4bd2424db358b247b037559d6c505485f9852ea9ae4a56f28e9876f67fc4e5d84a6dd2501fa8f62d8c5a086b29c312a96683020924ace0a89dfde21f549fdef7134bab955b8b1437e335340f858857169ecc16845782231c6d619fe99791bdb8cb094fe8feeb143f8ae6558aae8a4f9d4d68b49cfebaa58e651dbcb8f4cae489ca980dffcb9075f75da9b66f77c1f54ab430e0634f57dd00b9f2242d0f31645a999a10ad68104c1132ca95e3026ea597ff8484914e02b700b17ea1f7804c1765b866b251630315845048f460e9c6d44a1d3a963c4fd2f6ea3711e0e69da658ad949bbe685bb9ac69e083ba89940fea16e42a04100a8e7ed0a29a1b3b05172dcd876bc939d7d363cc296744669566d8973dd33ce271aef861efde24b88126b8aa720136cd22e0f06c3d6fae111d1a1b3e2af9889ba7ff5851ac1d813c0d8fb408f9c335730301fc6771dde40cf5088fcae3b7b29dd30b0065c69774bdfd4d0dddc4147926b5aeae29c50af0ef4b52879cd208083558cb575df389352a0abac784edbfb90ea1e321d60d77c465445a340e3188960a600a755556efe5030634e2e0029483bd46eb73bdc2ef9e567a5e7ff09c381db977a78d651982297917f082a42981aeaf63e90c5f042dafbedc544b9f3bf99d4d2f2bbbe6d78a44341337e714bdbe99bed57fe3f1b53b9f29ad7cf1014eff0294e86246eed3e354750a0bd334fcfce567f9916fae724ac97f6363db91e7e0900486a8c1e547dc01eb1a5ca5e3a1ee5aad6b3ee12d65b880aa73545bf942d3afff6adf59adb85db45f25981ec282d807c108c0701292b9e333fbed4037bd6c2484e25207f1135fdd712e3d6ed2ab139768ca1b804d7c4ab23cdd62071b642d75ddf9988f33b975df84d8011901d4b510c802b62ef87ea9583a0dd1b7512af7a63f6df159e0de80999de054d2f32dffe1aa8d0a441dbaaf8fb84bae469af786bfd3938d75252352c85dce6488c89176f5a5dcb92d8e307545f3847f9195562453750dc18be147e5c23c148f4facce4bb442961d384f7830c669a6bbafa17579c537d7a4cd5fe81e2c057e66e7c6dc02fee1748063a8969de9aab1127e80e8fd51688a5c570003aec09561a85dbd5c826ffba406ee1f29a90fb9013661a7bdd2467265b5e67c25680a42813424886821119afa2528af79f6722703af7e7b14daeff17f1d62b08b1d6c937f3dcb2e98f900842fe239d796f68b2d0ef4e88c5a09317ab557dfc668b5f72f7c091a9753757f5de43fd64b958d0418c7e6272f9a8f2df2678b092964e176af417091e1c5d78e5f97c0919979f419e907452829b0f771a58f6b78a4815e00a07e947561d733d024d5282f71c11fa2b484626a833c9ff533a1b2a96afd11850afa4456a24ed9dd4e75249727401a87a76fcac93343b478320276afb46aadd82b8f5ed46e27f10cf9dd8c578f4cb9393de08e5b1ee7023938f08dc016265683438c127bc475f61fad0e3d4f287147fef7fcc360c1f74cfce14e4a91b07b00e1e508fab455a7043d6358020389804409c623bc71ddf6eb89321b9bfaea4910ff1c7d137ce65bfb205f420c3f6411c86b7f57b33ad11382877e643e426a6dec4f758f2bb81aa40759550bc58fa313585251c08333e28428e1216e466d0db1bcce1b0fd59d606451b2e19fec7620369582bc1beedf84abc08f5bd036b66d1f64474618236f86b6b6bea8dc8a0b2f25e263d607948afcc584c2ccd0c0d49d429892cf0193091591df3fe3037965ddd8982fdba25fe7c9ee1764f5bb07ca28b80391aa5886719178789db57d1e3ea7e762321ed9b343bf85f73164f0bfbf133365415c0b9b6e55df327ae3cc5127afef952014ee23877dbaf2e4022a15073aa5d44669ba2977e25556225fd331fd6ba8f5b0505b0f3a6237dc719d538f0a1aa8d1f7d54a82a553f88cc80bc8a2ce28e2c2451721477431a0725879970f508f39d29c39f16f0d99908503e67f7753b224705966b2d31448ce3fd24b7a5ef5841ba54f4145b9f57b22297a2b9228832495b34cccb12fa736dd7aa43dfa843326927bf825f7a11a027355677c432368adf6220b297f6313ac6ffa037f65505dd195bd48428f73c611cfa257a4d34662aa92fc0e1e25f6b9e5cf12569e41e10b303d5482159268be3776f960f9e0d5220a7e26e8185194a7159b76ff759bf37f2251d53aaac9fa52cd06887db63591c4c1e2d5b1bcaedc13a2227fb68f15ed9427e241bfef0cb020e855e07e39038c7c0965e7f894c6678b9577435488b4ca9667792745cf044dfe7cdd53b06cb120fd2317c6ca5bb0b7b0826a8b54457a1650305e1bc85ecf07f0b403632278b5aaac4fbbe2e61139072d33694386b0e360d8158190a6917a449e20dc44090b482f339bc17ced0cf9ab17e575e73d2c81c8abc580ad6488e7af396fe2435fa95f518a1575fca1457c735126928601f7e96a93862ac61338230d77d54baa1bf045b060d450f9f500333c0a5db7ecbca615a30f45d3693a1dec6c06abfc94551d2961798861b0d68fb36795c816827a48a127660659acb3dcd62b66aae86fba5e37c27f22dfe4527befa76f03d482a61014b8325fe166ff5ab1c93d709b1baada666a94c603d6244ee105c885576d925381b4c268be6d1757afdbcbe7ddcbfe16b08b09643ca189789a4e73d0c26762fc863b7020bfa679a122a996ae60ef6c86be493cf414143d23e3ee638ba215c90257b041b7ddd599442af372390349b00f166fe8e39074c1f0dba3b1f1247e642a43bd13ef09346e74fc36d91b64742c43e9f2eed8b01d368d25fba2bf495340e1ad6936f320dd2aab34e67e5695cac6258c347b0e8f88983d5b16ad42e7fa82f0223e34324183269d5262494ae892156ee0d8969de47d9084e672af9040c22ba31a837842c26177e4d60da44ddd608dd5a406533229cc4f17d74eac26373ee01393a6833f1d2947018f52564b0de2f1e04182d49a","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"105a86ec278ba683589ef31f0f1c1ce3"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
