<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>PhysicsBuddy</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #F46C36;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #F46C36;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #00818F;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">PhysicsBuddy</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Sign in " />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c3c2747e1496655914f402ec1f1fe57992405ba9c00af498c05ac79e76c3293a4ea4b984d11e0421909106d6c665f3e8358bb4632d7c611f78c9d6bc6e0633c62d2a8d7f3329c87cd1650f1f637b6585401d8070a851e72878512b7d8640fab9860674bab17cacec49c7aaf1c7bcccc8ae31731f2c0afcf99154dc0433a76153b291bd1a3de89a48a08426a82c99278f52278a8e63b1dcfecb2e898f2a6de84f9ef87e819daf46dfbac8699e05a82072673bd186269c3e065438f59b49d91fb5e3d2be36fbec9615b274a48e1dc27c098474914163dae6e6c2d46c5fb5c6be186441e085e5e702a53aeb6ce386fed775bbfe8efbd5aa947afaaffb125acd676ba0b63543c4493b72e193e1c621bc1990b63051c1f46a02e3b338e431adc8da1c679d14a4d77a522d082d5d0d546fdce5035b52d801eed95afe118bf6c75f5b62bcdb2c1c005a685a63e3de50ac574bb375a6c04a40ca3a7101f0133f09402fe464dd2c6ae6870fa634e3f3da984143659cf0966a1556c955df03f7d122023dd8506eadd59433686a27308b6434514511dc5d049790ebddee62f73aaa7323291b130c9ae27996749469d015bd71a3890215e617867592af6c46221efd153323212896e28194fc021e1287590b42a60cb92fa4cc03cb6b05c9df59c300fd3a30a8ef571491093342fbeee2682dcfb06b0180d470c3a223e49287dc025f51662b090b0ec19fed894b4fab4c3676f590c299a1e2fb7342a53b1b674a44b77a80770317c8ba2ba1eb0ca8b9dda717840cd507169fea81be884fed80d960359d0ad9670b6041000d34071fd8b8c4283adc08e0e38192c3ddd25cc9f046a07d950a311520b2ff6210999aea2f0bf44f70bf32033fa86c342b54655da199645966d0ee3b7918fbcefe50e5a5e6c36798308e3e70719cfb945efc2556a3b0de46e3348675c5121c3afa9e6d7becc21e5560c44392936c7090514214644b11b21f808f738fc0bed6d07bd794f499acbfc900e8b8d625cc9a21387800c5aa326cd3aacfa5a20c3e89331a2b11c70b71ae6b6546f5f4250b77f7d38a2f1c6389e07104f94c799850ce1f7b12f47e025fff78ca35e1edfb040809c3a3749f26ef5541d5df2ed8937f1ef074c14538e12b37bde096cf687071c30407289346199e00360015d49130300acce306d85f1da61083b9c3104cc88d459287e066ac2b4e4752c86829ae310e858613d18ca405daf439fc06840b950b64bc42cae71561f9c4c157ee1b0e311b78b3f7e942ab310f7ba6358e14c6626e2bfe27a45b550bdb63f2090dff63dca040b1f03547adae559f24b51ca37557b6f38e77910a86baf4af7a54e5b66f5a20a22c17e1819dcc80c93f73e0911d9f211e176be7ad7358d19e1d11edd2c13ec5d4fec10ea3082c65df3f58f8bc6c1d30228a34f241d75001f77d819514ae71d35cc92be672516035d07dd271a8f62b802950041ffac29e720c1b00f0ad51776b1cf3d85d750989ceb5b8f05e12d30137a9ffed4fb1f46b079f4e2aba6e4631018c6f0e12da59ef763f61763645cf3be445fd3a32d924252724a38de37431031121cac3ef4aca2dceb5a15809337f7edec32e7967939723a0cc09303c4797701aa2e575a78434c2eaa643d605bd386c2df743bf430a68135ad95e6c1776b5cdbec64215b8867e46ae21059e338c43a03e6af6ffb6949181ffde5953a1648420c338a10bb1e0a9aed4baa282ac876ada95b0a1f20cac89f4939bb03d2f69a917284ef630da033a7b19cdeface0494fa6747fcca45f7cdd1d0aa25c850df90f0952fcee3854251bdc9dabaf2ccaca51c5f6401d98c44934098dbc18809ee2db37d64a90c28a2fc9e8e7dba3d01b6d6746e3dcf7e1ebc1c4be442994e3213b46ea841d98dad5bbc8c7c535260868506117143bdb364f8cdcf795c5e32405a173a14df83bb573c441c88633ee3317eb81409f7ebb6b0a63c99c5f03853cc4fafd0a7933be8d84e6e0318be0e755bd3bf8385b0daba86bfe923a40000e15a74904756c2c2b30489fdbd408895220ef18a82ff691064edd326d2e0f95018a5c0ff57cd004d9429bb1e1796e5fd17eaf6e993c4f4d38272551e95400ccaaa53248b09ddeddf8ed90f00830a0c932edb5618c87a7cd68a351c705ae053e16afd035fd1f62910eebc5aa7330eaa7402b4065902497ae23839a046920dba62634f010c817584e51be055e794b2c641b9c7924cdc1ae07d52070de6a7a33e3e0d969fb73b2efff24b96b1541f7f31c583edbf180f2d2bbf9d5cc9fcef7caec52e40ac9236d93ccc0cd4264f6746ed56ea92ff05cac087594c73c2061bb1a835a78c4d2f42912c42517a8c99289ff8e5cd82c565a07a8fc645b59079992eac9a4a9fa80a9913f4ab6134d2ca3ab5c9878904b6f75ab0f9946ae862ee452b6985c39aba4fc3e87f2074903e5a25fcd23cafd1955ac6671fad285ee6924cb1469ce415d4cd4c4b818b3fcb7e4ce9e2fef7ed144b7d50a88698f13b6aff2f9e59752b23313bd3005a6f173708fd63535f2dfd2eb6c2055f4052462a941805acee97a98d39ec4f49c4cb7341c289fea0d68809c2e34ebcff9eb32818c4bc61fa457037457cc5dbc2ce212f1635c71d97e49b89a01549820781864492c2fd63bfe1537e906fc0d7dfaf87782b72aea59910c5d5d1ec5b20cccbf48dab34753351fc8311fad69878ced3e54a70d96b79dd4bcc7fc0c7d4337cfb476a68f035f307936cf0a186a2ed86f52436a4863f8b2713364b4ef5bbb641ddb7c936a89b082f98b0e251250fb1fe6f23ac7aabbacd577ae014321ed72a3e35195612ee93c6ec8f0fb1f53e49c0b4956a91026b3606ccfcf16c141205bab1a1c0d894063da040bc51eb318512e0de946bc213479846563a68d444160b6127021b59fefc5fbc1fe81427bd4158926598c01e9fa6f850fef0617df3626f4df63acaec50823be092c95f93fc2e320d900756775f208262e7ea4075cbb3b15304c57ae51d8b223446f1874ec15dd4b9f0bd5f9c82ea2ae7c8c2b52938d4ded7c36cb616c53224e2b75325226479238c53a56eff9856817b4c032d75620fa8ee5fb6c786c27447ca0d4f6a2357d0097c1da9b838a970b1f0c87e79e87dddbaa7705c9fcd665e7778226daf496b54ccb3778c9856e284466115c847df7f731b81a74db1cddafede0af647c50a69891587b5540072969f2a1402f805d1a0eaace8d3268022b3970bcbf51fc3b19a0c956a8d86b292d686fae949933b198bf85c69e6d104bef01426972e2e47a92060ea99c473217df121ffc981f471f96756c7977b7adae8c6cabc273c9ecfad7a0b8626a235ca7ce43355e17862ecb35c6ed9194d07c524add38c9854df3a77da14fb4a0ada213b582331a8c43407ca3082e07be0407c023efb9b04845ac28f63fd223314655f0aa8868101777acd7ba9d6a9f88e0809f7854082299bb9e81001113d953244e8ab8fb80acbb563fc0c0edec5b90aa0c0dc465fe71bb5f6c8ceba753ac4a5e0b432883b8c7c8b1706d1c436901e93ed06fb37c8c6a68d2df5761ab0737ad40039a7797a1feddc6ba72a94dd850b569e5dc972a3d4fa8df459102b1adb8d04fd486af7300c1296e37a2bbcf26fa8917d6d4061e264ee16e5ab1259a372d35d29bd906f066980428b3171b679f1b4741fa65f29f7f20a7c1dc49ab8a0bac0c47efa45d3d93fe55efd323487e551e44d9d966feb3ba76ca17c2a826aea36e83830c9a4c0f061303a77836d4f4e08b47821f6bbb7d21cf9f86ebd2545784d43e218a2407f80dc137744ccb8b2c7a582b46c098e2afbf5f38057b1c40fc23eed231ca6762441038fe4bb015975cf03ef5da2e32d0ac754fa0239b8b56083a0698b93f51df148b919b2d6ed16475911b86a24469eecda79370295278199ca25628b29dae158353ca4306538ed46417b66302906c03f47a4c0b28b9ef0f94fe48b48199e3ceb885a9cca8d92cafc0a877ff27b83b8f461784437fd3f896ee600f29fe8076cc4f2b13fc7d2b8e2c5025bb2fce1fac930d35c9e424f855e55135f2abc04f23d837b7572e06799cb64834fedb7aece80be5c50bb472bf41a94c754a343987af76bc2dcc15bc9c127e6422ea795c98d37be269b2ba0d7495236afa07ac8f2014547dde15ec0ef70e56cda007305c22d627b9c4dbe44e6980fa1044c20076d6ce754cfb7a7e08595358b62a18878607c8cfaa9fd3164e4050dc60f2da64f59b5de6f044cc06204f2597abac930ce05115486a5c08e59124d0f25a75a0586c2651f716f1fc645bdda63400f5f45bbad68050d327946cd8ae67dc4a89bc8efa93109603fc2349c5004584cae8e89d3fa68abe64792e54eb213cab72be5f73b275a2e695b581aa4c365daab201910961cd7839cee8146f096204dba89274976355cac20faf6778627de310963d8548ca0cecbcda7cf225b40862cfb75f208645b3a547533767f9cabe9dd6ac09d23b6ee2ae51cbb17006f41ab8c2dfbf45806f50c760757fb426d0744ed32ebbc8d662301efdee9c252dd321b7d51e5fa24be115f2d55d08045e63da4f5b5eeb6386e5ffcec233874708c42242393eb3db2caf9068cf090b1683739977873a00fc8d3915a5bc16481f9d9b7b0ea239d28884a4dbb979bc31e5acc9cfd685425787760c46c65c8f06f6d3d5510bda37a278db29e4b6becbfe5d0a4922ec17e1b2a8066ea094bfb15efcedf2037baedd8b1e8fc98ad47d423890de142b8eafcd6023bae12d673100e05cd84338a1cdfe68ab77502d38a23c2419be2f1c5edee99a9e9f504b651d481fc5b36b6802e6febcfe2e843f1c40635468c79adc73ca7deed7f04563346635a14de6e0ba07dffb0580d00bed3960d363bd85a9d6abf8383c1ce772a75610beec0055b4197eea51203aa81786563e8bab419dfe50c4beab52748ea5778b68de1f86a1e9597c695550e4ed0bb40f21c0adc21ffb67910e48ed7b8095be2df4c212301aab8052707f03f356ad8f5b1581f02a53c5c7c86ff779d47ea03a40a6dde8170ed144cc28bdd93641e8aa8fe890af9cb078878f91fdf42feeaad23602837ae5ad3d2e9e12fdb2b967978749590267fe6b6abb2b1cb58b53b457826e9231c1e9ddf37160062eadf83937562613e9dd9a1c06ca1c914f52dee7a4254fdf5ca43fc00cd77e74c6778acedf02d938920d4f51b18c36848744a1882b391cfeb419ba3c2d9620e7ec07ae12d3edc655abba8f4dfd4e65dd99db95c32a17b70cea8dce45cdfc92037593cf3acae055d7d291f2aa8b5eea2380a8ba05a9dc8aef3008503a6a5ec61815427d201a361160088babd28c1c921691dc7dc5007cc3456e91790f00b38f72612d23c007be611fbb592ccff01d24af37f5e7fee6ae2fcc2603109174accd9c1c947957ccf9020cd5fff6c59ac1b03a1a9e5591a9bca6218658ff06a18a608def1590762b2e6624b36cde0d79c5f038303b4fa5d2704b68bfeaff64cfe209112f0b075fb2ef13f7605c846768051af0737baf6684f54e6621e59d28449e7163834e76b8e1b9493954fb4f97da6690cc64e508d2d9d4762287bc9c46f1c037d348e10f6fad91be430ae91ca41dd495ab50840ee690a383f72d7386943723f60021596feae53ad136115a41ee8ea6752899350e99d3267d295d0b36d32a0e030c18b2ddbdaccfbd6999313f251bebdc3db22aa299de44b5773dd96edb21bd39d4c422dca21e3f4dac17d2428146c9269899d5de2ca1ef103e3100362f4d5aabf44c25f8b4f4b21a01c65c134c0ae7c5b2bfc0480641541277238f5b7d19695a95d2a7988c2ff786ceabd482a2213b6f5170881dbbc6c88379a859623d8d36e48d94090945fa4332f6862abcb9979252c28840b3417b532d332299dc8fc904e6016ff794a1e3e81ac06b0cca7bb7ac16b0f220a8d2b2dc7636e2a6b418b9bafd1dbf90e1cee479070af1ca7b4d4c518852f16e3bf671d849962554570d7e982e6911ed9999619e365503cfc75f482c6f593b934faa2efc4ed9bbc48641bfca6a130bd1cbd224bfe6b35000424088831eb51df373f478777b417b000e67f26d0bf6097052fa79b4a733225a7e188c72562a5bdd0f25894f9fe791246dee4180b7419d9134f163385dac9392aefe3015fa72101645b9e4f4fa1a12209528d3d57aa9c30d7a155e8208b33e8cda0c58d36b08d5f8b2ff1ef16305fbfcd05edb87e900e5fd72901793a5c4258827f44a7fa5ce84ee8f6d961b40c088d3f6d1d9dbd13770595570f12c9f065ce25318c56b5e76c72de12464ae710a436f6e86d2253e9d8f2c868a13df4f2119262580676faf2c62b6341b87a2a3eff0d1f6b4cd81a2c3cead400feb5f765d1b46ab2db6800e63f931b1e35a2d92ce4c915f0903ec7ecf9728a3341ec018e0db844efe8b5fc86163032b96ded3c254149a9a6ab3d32e983b4fdfa9232403082803e3b8ae78c33e140da1a362c2d0bf237f0079b256a0e777bc60ec7c4f3c440da82f12341aa2866aa7e0e91ecacf1283753e323d08ef38606e3554d94741f44cc56756b2fb55f5bde824808d5150f524bcaa347d6d93e6edaf1d0a2f8f21fd31f17302b6c1a13d807e9d93c244cb1c85f8a8d08e8378f16e5e3fc27fb70d4271c8e32b92cbd6b42ad90a6f6ed856cef5b2407d796f0f591ca70365e7203b00834fbf3d616ca633c2e9b868bd7d248c398b28895e73900a075cae4fafc75bd19cafc333f4fef5b36ab3874ba81e5c2e284c1dad3b0453ceda73bfb26e09e7e764e73064ab55cdea8d57a5e3d5a7119d74b39c98f0b5f71f92952cd4ddef06b841187af83768e9ced62e1011b5df5d69820f738cd73bcf74fd4e3e3609b6057b7bbaae15200ee1f66e9467ad3d2980c875f87fdc39d196d413c5ed3d04170eb7abd5cf8dec351fa2af9e67390f1484f885c59465074522b94686f2b8048248361a6825d686fc7c1420e3e2a26eee42085d68502380542d77d5c929e3eaa807dfb90556f389edce28682fa6d3299417c8118cf4c95b02cb8ff17d341a9660a1d2bd5628dd5a190b452cacd5f9f1a948512d967861f40efeff084bede3a8b41d3c1f5922c648257e876d62a9a8ab508e4e09b19f18e62516d39ee3793b2545ad09f30374706a34c79c777d89651039d33bbfbc48314dda6f35bba197f63011bb1e90531c18df0ab164eb039343c82677a416aaed1a1d12d804ba7fc6989d6d8da1a17ebf4aa2271cb13c7e6c45b009e1a26a0477cc8e436faed4f7eb56761eb87b63787647b7a36419508f9ee2843671d948eeed1d915c1f1990c0b7ed8fc708058363e16a498a7f26e435d577adf952ed9bfa592fb492b355f8753afc67303a6134ea182f77082b39b08a63e769a3e7cd586736d5ab3f09f5269bb599edba19fc967a854ea638f7cc3c43fbc9877f9a6d915fdc2d1fcf75f6acda92b3390db2e6fb26b7048c5abc811cec55cd70914e3d68e799014e1905c9150a7c1b757ca975dcbe3cba702e63dd9e3739d6c00d1cb12cbb13b55eed0d8eeeca4b42c86fe063a3c4d21878e41bc0b1934f0903ea320adc16e761e57d11be01757b03935bdf655e990103d6940bd99df2ccb2d21e3678d45db33da104abb5b6885ebe3ef2ff0998d6a71dce6885e2f9d6b99d0445f6376bd13f4f17d2c393c0c1b904836982cc72950ffab66ff4ca17a428011304e5cbe36ce35a9095b9b175b842654b285ef830da964f851e90300b30dd506f24d11a1e8de535ac3ee9561cf939556193055e62d410b52dc37ed980a256f501257b3f4d9a475f8f044dd0c882d82059771c411eb3600c3a859590b241a3097fdc4a96fe7864d7f45044ec231a36362102f2173ae328f705cb2f953fe570ab9d29e5f4cf757818bf8d26e32fc09e3e582fdc513bb6a817339b5d72548cc26c5aa9d1fa2d06796ab779e6b768312940bc8b160749b6c70a1ed7b6d54948d8aba2b2160920f9b3048b54de82ab1387458ee7ca31fb8869f08743a6f3c023534ca91e3f6a2f12b978705aaa9a1324f31b8fe6fd0b01241a7b0fad7a0de1251e4e66843340a53b02f463dd6d414f583fb5c2d605ac176ca700968df98fe743e73e0d7bfe624c555f1d8e3d5f79836861ec58b8a59493d14598e8a9c66959227a5e84a8c5ab907ec943e64682bc862e8fe2baf59a9bf87fb017cd1006abc39870ba50724563505ea94f474e2272e3f57fdd1c466c24643d1141af07ad4a8fceb27a12e936f59fbee78eb584a4dc97b57f920dafbea7c34d9ff4853f31cdb1e650063a6d7be5a385459c86c9d045baaedea16b4e8abc422d84474d3ddef403290e237d5c2ec78021730c1c62c7ee0ae0d361bc1e668abfa1cea508e7b47ad67635666aa54276ebcf7cdd304047d230dfda17c136dd786caa2d132607283905b9710a324c4c3c3c56d8cc9bce5cecf9b07cdeb66e270f2202f993ceb90422429bde3e0864922385245915d222ecd75dee555d86baf1274de4e3e7abaed1a60a40c333957b80b89a3385f726244aaa1d5f2cbee9e5d2aa1aca4ff3c3ae7e1c69f82450a4c64c66e1e41eef1fcd2bd265754653aad7312ceef4de71c501d2498a2b01af5ac210b35fc7481dce1720a1882d6a72e5359f35140c27d8518ab5b20fe2159bffa9f8e44a951d233b16ee55caec4ce6d9f8ab73d26ccdecb7454d0c1dea5d65536608ba8470929335bbb5eb4cdfa7fa0515ef73cd3725a907a701b29c29d5d4ea04b5b06a0ddf7ade2a31194b1815cfc9179b39d765f0933febff9a617f5f5d981675980498bed219ff3d6d5e84b6bf849c9a81f84660d93762b84cba64601948831afb656933713dfeb3edd702ed64a94d422ccf0d6b7f0df0bdbda41ff2dca4a56bded713f71929f75ca0cb5facfd86ccc6c75c1bc703efdad0bef2de605480d67f34f758ee6c5a0f5fc67064ae06a89c196fbc0ac7c48bff2fbdb7a37579ebdb66e3eb898cc7944bb96a260c1ec8d802ad4fcd784d990f51c912ec43b9d1e773ad4351642d5e5e9fab36a424aec9b598e61c9dbcfb4bb6250709add417c36cd1c2948cb881369fdfdfb14a011614d229c1d8a7f4b4b6806a476818b45dc852d02fad53964ac68ec99ea2b024a9027ec54da9973ac13355aff4a508e4d5ad0d9e4c37b18ebf804e13f79ca14f3ed4ed7c8ab2e266739a5992260eed436d75f9c210276ded954bf52c01759a92c15788f4379b69e2e77e50f7123f79f61d186b7dc8ac2b7d893fdd312937afde99e7a7b26b0943d4a012059ebcdcfb14163252b9d96d1cbe6c8883a3285deb55a80ca056b987e2ddaa8d575dafdd62c39b3391819584ad91e9aa463b730ac249dde8e6b4b745318b7ef1d289a8231c95c2fe153a450e4e66f3253ac61e8223d89e9288a6a145f6d9e7873606e29e892dfe0fc2fe1978cd5031f0accba96d8cece29d7ad000d6f7ee8199fe42b5d45d3b8938e86b6f98d7e9b96deafe40fa41960567fd43e7802174da11f802859a54f521e279441f6c57e174debfcaf825009b937be3273c39ef78ac6c5c3adc8a22a317d2504efd5adbe4bbc56530639a8a52fa544f8e7a292a8e96de03c5bfc2053138394e57c2a0163f3221d413052f6dc161a9a4e764c026d82cbe5892ab17d69319275b5cd28d6e446a5e41670a327676300ede1962412fe21769d96aa1aebc0ed6ed5bde521ea5f8dce2bc9e7c4fd495177ebb1c4c5753c2af936a1320f972133457b3a1555910c3ecaa498d62357d8cc86a15feac2d4c6dffdd24df95056abee5d2a31459c5a459938e0d8c8d0075d4c91ececfa5175826a228d85d7c71c97d63eb51917bd894185bf1ad0e344c4609272f471960eae47d25f039d072d1b4ea39fd71ca4ae464ac960f0b2ad59cfbf51003110abd318b33ffa7f48f2a0f6691c394d37b485e32da2914c9a90247822dec6f541a3e492aacb837056cbf2f1b1dfd15f756a99988a8598aa5ee7b0427293de973dc132532093c118ce2035c19332614dab34ca2fa09b9bd28568dfdac07ac25e7deeb5034b8025e98a32ce8afc9978fc7d692bf3b31652a6451d12a5fcc4237a9c8bdc5569321e450db7b42c247d0855d33cbe2947f8c45e7117d1cff13b5818e45a9d3984163ead9fde6377b3d0a1c4c88983ce119ffe731670348b171633abe181edc571da407d007cc02e4ff29b88e9e1177305a85819bba5dc0dafb0aa6c87f92354fa6d18b95088c2668d5dc9faac3fe2dfb6682885fce729fd81573cb5619978cc4166d5f999e0247e43c61df1a627e1dbcd558f0264680e79e7399d632fa99eea8db12ade674c951c4c9f515dade213f51936823081e9576c63e6863c0dcab441419a4212de66c80322f9b2f2fdda845b51ae8370d03faa00d6daa2fca0a8a3fafb8d9d83d2bf6d6b00b97f6f81da7bbc190e399bc304232a8669a717179e1d56678d7ea409e71f4a7b40c4cff96066c9f2cd2f32bfbcd2eddb87929368afcd0273de4dfd4aa1fbcacc548ccbf823008c7fdc82fd6c800a66e2c05b2bf70c6b9e31d61990765986e2e1dc103b373bbe1c46e27fd906ebe76cb85fd2686321962d72a8091ca13d12379c0eecf9ca3c765ee9a324e34b160062ada893367895ed44bc5f782bf211111d27a7e992b6edc3cf93fbf14601fece6ded52018533be57e6763ae9094360c00c2addd513edb10a351b2d978934123f1edf5b84188854cac9c7a95106bf11f4afd5cef7cb4e482046975946d1108ff528fe176a7e2f92e15a3a1407d073e19ab73097fb316db491709ed1191e12bd4a6b38d5618353cf30920d07a4a54c98952afae4ea0103dd6be7c023a7957fb81e1461c5c37b5f2fe6357fe37de7fbe16b1649a0acf350fc7dffe877b399479eca8ccd8147a9c2f771038105c958515795cc078d4f9dfd9d5c8645da3a2b7380d3bbba71e31c01389ab6119ce7d7bd99150a8cbd9e62f12e562fefa390535679ad174a18f9eb8f9923fb947a3560538b6e91bb3de7261cd1a4effcefb87c5ba658a43226a3a445d1c9fc41d8a3a9771a2b14ea0e25f82a17c456531628e01de4154768c5fe65e7655f5f52528c66ab98af0338f741484a48d3d1df79b2e4bb7a14653cd885d1473694c519ad27796b34ed6a16e246b277daffb342de917969a3d46d96a8b69a056b9e454a4e9dabb6c89d8107ae0b056a5a1c722f3a76350cc263674bb265f3cc054f1e285f00afa3f4153a73c8438b9245cbe8118ffaf7fce582922538088270433090d8aef382bf6216234fced0e9084f440001a08e4baa0e9515dc5fda40ea04bed450db7ac3eadfdda96cd08105e221d07312df2f74643a1bbfc480cdd76aea669b8df83e898f3e682763323ea8a101cf9c81054d519f4e78b394f4340721eb030cc70aa389ccc909078d8907740f8ed38052ce4f0880b00a45447500703bfc705f73a453cc85bdba1d06df0878d14e6c9208784b7304a34fce676619bd168d9886d2726f74fd45487a9e3e44519b35a8e69c8eb62a5fcf7f4ecaa03ce1b0757d5c95b3c6386a1591a10e797c30e6f69c004d4a54e0f5f3eda234175fb4b7a2f26f1250c40e14f0b9670fb380f18b3d0828b1317096ad6d449b5dd1e7063ca7eb8803fa2b2a13527e66b6dc4c87e140b7f59cf22744d9d47295a85140550c749bfbb19f693d17e197bd6893da2cdf82c675921bfb8bf27961bc330f6a8108ae07aea131c0a7810863f28fafc8b6c98e42d04fca48d40877b057f2ac1b2e73c170f5f54f7e084c8393fb18034f4f5238bbbf24c560d272406dc41cc4dc3a087cef8985090a3b9516eb4f66c471d187840076327ce1d015c986da1a63a795c970fbf72f0771deddff285504769599a7b3a58e526233fd73f7070ccd1da40c5e85775442935d0289a861cb792d7aa70a2e72419edbc8c9b64a58a389e243070c56a288faff68222b91c419a779c8ab108e9f3edad0337b29127e17a99ef20afb1a1542f2fc65e45e7762bc368255a937935477781aadd16d1162b51d3021936367b0f79fb18623ae4ddeddccb1fbaf4c8a65dcec3a7b62828aef4fe588c900f4114a7486e628df07c28747d673fb1ab056bc4daae1137ebf272a6ecb973a8f587a9922b0c173d8ccb885e58113b69b8dfa59162df33457e24e5e82fc1309916b24734035729c66e49e19b77fea9e4add2add0730720774d89c8156ca2565c99837f35d48b4854532b427a388f6ccea87ca57edb217b3d509613e657edbba2bd9f58b8d326a51369b9d4171ce9b448e9bec0844e4b5df4f777432d7aec63ed36aedcb531d6fbb6f0a1546f5878b076f34c08d9d3b93f5e8c2b6cd31816d11c669d796b5a47bc3afc0b7fbdb359377ba53cda0528219830b02e868b41f329c3685d2bed6ecd87af21dfda85bc22f5a6b364cbff37ee1dae1c34d88116246392bfb69a21a506dca28fe0e9a3e883ba1972e91318af2e2f244443550b1555d1ce0e888c267bf7c0ca1400c8878cd7c4d9d9857115523bf7fd52108e892f1e66c63117ddffb4ebba07415d53a9e922188676909fbce7f3bd3b0e3e35ea51a4f5ffe0f306dfad051bad33cefcb9e93fc496e5ead088979b58d629aad30a9c1f66f3b545491c5e764dcb48269bbbc5476328224867e820675990c62677a05443fb84a7b558ae76fdccd4afe864df9e93d04191e5ec8b155993d9d804992eeec1e4192fb368a9d74af824bead569159cf937974f7173ec322799b7e6bd3658ec7f9bae7a31f23f8e4da35a477a1aa25e88ba046160e611c44bf4ba837ab82767b8c662b2eced34df399f063508486a14d8c75a42d1aa2f0d130c4bd1638d8440e97daec992a998111e3fb91c34dff3c8640d6a27fb3fb7412d9e721348c686afc3a2a7cadf6bc861f590a8ff5b551df0e1624398c1bd004ca0de52c31c153fea322ebbb39b35f8b38055574820635b7464b39793ca0a1dd1aa260dcead538f5473e0c0d00fc5eddb74f4b36b6534f28c2cc9baa1e5f4b89de1fa125fafe1f25dd7cc351b19028c806154ddf169dac663b8e5d39ffd7a81f41e2c67f1ff12e572cde2c9d0e90df7e3f87f5c83e3b862ff8e99482a8709494d8eb64402de4672486b52c9cbdc02669c3120c3227366933b7859b341508ad8614b36c612efbf76c83563ef581457a31f6b87b8c1fa35a5b4ab089be32ebfe9eb8b8c1eb6d14bcd71741743c7693a5b91a62856da75f6c2eff5793734e20733cfeb84202019bafa17b2feea90f59878a477243dccf40d1a7f9aad5362d5530cd60c87b7e5f9944cd0dd0dfe1c25af55c3e11fd083ed55490105230bc2c5d6dfb3363873c385751e95f04f72e07f1563f66c81cf7329dc1eb3a12ff5bcff8261ed76d42af5c0fa397110bc8bae4971fb8b7ae94296eb77b3bb07e5b4fb42a4db0cc8120be282047b42d3d93ca85a5266e377f88556e488f8acece87fa376c749f4224330534b4ef5b6d0743f6f9e190395dfdf70314aeec1888fe570fa956d50b27eeadf942b824664581cb430b6108ac740a83f7c242eab8279de6039ea41f62af30f4aa987aa9df20fcefb858d92debf2c17f9aca0f2c40020f76568542cc5fb9056a44f9331a9adb3af04d9c9121f30519b66a36c4354fbaed4fea5a0658a40f913d3f191dd04914e325409c36a886bee5caa1e248857e74f182301d88bbb92d7c253b2f5404c4b533ef24a102a5695a56d5190e83e3aafae645ab1c7c26f9cee1cd2a9d7c4153de3247c0d5ea7b133e5c4b4a08b954d73f3c232adb784b35e58bc094273c54298189577c0715edda57fc575b3a60b2aeead899b1111384620a223a465834c2d82827b2dadf4e2a9ced945a0ad4e08894f67c1412be237ab9ca454b25dd1e5cfd32dbada98000d45d703291e35f90376ad8f6639d303233ec29e3317d6cf4368f47cc7f66360c2698cbf6cc53d6a21e7759230dbdcb31d11f3c4bd5b130585a4b77dd24361d40d7321a4897d9859b265ecd694e5a24a529fb4cb8e1bcf716c2eae4366952e4508c68f047e95de4537514c931d33dd1edc609bc731310a35c2a1c57bfd847afc494a96a235c158afb41e451c94a8f70e199f3b5d5ffc755f6484d243a2a1a286622b616f4173d9b1d70815216a115018948a10e4b2cd530742f7347d9bf805ad48eae8c6d61cc2506094da362548a7e638bde1014a816d2ebfba30c586a5fbd7ea00b159d495a4dd1870ed650c4b5c94cead62f11ba33f94580f35ea4ff09de1dba64eccec08072c52c9e883951997851d60616a3bf58b1ef77516bf3a8cb514b7dde5883d919a3a8d21f7fbcc10efa472bfcf50e64a9237e4d1daf6811aab565f248bbe705d55a751284b9f656b47cbd3312a1fd78f1b831ae8e9f5e57c8b5626af91c358599491809d50bfd0383742487606205019593b27ff1c59eda62ac9fa90b25f11282de1af1c134fc8b7b2d86e1afcf6981287d9970bd151c9372b430746a899da5d34aa86e3e9bbb7afd653a2e28dcbf7d17f489382f9f9b","isRememberEnabled":true,"rememberDurationInDays":"7","staticryptSaltUniqueVariableName":"b1a8ed0ba6ff00db39d63bdfd187e554"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
