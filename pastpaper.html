<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>PhysicsBuddy</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #F46C36;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #F46C36;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #00818F;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">PhysicsBuddy</p>
                        <p><p>Check lastest email for password(changes)</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Sign in " />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9eab57bc472349e81f6a2e9220cf79cc2fc685cd16702ae14c41c93b25136fb01e91996eeb5b792142a1c50881f1f61ba5dc64e61f8927eb1597ac78a4a2dff215deacf589176edc7be41c4397d080eb18738e6554e7cdfca825aa25a6a27b1770d4bb7d5253b28f7d4c90ba59a7d6d7c35800d4c6ecb3d6bb2d2d770dcbb472fbcf79e0e88c33c5e260e0eaea6c8797b402bb023633880282ef7876918efebf54a6ab803d50b18058c7d81d3b815ab218412c77c05968d8bfbffe085418fdd53c30fd76e44d02c96df8fbef45245235c3d071884cb38710f815143c1fd41c6278b509507ce1f37e90238caf2c31ecc840365ae661f192f7f9a7da54049a55058312dd54812d552a0ace85d3b0ef641d51d1a7e7f8776737dbe1854779e658ab738fc4c2e2b761d0db78315fce0d38fbf3eacc8e18ec5f51eef454e2e41093b5b4aca3f31849d6d696f12fc1d81f637f72a2841902f89d5b08a4015cbcdb14fb789235ce765583591af09e69ee3ebdddac2e124dd54d73aa292b60843f4075cc9e3cf3407d307950398f396270f68b8c6d7a8016c0ccecd4bab0b118d757ea725d30d37a2ca4738988d856e91832f9d2aa32b97def1c45905d84ffe36f015aac02ad0f8b5a92fb004f734841f768bef216e51f6f3c1047f4efbd0a3a80db4bdd5da1923015d34ab9112d72c7fd330b6b19503f60ae894cdbb9d1b253d6c51af02c4b668f462daa4c809c5fb1592cfd22a82a3325598776af76792c48e3cf30e418a5c52b487bae93a924595de64efb2ab0c271d69cecca6f706ef9cbdef4662d8225e972723df7b823f194534afd033580da58c4429315d0f3bdd70bb68e748f8ca47c2b404ac001da641e2517fda0ac82238617271edd2f16bd6934fa06c4a9fdf15331c3e8b6b9fc34ae364e30858633e014a34a6997f56ef40198ca15912ec87c27732a66489326e052cde0d7152fad35dd22a6274cfdda0693e81caed0b501884aa2bb64b727a1a5cf06da21fdadb4949fc1342ee226770c0d547db8fc81c2edde9c5b9fa712b5c062413f09da8c8f262935427b5eee0cebb2d424fd0fc41d9f93da4d840bc3789163535ef9005d4ca538a73f743967a7595e2962ee17ca93b36122108198be061a5787ffeb53fae2efbb7fb6a7eaaecd2cad6bb880839f798db43f3a187a7771ee9f7bd595591e57676cba5e6ada257c62c9f77bb4c5073b2cc46d0482ce064d3b6816418b77fd4032e14024721d68de57af2baa73f302f1cbfb79223800e8d172da3b338842ed2704cef606fb6f03ec0ce3d5fcacb242b5b0bcf5c44c0b538e0251fd53a6e07cf40c35c3981567e3b065d4a8b5c22709ba5d0e7806eb7a66dffad45be7769fdbbbe018de4698e06ca51bfb103450772a850ceab3011d5eeb6658c56fea39c2b5df4c0e023d6eadf3779b8deab4e5dc20fb95891c03ae89b71b0e324fb828bba1e7f9993f8b514073c7d975e8478e124a0609dce9934137f08bd9fb5981b9b6c114ed970b01c86115d6c48648b1da87539fb4dd3c8c4a6c1a354e32b1fcdd9ac02fe96eb541fafbaadeef751472eab818d3110e72b30de07c38ae830b154ec40a6b1f186b381c5640cb7c511ada8e95ec2b9da821318478684774eee35500b2a619b0bbb4a677101e2cb746bee54377edfa8bd38003c4b0b200387a4d5483cd8692057c7a8dc6a993a898f8d2c5845ff64b243149a45150c1afb9c3577c6c1beaa7fde46613c3ce6a59b70e36d3f2e81cd986481d1318493f5e3783a04c9b4e01e3cca4cda04740102eb6ceb0cf10be157f2e9267d9e219eddf998160fc325ed43cf0a09780b71ebaf7f7b9d407099c4f67936b9e6846b09321c7d524b4c211f097641a0ac981cacb82a8316cbe84c1a403a33ff83f8fa0fd93ddf7dcace52b4251de8df5ba755398f69a0a515b334f1abfe9549dcd0de6fa63889a61cab471a1b66fbb8b9984a556c8e5e757749c7242d7aadf6166c44ac8c96d3583f6817cf728e808dac486f121531653308ed63ed0c710d4080ea8214dd250f0af7d51cba15b0f8ee196b012b816f8c8d586462bd89cd4b4ecff518936f2b9ce669117506b937eed7408a5e26d7a5873698b26cdb3b166ecb7e67704c2c8abc3df94e3e9f7c8e30629de916a68e3df9558e18276c7a714b0c94616a8ec717084a920316246be88c9d07832442136313cf27d5345b19e45e355001e50079e58612c95f6d6da81f1d99b3d286813a6901c4913e5a636f69c074a9b74f883057d892d781c65c9f6a89c8b4f6b4ed2bcece72e4028819dd5c8cfdcbc3a851065c24b188d876e9a0e3d8f65be20bb874a887e667f95d4279b85f4bd593b5744e762edf508c01ca4fabfe4afe3dd0f2f8a056cbc287260fdc803c9cdba50f463c34a8fe497fb6c497b4e37d0b347d68240d61aaff21cdb04ad26cf4a7955fa614df4adbb7015b884d63dbd5454878fd88221423152ba81e1c6e4bd11b8198c4d6b117b00ae2cf983b8054fdf4e90ed6d13d9e8b7e31fca4791fdee31524334ca8cc06812deeb335c7e4c9a5fde01842ca3187dbf983a1718a8bd63b3756219adf38ba5d31c59c79a3326f6ea56d7debcc8ac0890cf4173677628128fadbb9b6a6680eebfeba991d80943f60415319c1cdb2e3d0029301b3f7ad1914a29fd4ba0caf11ac8a1542e5b03140cddf56fcc4d512187498f8230366ae0a1f983c0f5a1e60de640b6db930920b948c92653a70f15dd7fce590aeaf5eb51f9c0e9943739f29532f7a1e57d74e525140ca4eb90911cb1aca4cdf63b91d1a70752d8b91efac287f42226b9b841ec693c6f71eee7ca9e782eea51fd4660cc0dec2c7b7f28570e6f82e31a4b603c36c7c28a06fd1be502ca87f261b2e185a040eb159aa79759ebb0967e79b147c2c8dc0d416fd0a172587eda4a787d48f1cb5dcb069d75723c056775492b363f4897cfd6328531197eeed8ab8c9f2eef1b3fade36b3b0c88434b4203e85ef29894ccea2f91ae641b1775e659986b11617d599a9aefa1dd966c5c51112e4f6e86d8bd337f80528d0874bbcd1294e3d1776650d96bfeee0d3cbc1c2fe5c25969820f636cff42f98e9866ed8285fade70f4f09efc6fe3da3ceac47fdd247b0f7bcd2cb7b5f9ba81451cc76ccd92257e2e1f1a53cc54244e3af4f3063d973be2dfb4b8b2aba00421f03e6feffe7d80dde9eac4d6cc921399af43ab52dad106c7630b6140e604edcfde8b5a674e77b047310fd6f2652c9a21fdf3f54729070ece2ec061b398bcca815dbb2ebe38ccee1755808a236d64cefbd970107ac91933edad449077d8bc29e0e1ebfe04d4599e34477c96f6194f979a48b9b3e530aae087891d78f29d90d4f89f4f91eeee4ee2707516bfe802163a0e2ea98ab6e6d1e684d07e684a8bcf1b4ff632046a438fba07eb7a4a696255448ed7faa0d142a54803c559f49be8890965ece7dbc0ecb05dd8d648a6b6227c4d6bd54ec02959b043003df493558151510877dba52ea9bea8dc38a0ebe1a61472491abedc9d952ae38c6ca7dbfbe88b1750bbf0e071758d485445a39c193d46e0a9039a88ea54d95c6b030b0c6d332d746de690a08a8895a7f875278944003ecd8e26fb0ef6fd4a128afef44de5bf310780884cd5b736ccf2ce55019582045aa0cfb949494c29ebb99eac11b29f4d20612059cc39994c42bb272d8a0f739af55a6f74354777e53b1ba8e52fbaf96424421df8b7e882fc645cc9975f080606268716ae0974ba993dcac3595487f929b6443d4787cc2e326448ee97216a08b74f1765678693ffe915cbbb73cb14e179286a7f64881a90e2dac73e48e2652e3b2bc9f5704f9fda58c63abb0c6cc37721d4767f8abe603095b9267613051a80a0fc69a1ca0b57c02564017264075b14f1e20f2a5f44c01bab192df0a50e8c5d52f60720eca430695b08e6e5550efbdf696b9b2a0b6731646e6c0c3c01c5535959b03c7e16f9f1508c927c8fcaad3ebb12211ec75b7c3ef1eb027f056b4a7986cd6ac05d60106575b88484e129dec8070a0e8b257a1a3f4a9af91d814550fbbfcab020ec3cd014effc92edb63d3973793d14f29aad6e6db262d62a256c2d2bf3581495c84820a3dd528127ae05dafbcb5c858bfe39ee20d08ca6ae9b5863ed93099c8f6293eef6de7b4ba5029f4c0aa405d248aa78e354f905b205b5122868133583ecf45bf77860ab9bac6b8ec6d91dc7aac167c24cfa6018f6e96596cb0463d3b8f151450e0a2c7a177a87c5e7cf9751de19bedcda955436572b1c94e68f63583d401a6dc065b5fe4afc4f290ddba141e603484577a8d15d5a7bb74faef7656e807dba34de2c60d9a2fff98671af3980b1b2cf28196a0048e18f6835cdce34a38b96973e1b111cba92d1b55e89d7b5e8d0a6ebf1beff0829f50b8ee8232bed05e3b8212dffb6cabb24005dd16732fa7ab011b37ac23b368fbd1609ce6fb4407950963e0a947fac04b57267aa476b5b51fc791daf56bec8d9edef8ba42d7ce1293b1bc622996bd305ef408ddc21cbeaae8a7d8c8766e97771eb2c3e623f60b248c4342f1b72a02aa35121ea195cd560d19e1abe4b4bd1c30a4df0c9342642a23cc06cf4c250d198d4c25957120fc61e1376ebd7c5f2bd3e9d949cbcd80b2630631133b2074bfdbc3cc34104b09b55090b53e3bf02eed7251d31ab833a21104e8f6e1eb376c605806ac3929b818533c39d71cae4e9870fe0748f013a859be8cbfa4b614a9cc85aefe535daf4e93e19128424f689ab71db48cd591ca0f4cfb442d88bd7986d95267078df75b80bc4e208e8c0683118880762794484069aa00a3ded7d9f3c520b8e01758abdc6e61a7d14be06d36984e1f254f237bbf7cb91e77d545aeccac254454c37b9d5bc1e5f92ac63f0d11a81a69d9b7c77d428f1c8b26ca0a1a7131e5f8a6a763faa64e2b769622b2783112faa7dee9fea7d7d3b93a9b1cd9d7d90cc5b4372e8dd38b04d6756865a6c394192d701792aad0983c93116b4a1cd7db79e9c69ebb569191b48995ed0fa8e20d57c07e4e7ec77e5bc3cdc44921980a6ceb0b6bfd32e9da73fc928a49eb7e36a462b50699a6ceae8bebcda0878cbdc2200ca662c7238b24f65b989a927cd4bc4132b1a3fcd4943f1f4374ad1f580dabf0df05025e2a183e731380d248f0a02bcdfafed365f1f5b122a2ef70daba8b0b25306730b4a2f06b95fa7019930d340ab902fe22ac7cbdaac869243bd0d89cfa83b9eeae128e5d840d9871f9fa2879c59bc11f02c6388db712aa5808ecfd4606bc388b59c6d22c63e35ee7a1dfd99fa9293e8998e61f7a6d84af9d80b61e42f78f7a65a174f24d890e5a5bf3156993d6250e584820977e6bef2771c6cd8063225baf6ada2bac9c865682f73ae2e427ad84299b9857a2877a46362f54e7bf98c691fadb2be4821ae5b29395921ff4141d3fe532727a9dbc04bc7fc190116204a812862e002df2fc50afa3b8be8a753cefa1a7cebd45366211491824214315d2dfafd6646402956c4a4d4931d3f4d1c4f6641ea5a8c516d7870c02505063be6bc9fa6adb30f6f8c155d35364fa1adb098c093b985c2daa7a03648f08a1cabe569764a8de723666ad47c8734cf8f12c4b12955503f7666a354ebda59937359fbc34bcf35d6c969cb422417aced690afcf685a57224df249580c27f9a57698fad6627c26bfb26a393f510c28ff8ced748886675bf1a735e5399c79968414b1b4f87f56b5b0dea8e40997cd95517f351b601ecacc0c55d7c42c09b9cba3e689ab4c835dd873ca946c6b13aabfbb3169df9733cb5fcc05641dd3b9e1045f3d89db03c9342453e74ff4a6b4426e7ce6681f8182f2bdbc0ebbfd30afc8f2e076b471f1222141ba64e6d0a65523a99919aa2a72dc0ed2e0f62125135ea5cdc52d8ab89d05d8247d72fc3450ff3bd4c2c0abb43253726b3b35fc0d08e4f3b64ba1525924486d5e0b0b325a0b9b342ab71db51868f88e2bd7bab43106548a56f423c02f75e81cad36e3e4914173324aaba5a9fddb35a2c5602f55be8f263adfff38fed8c00cc7c825bf0b2349738ac0ff015a0c97f6f79d3519cc2d89e2a28e766b937832f489c55b941ad180df73c2ed052f0dec84461eb4f644d232288c8964482d680423143caf6493340f32b7146a71ab155ae60787c4e769cd64cd83e23cd083406fbe0e41192238569b5f6153999a39ded72d52c324fcac5c8e85f7428dd0137ac641e3ef6a7caf20bc5e4056b8c94ec8b87b3d622184df58616ec1fefe87f4cf6d09902a3e32d3116ff49b21c8cfec4a5c29c8619efc75c432d5c732fe423fabd0f0365b1ef0d274449e9e999d5bdd2124c645e98fd087ce9c58bb21e9834864efe35b212395fc2ff92ba8a6fe584c050d232d8699b7ed3ae4db5cbd62bcb246fdd50c345f94ed03bfd8ce68d29d5c8def4cbce314174fbab79fe7ec5d5b839ae34ef3b6ef6bccae9598c10eb97077be68740eccf99e22bb9994253cccc72808f445b369d7f258040c667676de9e66e3ec85f70a7a7b24068943e7dab0520cd09eea051993fa77669ed35fc7879b98841fea32ea5e881e5728e766b6be8fdd5a06e5aa3222dbdaaef282b99b56d42d77561bc09f137550408444a74ca6dc2192c32c64feda1ab68fcfa8fff482a7040221e1fbc3565145007549c1c52fabf57cb5060b34bb21ca816d933f3d23df1b8959d4698f7ebc96d64e1ecd4c38b1436c3b878c1e36cc5f2bf131f83598c5e18bcfcbe6abdb977e6e47306bb649b8831130d4ef9477831a29161b50c83589215767bceaf011d4498290e9eb97fcef4e353b2e21ff01430ef78935ac051c53e6eb1323badc40a833aea75da6ceee1ea0655678164e39420a2dfbcfc4180a67c3c1b00d60cfb2e33bb7cc0d83f12474e6ffbd0ab732f0f4608d2279d53d1416c04039172baed42105987a60ad5af18b660084ecb37e6e43cb040727790b3063cbcbeea14c518a6d53f34bfaa398f89474fee6a5372d6fdac1af7247d7207bfef33b7244235f06140c781c1cb10058f054ab00b8a513b4a6c516eb76cb8ca66896c881c861513478f59922de6167193a8552c888133fb459b4896b94e8cf4eb6c80d5d15564a055e9805e2de6482cff18002abe2ec651e4e30b404211ef771b426c5c06f5b437791178c2e69c8eff2d094f77cf4e57d8b5342c165d41650c3995f27637768e423fc1f46d56f534687b2a2419148a5a687bc925d2158346e7799ed09720149194f1ad784758e588bf653e2f4ff9868fcb4e878945fbfb96248e3bc0596aa98ad447ce2125492e64a682f822336989670ef0570ecfd66ab8b4250dbe3cb95a46f3fe83c1093d7347969462d3a62b450d9eab07235ac9b53d1e117fce862ccdd9d30e106a6a8091d1c194cf604e1b05c37d195ea1839014acaf5362a72b49108a45ec87c30d52757c4b285c7d5a84c159098786f6e1480214beabccb2a181bc8eb584bd15609de5ab250d02f5aaa57f9222e8779a4e5ec56644eabab2294be9225649da7d86add4438e0cc85216019b928583e62a61037e1a881ce809fcc3c28432c6e842107e6b0d830851b060344653b075b0a2e8e48dc36883c73d4388cb795899c2bca7901324de190c805d2e95afae86b7e5346fae46d87d46084801564468f4f7962e68f0df187925fb66af8e1f5129608335f5c8c48975f156d22ffd6ccba6409846342bb5b32bd66075e80823308b06c755e2623199bdc04322f7b04b9baae315637f958eda043b6291ad83803ed87ff5a8332193cf7bddc70890b916d378bf40f4904925ef6870fd156b8c1a8a8e83241e8e8778c3fd290ca308e93288377d0fe7376c83114fbafe91d5bd55a731e47a5e7735224ddfe4a0f2d8452da9323332064b454b88ab4602d23595609734b537a98142e7dc9cc27e4f37b218b6e80bf45deb1672b4663bee6fc56d5316cb0f287ba76d2808e36dbb62112b51e9ab5f31225a0cea1ec9a04ca0f71f963c59fed21f6e1c43b21e63941bde17899515a13cfc41df40381eb2119e1f33344c7845832988bf2e38cbc5ad6c850aede6a1664458bac7018d51ef2980efcbadd2d78cb8b0446171a5251c0652e5012ba315ea0b0909b391d868048e40093a15cf5643616839560f570c6ff5f60e78f0588a2a0ccc169f5c4cff513743c329b728ba7569c7a589b3ea4233067213e2e324fa6aa5c6d95e405e1cf473415d0b5ebb95d870bd87db1021a820892edf202755ac97b725824b6f07e9fff1a5549eddd1f25fe17c1546be19c81a748e7142316534eceadb170d7c5fce467c1ca36ca020ec4e9ab0343a5bc898d8fdb15f2bbc5409801ca2c8658b9e37da4fe0c816b7083feaecb73f4f05d8fdb58c8bb74ba6acb7185bddedf842266808656d83f0c1b5d51cd76bfad2527783ef099a91427cd9eb953a1a928425ccea331a87fbcd2bbb8ad1bf83c524b968eb92daa94feb16095bd813f0cd4b39e885cc858c4aee3dd0f978037c608189232b21207d8d4d2fdd90863dd5abdc0b254f327a5efce0fdebacccad0ac28b68638cde894e9cb7231f8090c7e0844e3fe0ca650a384fefdfc877bed3822750a3318096eb8bc84de55e981d55d2ff25d11d688a01e2b4ed8a1f1e7c6e580ad6f4207d7579adaeac8cb7b26b093c7bb776b4bf63ea0d65ea259e917b77b23bc57c47fdb6e9c56e740bd3040fec3e34c3060c27e8482cc4d192cc7dc2a67da4eb5e61f203aaf5e98489665c2b2a3a46c3312262bc731666933ec7672080c5eba93d45f469896c15ebbce876213957573a23d5ef86c788666ce3a2ca65149dd4736656b3a48991041d7086a9bd1904ecb3367a6496181c9677ff9f15ee00c2f2efcb1c8f915ca262beb46063d1114cfdb67abc4ad57d13e2582e7e388f2c9ebccd186ebd80b29dae9198b0c7d4fd07f054227d81b7259b73c9a73d243380fa22946d3ee8bff26a607381268c966ec409e8153311977f32f30f77ef1be0c5a3f2363f2f22bf053da1f57e4f580ba84047bce2b5d8cb2564a961a988285c63f40615e0057899060ab0d97763280d27d91b6594791ad3a7f8123701b933ddda3bcac2d6c964c932a79849c24419a7a9bbebb5d3bd01bb63d77346013b141c7bffbd025108b815b3cc1d8cd3aa4c52dc86362356c5b4d9cc8caddfca0b26d516eff06ca4f71664630c0cf5547d98071df6ce5e5ef522cdef75c151202b7dbf8d82a68b5d7372e883a17b525eb8834f1ba2bdeef4b40332e73c1c2d5e96db01250104b99dd72648584e0ac51ade96ebde11631254ea15cbd2bfb6d07861795434b50a7b139e58394c2998371e7577c359c40d8e42562942ad3a015da195b3b15b373ff9bc9a3c6787a8a49162eb5c463586a486c29dd9428cd155b01d81f8f33d84cd7afd656d1073f743ac387eaabaae5133a16dc5806657bfb58f4393e0e67cb9b6573cde12e382243f0ea8218d0c4eca18414516b592377d7471579cf262fc32ba1103bcafd5c8875d63e0a47f178f206c7c732d789933cfe6edd61a326f839ddd30dfb2c1bf90e6acafb590acd9aa70199ae475ad8dd0be2f0f0271db9411bb4562dac2a76d903e42832eb19b1fa4ebaf01aa334100fd4d5637c997e5cf8a16d33d9460eb5ebe588f7e9136d2abbe5001d13fdb0727345bfe2718babb7d77aedab81fb402c9a070547a52e01e34663c375d878b4f18e585d68af1727b1bf81eb9527f3a81cf655c9bce9c863203bb1bd5067cba2287a92cd883cf0867e257d823d87a13798eebba3410264a62dbf5c085bea420f9c4d68e805fcb78a3d565334bd5d72fbffd37aa6ceb568a6fdc86ff9e4925c6eb977023b5d91a4a04b04057227fdf8577cf593e273bcc587a25d66fe4067b51640fc546292600ed6275c93f6689d8723c8c5ab91252bee5f2fb093f3cd89020eeb783b67b70a89ebff626caa4721ac7e253183559b07bf79e2f01237c8595fdc7d9159c6c24448fbc3ba881e9838c9d9de4956d99a487b367784c13947585a0ad026b1d2d8c90abfc79d90bd13a2216fbd20ec5489d89641379bca7b0c72a97baa6c917a2c33e972fa438d5f57f401173a49be1d592c595aad99cd0dfb0fb9f3b542f3836efde19dd8bb621d3186016cd9bdaca47be96936852a3e8fea56d0a855904788fe1dcf6fb41512f299bc7b715b074cec228fc25b4a5dd2b8585074a9300215f8692f64c83f432801dae25fd9fe10d46bd1f4c080ae0795e0f4572601016479222d13b82efa8224ae2c1d3494c9b37371de9b2356cd2b613aa15e4d64e54c004df435e4e23509c53f6ad557199b2273ecbef4826646e15c9f6c97698de789cd6c80c58631a32cda3c3deb1062e0224be09e30e251f29ae4b070606c1397c017fdebf44a4d69506919fa008a92c41c792a50c507b675fd87c9de2fada374e394b08901c1b783df14e381101039ceb3d27b97d21395778ff9fc91ffb42e1fdd2e9892ad597f7588671c7d00fcb3bbd9dbcd1f45be050963896de6d1539feed0ccc9114d87834dae0015c70757aaff861bee0774e5d65dbc2ecc332cf98a68943734a71b896001f6b452fe2fa54146d1c59edfc1a5a7ea20316245f8341cde8b18ef6f4e5885e7bca3070dcb7066c90232f48f0b841d0889a30bee873aeebcc987c1058e5feefc8b02ee593634192391cb136b40966040c09438a000c4b68e6768c047db90c3d272fdf6804c40af9b66c75d9380cba324dbc3229ab757b4fb08eaf6716286f7f468a7de272dc9d538313681da06bbe854f2251c667b72282824ff78d6bbaf968d6090a7b2e511172cde730418fb42713306a23db152e2b4d305eae261f2ebc88d4d2281d2d1490624b24a046e1816d8dc1d4062b195fd56a039a302a2fc937a28680126978c5548bfe2072da0b86d652b97ed83d8c9d2111355e9918f686c75089498cc65699bd5ac027890a8fa3f0865292c9eda762951f9545ec8d859bbaa67ca41ed6cdac59a6d409a8360f53910313f6e1e1688d4b6143cfd6c22cdab49546be7d4f44d3f8c07c8af622bdc59efaf9472862ab18fe81ba9a9bf2fc9e4572729a7de7087da5b8b2e5f24cd4776d4807769bc033df3ea26d836bc29a06edee888fbc6d4b0e4f82b2a6aba9fdd3066d0e50e704cbd559a8a5b3270026016069ef717a371b50f803d7a6e34e96532314af507353c3be028d81911c1d88a9a0df9bd0f2f18952813338ffed0a4ebdef887717f4b768eece7f02be7891a4e5a6867bab41bd36f7e5c1aa672f777794132e65b620771f3ae3697d097b49013ffc7c43a40b0910c09814d6ec6635e0c222b3ff4da080fb77ac08cbe44db5cea88325f6e4b0e687543be699df554fa222fd5d0401dfd6a74d6b095ad99cd67941e4c16cdf79faffe333abc9ac3fa92584c309cf9b4d885176152f0d6bf2afb6feeaff3f30be609c3a5a1f1fb60fa1847ce99da7e90a016dd4974f610e777b1c0cb7b68d102bc38965f3d8b74132283b6a7a6ed7487048d80bc1b901052c423dbb9a2851bb5239b978f9f494d63469da7a8c5807cb70cee0837e3f4f41a71d78cae05b8ddab74c5b952bc5b5619ce482804028e002ff3ad9616d4556b61567d588ca3519bab043b02cd5dde1ef1fc96fc84f6d532f743c62ab942ad91076d9bc60cc7abe30f9db440901ca21fbb94378187a187403bc9f81fd80c63894a2ee15718995955f63b3931549b9282c3d6c886ff87666040c3e1b447d9f4b2dca1f9e0116e272d433859be3cf4ed2a9c4b8fb4f461c0ba3b77adb0266251cbf880c994b5df20fcb1c6510f7c2885664b82692e8dfa6d552aa95c46d1d16815c7e41ce39be288edbef8d9e74056db94dd50ed5d497f15dc5521c167e07840bc0d4c53275483c64b10303397e24de094b97dce6eb47df3e625dd390540ee91761524bef0e3e8ea5e00b53594800865f74806e79793dd6b4aee0fa74e09dc2ef7c9cc41a517dda7611d84cb50e96fe5228005a692db00d4164ae382b6b85f6e50cda2130277ea25d3901865a9bff5ff58b8a8dc6f2243f56837f618af26a5d97edd3225ee70f01e0cbc1ee5ccc9f19d866312ef03c4c2d7469d8812650b397332a9aa8b14a2128ab5966771d081e4c19de73713037a28a89aca032723a4c656f25cb1d1d3100d4110e741619475ed892fba94bacaf2e9e7fe79948d68028422879950da01b853409c52cd883a43e597d7442eb69aec02ad9965b68246132d8b021a24c559ff9321c28d004de85d352f425fa3fca0585755cc6446b6517d2f712c9bfb1a447cf00b153c6eb401c26eaed9763a649701967bd138502364efe17262b13a87bef2ba578468ebb6771c4b4acba5293b86e039b668fd85a5a0be8235f1d135fe3cdcb0753379e7308550495cc8a562b4a07c669cf3535731c5a97001fd647d1294a1c05726c4a0ef2c02adaadda24f944135d924f0288d28287662f17e9f9fb5aca406f8f45e641ef7b5884b9c02df79ee42f62a7a0a4e452918b2767ce184ff269412cfe9b4c8dcc030157549bfb82152db62de2cd706dda77ae8a1db7d411fac40a8273b6d9ae743c22bc3891705ff5f5dd828015b8c36a7187ce6c8c3f2d47381764d313d2251ee8c39b4603a6eab86d7ef88da096c723a5bbc2fb1be325dfc252db9863257f55de87efb7016b1e0a7797c5e3bd51748a64597e7283505dfa632fc2aa082f58a77b8b70088473b3cb54c53e40250e5474c8dff01ec2c0ac0e93d5984510a351acd55eb252841e2640fba82d967cd1e539c903c97b48a8ed531c59385f26b81bbbd55ce0d8004988d3e7801cbc33336434895856236ac3135c097e8a5473bbd1583856769a7a90ecd92a2780526ccc7654b1e909f13d632a574fceba26a077d1faf62354b1ae2e4dd5fdb9a55ab0c83638bc01574287f724e17f6d3e06c79f6f02b4d36b9ca64bcb70907a828b36218b3fc819e03dbe3dbd35829643129bbe092f127b08ab2d3aeb4bec5060e5e0df1d70d57edc7149b76801ff0fa82d5afa4f3d911bde19f7b198be4d0e944560401e90dbcb07cad537052e9df4892f9144dca7a64992e26aeb5597e0337699dd013bcec5a0ec7caac72e94f08553e049e88a7615eead48094854fcd1af0af86cae838cd1be9edd832c9c4aa2837bd596573bdc3e0cc1e35d709f0985272e4371c9839e572a9a8394c9a65453cc5bbb0bae4296f4f85748655c41e5bac58c6856ad26642186ccc3fcfc8348a879b9107305ddaf350eddbaece48b7626ffbf3a0f104e33767ba30bac731917839ef9ed4a47484fa06a2f8f7c157d7adbffd4faf6129eb4701411f696594c2761dc3df591c675c35f63f5f82c4dce9d0eb5eabfc996c61a5c0aeeba692636eadd9743f6080e8180e7d877b02fdf8af3be3d750724a5a51d7261afa3831ce4b6d51d8c5ce1149867213272b4a9f7a8173332d3d5fd0828982722ac6262770b0c6d715084089a110de2db1e2064f0cbd37439df2da974c0f87f069cc8ba873a5a3f19759700dc709a725bc4fbc1bf0786c969a04d3a1ae7ac4b54b9d3766dc94b91c0e3bb00cf70da954859e8b070fd35977dea1df79d9515cf7d3a4ae2dc07fe0e6dc52ec65c48f6ba419284b50eb29bc1dc601b8ddc596cc8c331b89646badae970762deb8be3d8fb8474eec568aae4d8534af027e7be623791294bdeee6a1b5aeb6d989ee2f48e63e8a8a02c9164635abdfb41c72c985c8d6922fb7a1479e6ff6ba37ff8a14a73dc5ec86ad2cfbc8e1f34c2bc1ca6ea77aa0fa6197a5f4f4e2372438bffe15487b168687a1ab8c01ef710f106d7d5848109ca597e554f5731d7173187065fd7090fa921fd2d5c87e24b5a46d4f695b8780a29be52759fb8b93fb8ccedbdf113f3c9bc7f44e157e33d9f07dffa25005e566d6f4d0e319c34cc6368629274c540bc9c213f1880c3fa7c8012a7b3e3025a00bc83b476ce55e10aa5951d54f3024bc505d66f85b338d74f1f4fdceb812bb6268f0591c44f9620f09b9ed92f76a0630784e7d32df73e3130ee9bf7ba09870365056c2494e68c24f9a4470b5936bb570947d43eea5f41760836a69dfb094b3ee003c83a2ed8b226456c8e401f6817854bfe96a4fa3a005856c113d13b3203f0c01af45781547df430663e7829dd0b716c8c08196f72a598b01cfb6a944900e6b4696807abf891303ef835c9a638e10a72d319f59fac641306d165963ccb0cc19273ae97cc2b51a3569e231a1d098250f7cdc6eaa8c722a118f57b84f8ce97cdeb8362ff81eca9b20dfe14defbc0053780c562d96f30afafa078e942df250a4d379b57b7d471082dd254dba8e72908a63bedcea7074c90882e5eef7643685953051d429ad95a9b0fa92e485bdceaa19d0317ac319b5d2998da0ed0acea8720ea36ed5b12ec6db8bf0d8452303b0f92408d4497f664e5fc7f9cc24721d89dac989fa3c4f0c340d0273e6d628635c775f29711fdfd34f0d2a242532f0998d002381844d6f5f886a63ff4529de5f78fa731cf375e511fd20a056462514ce3a3d75221baaaa7c22359d5206397812f85e417b1b6e7a85f4b13d0b97bffd542a76aa9be960cd0f5b7fe4b56afd28876f3578283478979828d14ef5292a2481e0acab4cc3aa3bda72c56f40a1721bd1eab284c2c542fcd98b74faf0373314a1c853518d1c991be72f42f29b2db0260cf969251facd598def0470de82bc8e7b406d062ad780271f89de89adbb80e6af4f85041806c18c413bf76d9315e552802bb8d001d90385cba6e8e7a0c9c1a90941517bfb2b04b697c7e32f566948a11d096c64f6c206db0b2c68ffdd1190144c404cb5c2a6dcb41620ba06ad20b5cafbea75a24346ef3eab41e4c6c7b86ac9b266411ccac3f217d3b099257db4a19dae253c88a8223244ede9706cbb7e59cb233704bda2764c9e8c00f425f1beb6431bb170c20299ab53d32cdf6bc8bcc6d17994a6378d586d667de9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"13e19e30e38d1bdcc478d8da2eb0ec87"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
