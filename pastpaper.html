<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>PhysicsBuddy</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />
        <link rel="apple-touch-icon" sizes="180x180" href="favicon_io/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="favicon_io/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicon_io/favicon-16x16.png">
        <link rel="manifest" href="favicon_io/site.webmanifest">
        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #F46C36;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #F46C36;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #00818F;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">PhysicsBuddy</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Sign in " />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ffc40ae80b778a1ba6ca34bd841608aea9c868cb29a06fdc2ff22999663d639414750a7d6896eb7170bd9d7174b4b6adde623c8a211c05b93938bdca37e1665c49da6e77fa3bb799b9e3fe40d2a4499de1f8cd60cc2abac90e7a2362c2889f8c0ecbab50f83c5fcfe8bbbd8004e912df811d4e79d5c20331e43849f02e359d54bd8f11637dc699d7ea4bb7502cee46de0ddbc171e198dab33ee46d306ced4ca89438896c7064353f1eaf9818ac28cdb9f1e5b566cd3199c0a7c9da8745d2389765dc6d4774456b2ee2f2105e92a58df5b758ba63ba0b7f0440864b7039cbd9642c6fa124dfc766e91507b68f5823a002f99dfa17194eedc009209e8822a19d4e4624ae0c75c3d48d3c32fa79d47133cfa4f746536aafef593576f234743a946d2d5a87ae41312c5d4e742933ff4de68d57972800550e696b3b6c90bb2e4ade61675d09a72166f70999e2964dffdd9c2ddb7150d996fc6317b2ef8941a837723fe2d672ac070de1676095218583d0171e5b40f8ab32c07773e0c9613b5e4958694097b7cb28d0a15ebc60088c0e9166aaeef44cae56971e836874360f93b0e7139c251fd25cf4f8c3b53f83c885567edbfd73deff1ad00304986d323cb1d20d344fdd7401f00ae09c712989e4022dd66942ef264a24d0b7fac938ab59f62ffcc3c0005b3582c865c6ece9d79167898cd910353397671e645f2a48e7a86aa98bfcfd3322adac36b497967d75dbf037b2a2c3ed3bad5942113bbc612397b47af0c236a5d6c9ee653996675cebec722eddca9d0a8bad963d4d4b64972febaa848ae0c0126d9f02718bc3d7cd39409ee355ee4e19ca2541f307a2e1185b354d621080b5edac035dd8beb8e94dfff88941549f11c43d87d8c69920d9f3f87967bb284046824f60388e5a3848521478876ce08c7089340da863aa9ce9a3cf6a58a3f49d7209cc38144fd33e144b6fb9a8a3d2c50035f93ef4fe54562d53d3cb1a449200e78f95d0351752a88dedaf8c153faf753a2abfb9a4b4188564b3012f18c2d5203c2c13599d5affa37f0bb7a5223472450c5f7bd15e906526be3120f18c4d6b69cbb2c70d719cec2a15e577df5eff6359800c7fe5d1855253078283f90946fcdecf70f397eb1918017a5c034ed789ef45460c985e5186d2322a724139cc08bcf83f07e02a85f7978066c506f362bcba337314c26f934d490d0ad6276f6765a2ec4743115b01297202b77e519a18c841716f13558efbbcc05a47cf8e0890cfcdd702ccfa6615d46db68298d0d7a3582a96cee95d69386666fe7c85aed5abad53d6957d18ea68208389eb5f336dfccb6c0ca32afe5f1692ae6d0df61fff8cfec277848bcf0e195cfe218cd6f29781df359c20017efd2a17f446216bb02d560933373a86d798923de8ae1d5cc1fa5efaa63750d0323f2854e03da19d8ac6583ec97b9f2dee608bbf2c691ad514a84c5f98acf5d2804285a59028a6522a58ffd5a469e417389f7a2fca9ca6fa3fb43543ed0834507c84e6841ce5c15dad302cfdd8a517a3d1b80337e5f0b94a2e8c516d9b5d7059a1261c863408b1220f3780a689f8ab99ed92e4602a1176371076494c9afc21f344e92790280c322d1735072cc946778b4a0b87eafbf46f08ae60f244920e0613f6ae35eda04043723a07f3189e6e55b0db1c756721ebb73cec4e18e5702675b4bf7b90172bda8f6fc8040c11ba54172e890405053de509f59419c648018b38761fa2f0f63f277c00ed5452303ff94c9c44e62459db15e3e83c75a38e1975f32ad11ed59af44df4dd34761ee7ba1bd389dd291f6a12dfeb4d313571b6eea7c3c121ceb3657ec4f2d58e03c5f3c8780e1c167a07fa67f6185a1e5df157b358559f2f1d7eeaa7f086bcc2f77ecb1e8a4f6aa4ee16d1ffe3ce53fc451754c7cc9b90ded5bfa7112303d98dab9def52356138af76a0cfe3ff03e078c269f509d97291c392263e28d262d7f77a1197d38cd8048cc1c11d2d35c590ce0b85119deef8ab21f364d9e3453f35981740666c00df6ec5598bb21504762079a1ac8f1661c97940b0f4cb6c01a4feb5dff2c616592e7c79a2d7425cea0eab43d614306ce17afc2760228b8be07e0c2d491429b486816502293545768a1b792a03c10d046bb3e94a54339389371f98f14716f8875b30fe2d809f2bc55e9f98232dfda43e880e45d04f56b564f4a38bd98a88f92570e7c06581a36c5f672ca729876822e3e4be34c6a97c30255b5513635b1002fe90dd11a3730dedd58aa64cec34f4eabcab50ec3bb3234ef17263f94aed1ad009c42f945a61b79bd7aaf6d2d878f14b6925749eb1aa138dd155fdb26078bf89db3efc5ecf786efedfd844a938454aa15400cde2e5da764c53d3366241f117feea69db1233f36c8ceacfbab7918dd6de820f244136a1a33ff675a43b73234a59d46d3a676ede24068be6245eb993b3f0529a9ee819cd4e42b81bf78a9c732c3f736d7201c57b07ea4561abd3878ac5427bbb3318abbfb212e74cea2d4a4525127b92e6eaaba1e7241fa8b9cea867f3efa5199538421e649fb26eba846c631499434a343fd2584e357c0049af4cc7aa179ba7554ce97248276b668ece7328afd9f35c2624850490b20571f2246ef9830266fb3ac5acd0ad244e352abad6f0a26f3cd60384d58464c5b1207ff90e17021aef299a80f9c568cb2f8db90208919ccef9d41c984f14634d2492f9994162e9ccda0f034e4283cd90d9d024649ba0f4ad1b5e5d889709a064d14b430e62801df6652d77cf101c821fa050aca92f1b41fc7b4553d9416ccda8efd8e061bdf7e4044ed5bde2c811a084c6e35392b1981d3d0277f27fb7d2610733547d123c233e80bdac6a851c30b76b967dedb460c1f9ac3b34427a3a09622db8403fbdcb1fcb7396103052b883b7cd11ca3ebbeaa724de67ea29ce6b8a2b0e4377ac632452ccd461a80b0cf63a8a7c9031b6f0e79b860cb3a1d56784e2d244ac2e86fac024a975349d892349f25cf0e688f94de05f93257e1eaae11fc2be7eea3216f0ebf5a8c67a02ea252208e2df85cc76c10d203bac327193b6df5bba521226afc1c2f5618f90da8d849b8cbb9ecb167f042dd8acf48fc73e8f93042220221a63bdeec0dab5c042505fa67c4073a7299b8e71b52252421bc386d2c0a7089cabcdd8adec6205fff5d0f988b205198664961985866d6f36b8ac958717b31ca46b94da7f383dbf0482fc61e87ba6f7347480ca3004efc49798aded96f4e08e3ec6a8d80647818ab1d1fa9b5b637db716fbdc455cbf1c43845665cd7868e0e71f2b653f985ef6c769b43364fe15c7472b719cf25c94a2e63a2b295c17b3736fb409c87b913284357b15ca28f8046e45d72f858a6f21a115dd8d756230372b37ee897a1e53e2fb4d4396afc200b092ae93d7f7a4c00e51ebcbc918577cde535caa561075d35088ff8a232abb8cc1ea64a7cc910b433c961ed59b69f107fc2899dacbd02b6fe350b3e899c0047bffbed990bb35d60b55891d1dde0f389a519e2021bee5a6ed039b6eabd819fbf812f2563c6904cbc1eaa01deeba4ce148448233bcd9bbe7fb1c1054ed475c44a03f1500b93e9667a3583ad4329a5716b3123a286f0b72eb680089e1ba0a55cb6223de3e0c105816b7d2bdc09b3d826ab8379b03720cd9494c35fbf03aa633789339460cd8302411bff03935e63c4e8f263def9b493fa8e32ef4ee959e8a9743e9bcabddcfb026b22af279e5942dbf6e9c8bf318eb5320462e18102d503d0b46a1729a907f053327bd7f93f49533dba522ba4a93cc06a292b0920941ad2fd2120f91e940f6ffede7716fbb1737f6915fb2a80ab751f786396d73e0bf4d7d71778ef3b01d77d5456656e055ca38e8fff4fd7115770935a7db634bbac0104043de4983396437b5b3de0ff2fdfe8b6cae95c30771f218e359b1f0b277e23b9ddc574b44286d81fa355de01c109fe16c5444929791cc01b0a7b7c3d25b6b0772f5918b4781b68e8572ce32859bce06611188468e30966635a62cd02c40f068708624842941f4413e9e43bd7fef2aec85ae439a2b8a0265de2dc6783efa1bf13c73266625a94ce2d1517c22e2c4e1d6054b5373042145561b9b07c828907e85a3082638b9202c012b9162c88d0a5cf273d77bfd7e8eae679b09014308efd028d9aa35d6c4ae793edefaa612b2b5fa7eb2f2865a7378d7eb41f82c3ef33d8aeddef34370ac7d0586dd6dbbd2d0b7d3c2d82c2cc953b299c7be26d522b1b7491c6ae03c9a37da5c087a87b1b861cdedecb10bb16f87046b2d3ae9f7379ac2a8f31f76f9fde008ae0573d7e57a100604c276fd7cfb3906a2569e265ba900f1d140c4d8aa126f4a27d71c920b2020b222c0c61223fb5e68c077261489b8e3717d30105f6ac2eeb3d53dbee5ebcb5103a7d5c8cc3b59f2a8879c989b80640abeeb76e997a3dc19580d1ac084b74ef6b6029d66377cbb3980d8bb2f0e24174d03e577354be31f6baaf82fbd3de74f98d3efa076e0bc687ada3dd6405f1f903c94aa5317d66a2aa6820380130aa271c7e017b5fa2f5ac4dbbd28e75cce78302e7426a231d204cc2b68d59001ca6f76dbaba7f922ac57844cdbe9833b3d1a91e76ac35b2f919cd508570b92fda75384be2585bd7eda49e2d61a276d95dc1d9749db31ac628de2ea842c634ac359a4f2a273a4077e0b6999807c6c83646d3aa95f8ad06eca87713b16ca03f4acd44906a2deae5394677d9bff910fef75747924ce4db3c1c9c125a5acc376afa6b097565f610e94d476f3faecea2c3ea532bb01022bcbf52504b392dc1afb28ef5a3d3368a89779fa244cbd135ef01b2dde90a32e886b1d572bbd3d52fa94ba07168d3e13f3b535554b169df51042da31217bffbe537d52dcbf583f1f761844e9849ec6fddb4a023911506896e131189d7f7bbe912ea9ed582e356ed14daa812ebc4444ffa0f92318a12b2970997ec2e56ef49f1ff8eb984bfa36a7f64a3882e3d08b35e034650918d90ab03a68354cd0e25cc7915099fee1c06ec0da4b6b8cbebbba5b592db37fbeac811a74b5b6de3012a533d110baa5fdf9ec3991ac67950f6c806ad9cdecd8e268f9e2b5595c1670538b3b431b0e782a91be7f4b7128c25813a4be5ef43836c683e60473ef7b3a0eee4e219a2e86b5930ffbf435a90aaca3edeffba2b36e6e07d125f6ae8a7362628c81a4c1cc8b28f92da29d31fb6eede682e1de6dad1f949c9b8e28a537042b2c395bde0ac311883f45432a88abf448f4d24de3fad9ebe3aa36605947ab7d9ea9eaf47954970726715f91b0e30b789aeab127bc352f46f2ce0310f25412291fb5bddab6d215aa39a4bf69751b1c2cb2c8b6a0a96db9d3818887be1e2e7418b9dd73fe2bf23083d223f246fefa95885ddce953049813f7bc4bb1d9db45c01c8ce5ac76136a96193da1f673a594e6103a8724d924fe7e5613eb906411c3a5ae7edd04195ad335d5f0bbb1e375ee824c4dfeb7fc382463f76badec6e155a1b027c688760ef7296a8e91820d884c44b1380ebd91b7e8dfbf3d2dab50cbe3bc4d42245ccd444edeec933faa42e06c2559715aaf62459012bbd54d5aabaad6219e460b5cc194ceae0778395d00c503994e45658e4b5345a80141fa3670f9cf7db715842746084550a36a07d749e455e39a71ff82c9fdd72d6b37134f714766cd474ec288cf7fa3d40d9da268481c8b0d88d3a3b805212e247107f5290c7f5c12c5f1b285a99ceea91529847a10a98163944a0d7c303a3362f5629e52b72904082ae33f90a903cc43f821c3a7bffcd2bbcbbade111e6baff2c94017e3f4e37269361cb92c0eecc88eac35d2c2664647d453ca1082b84df01aa4d74ee1c06423037d7286ec7f5d225a821e95e081a1bc756fd7c00d88317f1467859ae7a10f45b06b1f14dc110998dafe8c914927cb4d58327c3fcd9dbfbde6b1dd81df45835d0ef262abd519cf3ea39ab5c9cb942fc974535d1d3b8174ab0532c20a10e887bd8c61f309a4b074871baf7961fa9d0c2f0ce897bae859c415cb7352716fa4d78234e55e3f6205d82a6f610b28fab1bdac6e863baa0a16bb9d4f46ae6828f5205694648d8795165b7e711a8140f83887e0de03047bb8a735085e4ae896cd5a954fee9a56bdc452ee653365c68f847d17f45e860d1ef983f198db916eef3cf0cd1936fc03a364e0cfc6765e20004a2f59f1a5d97f6129f435def2cc346310348b0e0a5a102e629c32632e86df99e8f85ce2948bc8e46365a06baf79d04324a0dfbc82ae1ad46de2868f14c1d247b2fe63a4d50135a5f2323bb31adb40e08f9f9621c5db2c1f9fccf97c460fd852a0675e69791709ed248b0ec1c23761eff7ef968c5bd1b37322da916abcd11afe1faff946f4f5cdb95aa64ccf11e81c400f6e86cd46a4bed1f6f04ce6e4c23ffb22dce6b78c5813e186895550cdc6cb341db36726976afab36c4eefcf0ae21f4c26c758bb74c0b4656830bc657fa463aff355c3af598813c5d7e3efbe4ad8605c4e2fe9c35a8ad147f89523542a205fce09daf6564053d45c08d0f191003686ce1dc365714d9c32a4fb1fdb8e4cd1625605464379177b586277aaf26305ec815dd6a5f3b9349ee98a166f1a87cdc1ffc15d927f0329a4433fe7797f1f0c70fb12fe3a2de0973294e13e6eb5ef4f9767a004d0747277a35238d5463b3497a14856d3cd8ac7b7fe15404f595d3639214b2875454090badfb90e5a99c00fa57a7e087316a774d50f7d85d08cbeb3a674dc88d7d3e644f95594f1fd348e8a6b946d5e381ddd505c2c183dc67accff3da9fbb39ba18039f49c6e88bb779285fe91f2fa6f0ea2573265309ba72fe84b76e0593b84286a672a45629b2a6210983cb99c12bbb33e6d90569c73de9f62d3ddef5c97160951a700eb65e532d95694b00b7f76d99be94122892dc906e6853e86bce8b7d3e34b3a345424ba16342bd419a267abd9b08d9dfe29b72c5795b3769fce2c7c66994c00321b755a5b2c89c034047d435dfca85b396c83a88ecf53e2ee4ec5b11796e3a31f9b6a852f0248813f0977d82eaf24f24c8e4e3dbe4c166df2312b064ce7edc88900b543e8befe66d0b2f47b7d8e5036dc464e83cce55c3e5b2558ddd6a5f4e6cc3b7a85ab667283ffddf96d0fdfbf44c333a106a63581dbe0d74965aa842f0346ce8c34f6ad4c59a69befd7db3e3cb3b96430ba7009b68d53a60a2414aa0898be3f2c24694c9f3b9f6d8d789f51cc3115515fc51c36d7ff4486f6d8c7a5a44c03e261728ebcea161197a4467dcb3a16884d9fa7667477e8d028ae71bf0d6a49f955c0325f554396233f65ba89a2856650cf1111ad621065cf930bc1e86e9377647d7969ad9af52b05f64c9ec513401e7ec4e68cb66d402b456cb999d00f813d49175034397ab071b876e86e6d92fe4305916408f4fd9a7ba9b4c428f5a13245c7c00a6ab775230cae8d817c46799342f51add4d22f6f087a4a3be9cc64f09ce9c4ded247d3a44bca104f94da67fd7e0dbc245a8d2e1e993d22bc4df1b59a6188af091d44a224e32b2b0022a17908b94774fce8528b6b556aab42117fcf5fc90be764cfd509f08d50e3de3be1437a1e4e26c20d7f61bf3dc4125c3bc25c45d15500aa870d3832137a8d57eb13c808aa1a230d0b7fdf89c4e1939aed7adbbc90a1967812e68e6b67caa75b42fe5dcc9f91f1fa9ea8b905c0384a0da97892edb364564d2ec0c5398f1d27d9b3287dcae1b4633ddb2c36fa3c270321a3e4b4e2281a3a47711b094510c54cc172ee6ac099c4f45f3e5e26f6209d6a66d9a10ca9576a44a14833796f2824a56b3c9f246ecffdcfdd5905a46beeb1b5c7916102a7612142ab03d5903df9da1b701605762b3574762a0c1655f19c59b864dbeb2642f6428113321fd2143ba873828d85d98e76ccad40528f73d115760dea052c723c46b08dbc49e26f206ab4bac6e286cbf41804944db2af8d07d115ceae6d231b71f3ab309a41c2307c21b44a8bb918f9dbf4a527126b083dfefda3da16120a3fa351aed37033693c7d3428acb3d15762105cf052e8604c88114b7c302893a319cb7c5e32d65417ddeef972b379fb580b32ae6dc4310bb00ccb2aca32c645c42c5d4122d4c6d042aba6214b5e961d3da050657e2f31e9483a07713123e0d0b460533776246b93381af3cf30f225f1297f0ab774d9541de53a286f3cb7833063e1da12a86271004ce532ee1392178e744b94b2489b5c621332dcfcd6bd3a534a600923e16909440d924d4398adcd4b092a7f70d7fbfd075e06af8c3e6fa21dbe7774e505e964f50d7de18faabdc40b8d6e912152cab794f1dc13cd8eccb6287f5fa9961481bcf1d69eacf68ec44de18ba32fd3d06d9c2fc26535e9c6d913555c990332c634b062fa112e00ae2ba3a6c48c334dafa1fa3dc4f6e6e95f893f4eed0417c896f65ed9c56f6f3b41a5e45ad28d76e5604906f251157c58297d19a2c4f40d19fcd139a57d3783126ba3469704acd51eb189a3c5f52f96e3418715e834b625a763fd0756e4895d9b0c240361bbc1d2c78a487e3ac4e69dc0fa6b6a87b08c574719deaff36cbed400465f266ff10d4493565b8e914f9a45d24184424e89abc60f9b804f86aee64ab14a755cf3797ed9f6e338e717a232515cc8038d8d88b6e5ab0d7325c72e47ca0dea3274c364bc3349e8d0386b3f6afbb3ccf67788e241dd14b0b7619f9d637ac6e8e629a845ffe989e9ed7c4377d8331d97fbebb685ce60c9c9ce2dc4eb56fb4125b501780cb8872f9e5349ad72642d3c1a0b480cea9503b4c9fa2e2333c2b9c7ce7a3b42db6c1299369f12ab432176ade136c81c5f5209ac34222df9c7c9beba04b00125bc80c3c93a251e97a2594bb29396932608fde7a565b8bc49df3a3ac71f95e2073a6b8b1f12b596fe0ed6735e8e3a0b6db3493a94ef876ee715d16b0b1a4b7638864415ad2c19f504d1f21c4df898821b6b674afa3598fc6730807eac1dddc1be6e4f89e2bd54b60d532f228ca0895edb3e0df436c39d97ed0753e876028ffaad6d272ef1c42062eb949cea6821e5a5e858e3d0840f9483da798c4ef7e633a6f5a437db485e621d7f09192386507db573b30338e5cce0c2d4f1c1f95ac2048efd5557fed895ad228cb7bb451fc113132a678afdfc6831d92caae682eda5523386ec1966441af612e4e86c804bf00d0c42d9aa55d9058194214d8162a5d05e0ffb58956f02d123171b7e0804f555d235d5fda4aec45b9df3244f57166032d4d480a091f3b2f626239239c4c148bcf7cd69e80007c69ae2f4e0c6f6d2ebd9a343125645e1d0e0e535be3bf5352402ee24b6ecccb7b257a2b7e1af563c3d40019eb9ccb523aa559bdb98a3851b2f1110cd345cd83340e47741911429889472dcd802f15f181850ca66c659098f85d0b56321990d9b04ba5bca65e67c613dd15c9010c47ebdf35b5fc860dc5cbc88886e6591d52f57d0050a5fc4f735788c878766bdf7372240abaf89550a63ef98a5c8b115adcf584921dad259b7bf47bbb3d3ba39c73e89081a8ac156e1774aa98d33e39f39cb7880bb283fc6d6a0f139cd89923f3dd23e2143a64a40da626e302330c09c5b4e0f865b2e26945fca059e9e647fe39a9c32a58a13f9743378066964b0851b4b68a42ab7cc3c34a171ab105b960729a346ebab855c832f62af8b6e2ed65287eef684caaff599578839d8ae4c915f9284d261cadbd743efbae100de53ff2a085879f80c116b882693a922f6b6a0159de007398222f2997932b46bf1f2597805a2941792a478faa1c3fe06c8b0a0bb46c8e4ab8193d7ae691a75b273418bc76ce361fdc815d4cf515223ee46218c4661970303b85b6e71e410d2a28cb299b620bac8b3812327c0a92b9e93717810c49cd1eb2f2a9bc59a4a5adf393f3398c47bb0a1a202e93c91caa6dca7f21137ddcf3c82eac7465d357ce20f4992ef41defb1449c62af402a768821865b07542b30c609f4c73e18192bf676710be55e7df810ca513dc329273926cbe243813eb69ef7b952365d175c19324e71f977a9d7504758eee9bbaaaa4e444aa593d195f49f723b289c6fc129b675bf9c615e184999bf4126e9bd4338899b87b295c6bb23c9a8e50de8fc3e26f1e854c6fd023aba8b6baee036072be51a7d4b55e63f176315a8e492cc741d5550481c9882145ba0faa73a2832340f831797e0de34be6baa6d697fec0f27aa277c45faf9152e03da930d3da257bd7de079b18cb180144236f318e4916e24e1b39dc0e5dc8ada85796feb34c0a4b9a3d28dec05455fff4e5eef8d0607ed78cdd4ea5ba7b53351e05301787a1b98b952544774c73179704f305e21f612e55faf8abd17b0564317b023dcbd6e6dd5cb80f72b54d7fd99d30b2520ed9f5c0b31777bbd6bf6cbcb93c0b64c10582d2a74e9e7dab87a54d69aef2e92a9d758c680d7528870fe40c89a08e965f003c71b8b1890a87c9311363a9f9c82bd33d9f5bc07a6ad4ffbe19c71fd2153619499f6902ad4ba30d80515cac1b5ac49649db3c4f59a45e722243c11f5596fc21d5aaa6208571893b399cb2cc895bcba14d909b1aaa5015ef90ae4dd828b58017b4b837e0b4f5cca094a65adfde319e3f9d3a77dd0f7ca4e8b5ec9f9de4bb676591fca0640cf55203a105f03e9e16accff8967835934d23373205550b67d05087aae961f516fe48535319834221cb3cdba0c4639a921b459512edba8831b5c32711e768997f4593593d04d65920839fb4d6d6a9917502cbe0cf6596db06506203ddf544f8737f42bfb8156cb688a7d2e88a7b0a0c83044e619d08751f51d5ab5381288c3928ba73311f73b94b33becb2d05027b5445b16b3ac1289d4d2679b0881a5ba3936f2402e9d07e8cc62ffb69cc7640305899e999a8c5a2555ff657dec37c8b959d6759e132f391a009144be45536a98231dc537d946258ef7505e62cb0da4a43faef7eb5ae9a76a5eca2cb9e761651cb5f4daa0ca1c40cc6fc1b30b87af31c3ef8bededf55379974845b2b6b40c87bca1971af1ac20e65aec17cec78761393ee346f4836aaab20f670f9864829f19d189283e1558dcdf9e71cbbb28adb0043055ab3d2f6c13eb15a976f24c6ab9f2491f435ef489c86a23a7711691a414dcf59c1e3e4c62d59756e1b877fa68f98193160d8ffbc1ec7f131e78349e1c8be6fa22c9ea8d430205e7fb955fa55862000e1a133a1b4456ac2f9cd960b893e15e6525436d21a313669451419bfc8420f80cd19def5f6fb8ab3774e9205568db89fbe6f688a8c0577583068a033a5217e747e0856b3c64fcc071738304b7032b666881b20c13680ee142c4184232eb5573ec32172c9aa6eb096f2ef96dcebc1c0f243b49d8629f2ef43f98fb737dd6d0e0408cc626fdbdd708f0234bfaa9dea2517ea5a1a4ebd560ee4a47ce4b3b6324ba752aadf9119f85ab4d439fe185794a67367d0aaf833185636277842faa06b524ff46d036bfc262a1477bb3a6b793b671bab7e8d2a5dd794b355ff293ede95f5d295a2ee413a45398817e141ef8c9b2544e248a8a410e078cce8be0e605228f23a0329bfc5d324ec1e8fd2562fc9e9a4c376452a1ce8af23d57605267bbf2b60e98ffb75f0150fc962e2443823b91ac7d7b158c227a2341d1cbb816999908a4171c796d332b48113d99507f366c41ed56ea73b1ccbcca9c54063e737fb282bad7c72bdc38d380e6814c54d7a1cc601c72fceafa4229f372e1eb8b1b8f3a4ebcade10a831bdf9838fcd5f645c4ba3ecee5c417118fc399b5e62f850f09ed7243e940d00d9fe827616c4409df970db79a56e3cd92d6624639efbfce46fe80a81c9bde6af18a1a7b09b3079bb3b32bd781afcd1f2b920e182858d4c947a96b7fc29baedffa5198e257c2cf94b1d1c46fff97b94188445e8745bb47e458f1ab6e472b1e49ea5a730b79f2092dab3a72fc5c95bdfa05880d989271f8b4f85cd69693a68ab2aa458494ba62d4736e1e4dd97b74cc6d5ba3a2d8800cb6caf92a3ed4abc20062fb9b0bcc4d068d2323a4a6cde8a003f24c687c90fee446ffa8d83df93d0eaf3e2d9a57ecdf815ec07cc1ce4557371dc7c6ec00e089079badad2dfa65d1e0fd813bd7b6c66815ad4921c89d7eb7145b0bf650db95470860e4788931551167888567b95c792164621de5c906999c720da151b0a8de78d17f2d4b3db85c30e3c4d8909fef293215cd0890613e4f90640c5619e9025fa7ab306d6950d32dc4423d11cbf761f42d7af0690194213e8aefe70e60dc10acc239d66303fa8f77c2ce6cd7004af402a92be9cdd45661ce3b4e0c8f13878f82ec173895e06dccbc0151fe0e17ce4a312f6692e75caac3fdce5a81fb99f368626dd4b439570acd162d32a2855100b7a848dd307153aa60db9a5d813c2eb9255a335079c5eeb6aaeadef0c47e07e235543221163ba5a4514c4cf2697e044c517d36b16bb7778b4165327dd970002b0cee04356815ad13890a27729040a75f7437b9ba2385e45d33ed56997701488158ce34ab4359199c111745c618bd93d7c742b25ec25115d7492c4e4c56d309b7b73ef4301b6d4b02c93006c6cc6b4abf033519f98c473a666c76572885f1e1ccab3bfb9495fdc2ab30ffb0bf1316be95fe4ff3720d2224e2d40a1992d01c1613ba54d21f56009cef1c0b3b881f55a9bb4f51a190168bed0f5210c12f8288ac76dab50da7a246e88fbed61312900beceb24be00188986052cb1088fe95c5342f306ac8095db6ba0462e610ee40a5ad5134985c1b37930beaa1d4f6abbfc6cddb648025c8d88a353159c7fd82d7ef35d0c0cde811be3b085b9f067c1f438763ea76b529b0578a5afdcd57d7af6e65ff30ffaf466b14a2af86693e51091e070b7bfc414861fc832f656b7a99c8dbe8c3d302fb86b613fbdb8adb42c668513d745489a7af19dd20a7a5ee97f739e1a1fe81c92950d871267768876f1d9dc52d12f8a1605db7c6d5c61e767edf2908e1b5ac1a0f6c6879b85ce689b6a3bbb88ab1c525c9f54690b919451b00a143a8f54dfab988666d2a4da0253a69a3d926ef3f4d6d3f99cada871e0c48a1836a4134335f4ab45e6a20830a09eb5bb514e6d64323f94809fd2ba4fe306ba8b45af1f74b53ba05c08b9fd33b4a22c1bd9ffabb166893462759b8921bd892aa975e0f3a6c4a2239889ca77d1de56a88e67a5ebf0c98d14d2aed9f913c2855bfb1519908b9c9531c5c0d0f14d7754fa84f099be794a4fc1eff79c62d4788dea0760da7b44bdee6ea4b7f7a8917de772ea2d7688b639221c8219bfb0a21f6f834195ad9cbe3a3e26a2464184abc62cb5ddc2c5826a0b84a090a3c0bf63cc47b3e0611736cca07d1260be32274dacb3ef2d9dd7a473d1dbba7a80064c96a2eb49ad5d6e11a125d3d82e3945083fcbb8256bb16b45d1cdd58e1e66a3cd7d7415fe80fea2bc1f75e54c035acc00fd88d347e3e7f2ece92cb5863bc5060109f8c16616298668be390b5c8c2e434b6644bceb69b7cd26ca2cedcac36e92ed2d02cca9d1591829f7db5fed632cf452e9d3268c7f1d97c037943a98af6f380f29405be8d423c80781ede2f8ff5c76e9d0a2d8dc493f4d80533b7c5c5a6b94b37b27a570e2f8915a5873e1c5d04bb6c1280615fb25489b72e3fccab1d8ffb6e98c000c1a5598916cd6da239fdef7a66b08bdf4e441d6b5d81543365ed9e2dd42893ae29a078611497a09408415d89b2ce3cf99b40958c34499a0c5f1e212674984bd1f30e4854ad9385a7475472b17f5a3b9b82394ba9ac7377344342cbb7cb46f2b22b8b48154309e95d40af49c3bf0ba6f12eba9739383b7fd603de89eab012ae87cd1b44d86d3efff44a3fa5441bbdf9b57dbf6ca4a0c56738d64acd394352990b0061abfcb50203e38db8f581a9d82aadede5ae44fbf868610ace3d8f2041f5ea3f5ee5164748a95aafc65353ad3ec0623c79bcb5326df089358581498f70f14ae4cdd8d8d4012a27e76f303799891c8b0dd7aa0bebf34a129a43dcffac1a39173f87a16365eebcb90e999cd88724cabdbb9ee6fe18cfdc3c516ca051518b18378caa059572ba3602ea20eaefbb17176f06a460cff09175f178d7596cc6a5439c06486b8feb3e6058b060fa066092b6a1eec03f635acd18e90a676e50df955fce1e7c5424efe28e185af0d2d96f3b8a08f48ec056bb29f95cedb864fb03ca1575813832cfdde8a3266f6ae4e1d74aa05e4d1caf115fcc5d23c45febee2e5ed3a5fc78bd751e78b699afc0398ca3f476c3d0517f579fe27b658ba937182fdca055975e0d405b0c430d6b086e4004e007dc631ed1dc7422ea16f32a6354a7bc701777e4d0dc7d784ed5896fc3448ef8ee64c1a4cf1cd061714869f28c6637616e92be9a1f8a35d19671dfb3cd05d17b05da43650c1f68a4e065d010bfb25b8118b1e6f3d4abbaa03e9126ece7bfc53c8e22e75b02e7c6b93526de8cbba65811ba7ed8926e12f34e45c7e0c5026d7b57f8c7246bb8680a1f123fad50ba55b04949c46f32411ffbf8536a30bbd12091216900ee1e9f41865526c68392027bfc56939ce4840d387bb4b84fd40d0c201acb0b3af298d44fdfa46d7946abd3c616dba273a5ab0d17a0b5e853484823eb56da2adde7a53be25901b48c83a1cc3ef8f3430b57d15192d4fa4052248fb9ca5968e9ffdc54ca87d55f7f2a0605a5f0d8b5a6f096b6588f36edc208bfdecc1fa36a367fd2f1d51fff4f23c0adeeffd3891afbb1d5628a7fc050dd5d4f77b17b41e6b35aedc4b7ca06fa284e2be80228e67da7824a509b2cda821b1b963f5fb7f63393ae786ea5cd3f4d484dd469a9977dea178e103f2ff08272f43695f070b6a301b31a03d53901677c08769cf0a2020b3d7dabb37bf0027c96f7c1c9d53ccf9a9d9546de48b6e1444cb620484a3f55726dd13750b21f9f6cae83390b11d5dd28039931bd064f","isRememberEnabled":true,"rememberDurationInDays":"7","staticryptSaltUniqueVariableName":"dd5ee36748ba7d9b7598a5980bfa3473"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
