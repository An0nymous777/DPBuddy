<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>DPBuddy</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #F46C36;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #F46C36;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #00818F;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">DPBuddy</p>
                        <p><p>Check latest email for password (&quot;Remember me&quot; function will be reset when I update the page, so if it is reset pleasse click &quot;Remember me&quot; again to log in faster)</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Sign in " />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec559c5f4fbc72d4b819d18eedaad247cf2fcc97d6513f493a10c0d131938f76c00d4a678c6b8253457f95f6357f2a41f23f2333d1987e33b850ecec5a11dc70ad72477abc543323066796738c9bec9ae8906810187a0fd096fc3bc2ea3c11749ebf2101bd889ddb377f57cbf5a36185dc9e277610c235f6664e2c0f6815757cb853bc961d47375d62058f82d632a01b0db1fe2afd0f0a5b0315cf1dd1c1d309c8bf5e1c49a305c9d6cfa760c74d6598b02f63be0dfe6c3e672c43d30541efb744fb4457570fdc2f17bf210108c21a154a39a66e36585a3623b46f54619775cc87c499a689db859168a792207e6be53904243380b865522d93b6d4a0f2d1ce4eb8282467abb72de0bb9136bb1da6bad77b6ee2485833903a37988d37f8672599f62262758d01b32eeae2bc86944f273b797d48090d59fb22994e96f35b9302aa592e846f67a84cb97fc965f1631e4f0b6d235559ed144a1366121f34d5bc019c853cdcec8b26754ad2711467a893e36cdc0f7ef7541b795dfb608d93443a11c9e46d682d2abe542621cb88b65ca405a6f749a4de0486955a94db4f68a5ef02be75914b9cfd17b174839baa9fed6092957b2ccdb2d94ff989d11ab84116857ed5db6d5d59efb35d27d57d15248efb3820637882c546504f8d399c652b81b03b05e69cbcefd61dd0085c661f896a409b0befba91dce77913020fd0fe2c2d31455a2b20ac0253b7581aa338efed96ffa94ed976afa70c4f984890e4822e98866efc9566926c6accd214228a21a8b8fbc0ecae222046682688afd5586e3aa8eb8632ab194fb2266104701dfe0c7dd6cc360c2bb6a0b1a3c0ac37179eaa94b7e5ba392bcd8b5eaf1f86ab71952299827c85f3c3e772abe0278201f558265a59a59dcbfa3f2dfd27e5ff2357a7e63f28cb839c52a92e7d549dbc189d9b849b35217cec39314a3b360c1b84a4defffef03e0673a55280aadb897b966ba58245d2417f2098d45ad4c8cc19c33d2368124338152de4d90f7033fc991319bd151bfa18d5466ac02f1984b98e44fcfdbd0a22652e0a873d69a792713651dc99c53700cac4681de0a5c1f5f50726ff16b1a630673338a60b5f5edf768d48f4c6ed7a1d7a3065b17c068c19e3ce606c988994216fecb1a0eea6d97479949f4e8aa95cc98bcd96fb6bda8e411614bdf64d8a5d13829e20f0c7bdbd2cffbedc262a2bf9efc82ed698c566ef888ab30e42ecda75eb6b63af191de8392b92c2e6d2f0a9e33a9224775f82b407389d2f433cc2e24f50b8bac88afca0b80711bd31ce88cc5f9fbb69bed7f82399d2e2214b5e02bb01b66b9ff94b10259c390d45ebe3df00aa56e9d7a1ff32a1bdfdfe2c1302dcedb4734daeb5bbbd0edfdf7220da2ded44c593fabfcfe10c0b47e09d7756c139f4c24e7997be6de41f0a9258acb9be43d96388015d7c56e583d182a3654a05cdf0d802ba4ef3b301bc3835c16db06dfa9f992affee4a97b5a28ba4fa0ec842f83efafbd3243be6ffe6706b40af9eccb023c8eaf29840a3bf5299f488a58df1e3363629a28d66fd141243b753bad651eb00772bae249659c3324466a2eb9bc24e5b44a66217c531687f9740389b813e8045f7f64128b68028888949689d88c50f1c511c0938ee52183c8a6bdf6674e4556f1995e463de01cd476bf2bcd69cb47ed085a5a8bbc0794e32a2d1c4520045fa23ef79a4bb9746dd7498c153d26f85b270e2630e051d6f1a432af0064888fd6c91ba10fdf1e4a59841262835baf7fc715c1d37d07f83fe30e5944b05ac3be2548fd18aa6b5aba1ed7ef173f36f67f93c901d5581459a43bfa2ad40d3771ac38d1044a5c168a2dc7bbdbbbe0c2c1c50f95528b8f0573ad6fedf9c1e0aadba98c0a4929da29a1907f41ba05658cae20f9c9c79926928d7f64cb989a5557d7a4ba70b6d3f3f04f6250d81807bb6c6673ac2849a9de7d2fbcc6c2ed53d78e30da0453fc5f4510bb075a67e6fe1a78f6125d1cd92cc34cba7b407d8b2d27ecd2abf75a32824442add7ec7f388a0024bd293ca72166217481d0df143feddf9716c8b4389d6619e16d823f203ef0efeacbcd2b178158c4f0ab93d19689e8accd0f424834bab5f68ee48c822af21dc2ae53ef4c659ad54070f18e0649eb21180e7793759cc5e964897647fc0df9b9eacf411022705a82b51c263ad23f3ef07da4cc71d31cbcaffcd87a37cc62011adae2e319a7d0ddba49552b530fe3b20d77dcd998757a6550745c8e30fc19683b74fd4e725986e986b39ed229546dd00c75663338f441119fd6b3bbebc6aaf4e24715159d4e3a77dfd60be25ce38f0a7750e60431c534b45291fb93c7688db1b9353be7d32f5e469331817d9f29d99e057db072e7cc28baedafd810ea3cdb1291aa9df2a0a8bdec970e4644881e98f56d13425b0a5ad45b594901e58c4c6fa4046e3ce6f2d1460f9e9f5f50a4e12c2378825cecf1990f1a997be5cd97ce09933bbe3efe652bf2b263aec8e8028747592d1a35510e9dd50f09ee14244bbbb0d4272aed643bb169f291e976050b93c694782ebe686471d26fc4bfb303fbc846307140692ce06bb79e652297de0087a538a205f21188e723eba2e4c2e6820d73a636d8ce3fa1cf7ce3802feb06658b562fd8a22fd06cd19996f88de1166d3781c4c4aff0baffd9e40ac4ac25b5004ef389367768f66dd1b907fb4a6d771e444499e5676bbca86b0094da52dfa8fa297342307be62e3844c92db1bf752b55cb85ed1fb199cc41abf66bf548787f8e3e3d8831b11c314f4fcfe45f82e73991e1e6e715c5f022a62fb045870bb7b6a28068e16868107fe6c37998570c08e8ae4f70ab5bd4a3749c379a48361d7bfc05da6b2d54b756090c3495d362c3c2c50f277ac22939a89e1b5de3ee19b014b3f6ce15828d5597cdad8ffc05bc29ab3623cfba55d2ede5a63025ab8f884e686512bd8b5a014ab44fa51c7ee1f0ba9b69087a091daba875cceb6d0bd82154d4a7e70fde90643189d1e8bd2205de3f9aade82f96c14f2e4219df15b9777e5dbeb6b1b2435003b76df526d4059e6efbae5c314a343cf2df1c250bc45ef42b36d2d61ca0f49b8a8d28427ed3f4d951e615a73cc71e5539b457b209aa7448bfe9c8cf8c5c95f5838048f57d656aa22506346b534df391557f847ac957b2746ec22da7d2a7d090bafecb903b96ebdd9e7d74f4d1cc60b964a1e9876dadb9c4fe755a5bedc846833a93cfd797a265e37b1cfd4f52da7a31b2fbbde142fc530601fd29c1ff3436fbe956e02c9d14e2b7cd5b6f4107823c37b0faae2ac1140b4cbeaf8c2de3f1c7acdb6720275dbbf5c4139abc1b7cd032039369eb82fedd9878c595d46e9641589b8bea2f8f508e4a2cd01169c7579cb426a257669810ae7202522cea072c89521f6bb4a05f0aecc677a83a29413b24f521024eb3c3aecd03659034e2c6df829a9cefb5ec3397fa1e292854e2ebe9f85dee83cecc5a0f8c9fc595348b2ab42c7992c578933b1fc500b120b05b363e3beb1888700cf7c5e7304107f3c23e5379efe8ca2419f8e436278753180d5ba37e01a256730ce166990af99460dd736600f84ffb81faaf2e6f39eb47d235638673170b2ad08248aa574300ac0b9ba65396c50de6411d8b78ca4192b87e0bfb9b9aae5cda897801c75a0d6047c3012b011c3f1b0373bf8e36cf44e4739d71c623247d70cded55e55f1af29fa5a9f0c1be8f4ee10d5aa92116f0e48f3f55f9cf6a0648ee0c53da836d4d9a2bb644af9d732771dbea7303a8084bfc5aa21885c4d49b14960bc65f8c761438ca4aa7037cc76454eaff52c1f7b4ccd265d5a0d5163dd295915db31d2afa4eb9276620d5c0a2d111b24381ac1c9794b672b8dba8e574820105ac138403ab7a669dd6d03314a0e2374f4aecdf9f3df73a90a7993de1e02008af45be9aba9546fc766423455a96e9b5cfc148ff9447390c44dcab6be44e852c976c336075e8b6d85d36421d3bfa64061caec43934e02ade2a8576f9b13f61011308a7867030f3b1e2d43e3e284734d82fa959df3a9a22f147cf0c0c71ada65a59b54c07e0d1562603a3538fd7f3ed6ed30b9134b1d67541806483e4ab8ffd979814093cacfd8624a332b4b798336924ae55ee33ac38fac074a415a346bef60c86561a55d4be3ae224280a0245d45475ef1cc9cc6395d5209ddd34185c3c23b8683d92293eeae2acad7608d3d819e1592fca4cfaa5c99f2a88b84f8b973069c83f9a9d042ed6e908cb3a89fd17e182256bbc2d15101fc14321361ae3916957c9b5e11292ebf38b056872972c11df2e5e9539dc1c1c550dd511fecc87a481ae8dc22741cd17ff1128e43ddbe42cd82a46b65e276cb8021df17a1c27351c4a1844e169a2c09a438dcd35eb910ead9298a24e29d3890fe29d458cf95ebbd325491e2d593a48041682875ab7995ccc67c47c54514c909429095d5862ba232170c8d47b85cc9c301c1007b45c2a4f534baad7dc16c9f20f2d6c1f4cd5bf0d586d7f628eabcded1b69597348d5f298edb43f2bd8b21fbe896386f97f249576f346ec5a819dd3c3756ecc2bbbeec5229052e10db7b03301e1b2b0a797b463d7cdbc8aa9695ffd98b523283d25bfbef0c999a737aaa8fa63f09a8a85090e45930c0609a0a8fa1c5a4059a3a52e3b8cdbb9e05c93e798fb13d66d05fdc4c5105b67159f6bc05c04843ac34b8df04ac3c2fd5f46bdfaa9f22cbf98deebf45e5017a00719622a98f01132f690e3340f4b1dbee3374dd15624f573e14f49e490d79971c0b8579866ba9776e83ebf800b6ba6fd93bbfa70f170f99298a096daf11594d5e4119ca074ab919aa1b70f2e7391273e0d0cfbcf60bda7f581593d9c53031de615d914667bb5dad164a5ccd4c146b1f783333a8d41193a3f46d44a1783b9ae3573c096586615d7d09c7ac780119d6812cfd5a795a65588cfdbc72fba3e465359f09c7d8af92f1a2b216438593f919abba3ea46b469dca93f031d40644a241361822da4b47879b4b028d3a0463fdc6b822f6a88e2d97aa4723073f07e06a09dda8e3340900598cb466826c0b9f84ffd394dfb57db41f0d5296a3fde1e1d6f9c59d3599fc1e1bc1b4f7ddb2d859fe70b79d6d2f343943855f72b07e39523ea31680aa7bd2e0721cfa9fde991c2ebdb6ebd2e8aeb4275c617bbeaadde6820d3b874f7ea05d87d5f17d8c244a3f71a597087cc1c002ef070637a9a01ddd2af86101acbfa77780eb8baf75563297156389a3c16919d7a81bc444a3ea2f069f553c4ba4a6902fc51d7699f1ea47d57ceed36df9a9939f579d444cf8abc307f5f11be48dd34125f2f16884fea9fbeb5a001cb82fd82daccf05c95c1380e6ae269175c4dff5d88fefc7fa5cd11685bb9eeba1dfdc076c82856dc7c0d37a86d76bc0062bebb6db19a33fb0194028623b1d627596cca8d9d9d28789a94181ff7c53dd2c221017b9cc931258fa647455cad0881e3991e7f18503f7bd73aed7a573cf3b511ec1f63b7e27f6da196dd16431762726b334b8d0cb5dba5fcfdc46d037033ea24e7054300292b3bef96aee3aa45484d535ae71eb68bf375ddffd5562a4dcabbb25fe9039af17ffb7ec3e313eca56f33e59dac51f4559bc82492371938133992dd6caf4e1788d4bdaf036ad2cd240cc627733ab0eb15e630d0fbbfc54919e25ae97d0c9603431d1fb46ee81b4bf58c024372737ba037e1370a517b551e13c4e03e189f7f9d02fcad9b305002beaafbff290ff7abd88d5144a78ac8835dcb2f3b4a40edce1443915df9e8d7763b0253312e49ef6b5bb3dae7d40a513aa400c052879254172e4a8a2ba8039874967d61a205a3cfe40f5dc5dee27ce124a6b34b0b812b38ae4ca15f0c3edf029ab6e86dbc7bfafe3b75e41ea644c3c8367a829dfe4a4981ef87a3e5738825fd721abf69982e8e5fab196ce2ce7e6a98868c1bba035c7c1a511afa14ce0d38079f15e051951f0b63eee80b1c3f8dbd72b597f6fd33245d40762c1cb59d1252743a3fa9554396913b27d0b3cfbeb7f7373e3a46eee6724d708b4ecb160f48cf8e8b6d7d8d1a0e73e83ea2c37eb612373bf28513bf91a39b5c7deae5cc8fac77532c602c4e7f8dc100858051722211dda7f419d20639159e68647e28ee4099012d193434f38d74eb30b905449d29f06ef1f246427cc714ce02b3a65dc767ad80852b5fe324f58e75d229a5112b6ee9092e2df6a8999918b33b1708eadc2254c514f3461090ace5a359aa83492f980278f81026399671920530a711ae802ff9a5fbe9a20b4b3348f3cb70951a47d09380c40cfa9a345e763a8a9c4c4b490d1cec44523db7126b3fa5514f6c6deb76bbbb3a576c1c86a096a16c063bd3c70ebc175aaeaa5048d70732f57ee025ebefc4f02bbabc2c41bc85f13e62f0309eadab217434bebe4d7930fd5aacd2392a072978512dd6371798d4860263ced1615a048d1d2b1eeee57afcc313e045a044470e58d878a105c8bc6031f383762ade7dd44b806eae8f786e807ad998c69dd922d674ffc90bb737c9e5cf731428f76ffe5648c8f90c648e033465b2e19473ecf6852e2ae3507252f603fc4533f5c711bafbea91cb6db13f4e6c62b37392ce9ada096cb296b04be24f742d3ff3df149d3233d0fd668a67e9b418943d39301a680cc6f062f4007d1d5eace4b6d63461b98688583badafa61b5fb793ae00fef7902451ce184ef3492fde1e64dee5bafccd346ac3bccc54f450c0b02c9dff265a79a2560513f571662559e290e43a95a3da2a78c6e8d97bd70d0b83d682d19ba887b21fd9bf0fc0a71d84b5484778696f5828d43e667f0f8b03b95b471ee72cea84e05c82053e3f9abe1a428a946a0c7866136fcaed08a36723ced017c18fee38e50e6a732fc53a811e4b5a689fe1d2a6d7efcaf7c64aca26f06435a6f86a7f7148ca1a400697bf6656a30dca14292c47ec5194e26c14404f6472b5f110a85132e7b1624034d987173f0d3f8d75bf492a7674a1ab4b4a8c313d585c90e2cec5553c8b9d81caa547b73c66da7ebc6ffc2bed6eff383646bd637db11230d466645c1d59cac30a29630775d6bab9891f510050dc3da7f8f0deaa82e6afbd1d0e3ca606ce6780c92d39765f673799a947d7abed6de585d9c5e021d0959f91bd6c383f168352920df5f5cbf4829ea9ac042fed638f46dac6a9e69685fc97da7b32b346ee142ad01b51fd9fa2265f84ec0f27ea60c499b89ebecff486060f8b22ab75dbd6e2303687064995d6bab01f9bd0b79c494b9210775355b4adcac72694784607537d0f95a01285d6b336b78b3e5e7efc8c881b9830025ac9cb163153142de18e146806c2b0f76dbe2372ac4f7c15c5fc75e68d5d9e4e44d6ca01fd10ceddfacbdabc3bdeca36d731dfc598d7728964655dfa40a15cf2356fd3b88884d093da54b98b8a5b94ce347b942fb8a64586adbc8c4e878b7b5574272a8232734f6db1a819b297d77841f4a26b646ce5be3dea83d5a7bf8e3ada77d37df2354a7f5cbb2973b7f68f4a9b48558859e3656f29f2350ca2f62663076b4f8416ec59dd46e404c496630c0207a0d4e2a9a1ab6006e440986ee5fffa4455480b21fbdee1e36634f7c7d7ff58c359b74b018aef7a606617741b8bc25e246b2e73d624f64c779f1daa09c45e7cde6f42ba3dff81915d71ad9079b5eab8a34ec8e0e907a60a57c5543dea2824a698d17fa5e46777098e5db4e6adb2270aca80b6921db74432b9648c469c5df290b33769673d32a45206076ccf27f021c50638fbb8123946417bdc1329971b28372aca25c80b2dedf10b98e323fdba1c0561732dec65612efa1f4100d0278a142ce8dc563fdcc8d6e73d0957e1036af8338761189237184b3e2bb27c3c483149dcc94d84bd4d06ed30ae9a8252e18b9503f32c2d30c89f7b0d52d8e1b6855c8126731f70434fd7e42816cebaf6f41375ba0695bcd105dc29ce6b2b4b7bfba4abc79e2b55e08d7a4a59e06ecdf57ea47bf4213d0cc753173fb0ef6581f26194a257978ef9c2554ba80b497017bcf16f42690aee3d1ac1bab22380171f8753e125461b61af1f595b9545f3478ed741499b7ef3cd983f5c58fe8823adf46a8007fb70341b02468698d4c90b17ad2173edd397d9d38b696c7947639f2beb8a5a191cdec5aaa7448dd6908ac40550bc078a1d82d3efda5c9c5064af766be52a179153872dc725f280569f8d9269bbe2616076063741acc9ffa8b0c198d7c0a9ce3172c7ab38b99258f043099708ad533525fdef0602162fdb8a16d2a9b10e03a0e9a182b1a37c317ffaa6ec87d55a5df0bf023dcf9fcdf9d5d0abb404e6da64258fcc32e70d10a4c8fcb6314039ec2391b405a930a2d600af1888e22245d62652e216851105a9b7934fb1f8b1441978069cac15d858f1e01cea7da4e33e86a8ba321090aad8cde950013a328e3b81e5adc3c1ce880127a5ab6c0204a545a311f2c9f8f5e0411314549150aef1d033429a43ae2f11fd8d11c1d871c0b71efdb9076df2dca6d56ceee9b2ee6010ea36a9445521992dfab4b562483fc575b51e6f13ca77106c67d4a0c81468e5004996f85f6a98630827091b00d4b4e0271c3db63c45ea3db0fc5690c9fd4ad577fa7244e703c929bd3f417d5f4d2fea22de986026b13d99c2d7a982db811a2c075a36d997d2c4ca3d1e34dfff3c59f049e817dd284f138d80210911169dfb09e0418b408649b3108a209deb27e61982d0a66a500081466b4c7da150ed61964eafacd5208f5fb7c105c2cdac90331613283f666c6482782b53c1a471c2f48296745a50f1892889f8c1f09992721f6162435d249b5a32bfc252b5df3b1f8b85eca72ea26f7be4a719c00d2ba96065b8dc33d7d221dd6f5862c00faf371743904111b8915e9cf5eafe17db99c92f27e5e65b2920e6394acde61af48203c41683be80522362c1f9607584bdb8d7f950736bcd75eaa2a06c284ea8da2466344c23a6ea2344898b6ea29c84f1f09dfed560da579ec423d02d4a3a623a213b57c093f2f370472d4a4ce98e2337864b5747af6bdee99b97f8e2310ab4bc8b54d7ed26d53288a6f9850e8fe0b049fc8c32768b0f7cd77cc45127c06f657b9e471c245d5ce785dc8dbc620df594cb4bc059522841417b2a5de216e9cadf26cdac487daae9d10095eba1d3a63f9a78eccab09d5121481e92b70695be827bcac6ae4b616103c14709bf9589887251a68c915228f24552a64c50636f6d407718932f6eeba550c4b49777b6c592439fd5131ad06618c086c0ea09bed099e64059619847f0fb60ee79898595498b6e5dabe49f0dbb48f36c8320562ec2028480837f8dc8f1a47d1ce48279977719b3cee7d2cf428247c0bb033ad70df2f421955b9f1535a5b4c08c91fc0edc332bfe5aa119d06dea3849d17aec59efb264eae61a31c378c1b20a00fb9ed60cda7373535608283e656007d1d55970deb825d182dfa99a368628efe8ad5043a8d71d5c3a07cd40f58be68b8663939597591fc4083414355bd4463815d4f47c1b6c153ed79d8ea629dd215ce19576949d2254c4d6fbb2fdcd3bb44a7e47971408f6951ed3e00082d6a8a822b482444125b2eb2a76ee4d8cb023f17b6bb80ac5e859892e87c8e41f58a57a7c43420f6c4eed49c989a171fcecd9bd603c157a6d8851339af5ed42aa4828dfb19388ce2d089cae234d4f9b1fee0c5c9bea0f75341cd41a46d6fd4db6f4fe9f857303e550a28de15907bc5ac3514dda35669e2e9728cd7bae84a5927cdac8103b18ded0c3a78902a0c6f499ee7f5905710cd818979b80df9b1d072f4e4171c213ffd8e21a7df3f075e33c46d2bb9e3f27371d4e2d6d730f42afb5af79bbde4243de9d746df283e0dcb7c15e4a2424d9cae1cad1958ccb9b03d3e6d93c7fc8b1a765adbbe2b2d383734b84751566ef80d8d8b5c5fd4b015248af55016641d428ab37868d537ec8ec60fef8434d5d0c708906966fa10e930d4bce336f905ba45bc282f9318a50c45b758b30979d2458ef6492c27232c0ae5fd01d1d2267bd0ca7aa85cbbf38f043f927541d89215d9bba24f24ce3de7172e3a634b99436eb662c7075c2d87ac9e9b872276ae358291acf3a288915a5a70cd2c8dbba8475161961cef2750359185dae19566419de078d36a411d19b552ed78276839dc7f35f2afbb96ff0bb5170054d581b4c27ac225d9cc03493856fa39cc10e7e3c2cbe9dbe030fb5320f2a8cb607e0adbf0efede4418a2dfb419fe5f73d418c1087dc24232b3a00891e8c2d1333938ad15f86ec2e1f627cea0393fcba66ac3995163bb0395561b6e7883ce8b20abd4f4214951edef696a8331dd4c7f0e953588b5a8b4d10e74ec4c4b3f0c3fe316b3251f60fdcbe096478398c2866f3d64fded0b3b0030dec39982c6b5b256a388758a20522e975aabec381cfbb501ca629bf3b93b48f52fcd4cf20a527b5038f94c66320259e6b9938ead4a7739f3f4b97e763b265b43f342affd5bb1e03a07b3473610f11590c73f75b81e1ae694a6701949dcfa846bdb5040421048f159cd0a4e3d80f4a82c9ede49e7f3b67cf1fe0128a8ead7cae4aaea1451b954158c6b3689e3dcee67eb0b8f2d5ea7497a1f9529776ddb27df341313a3cc2c71a6677a186e39ec754ea38892b14b03f328991a8d876a1c162e857dfb11d7b0c4b86c1fcccffdc37e63ae500c4af30f27dbc862b2b35a0bd1c4f69e9fccde220fcdf165daf15d8972631b250be5b71bf7d2ef01e643f3d6f662bfb5c40f2cec24c5e226c5d44c628ce9f7a2a9a8279e05b5e8a113d64843c0e21ecded5946e3aecdb7ff33bfa7569559e68f1bc2e9830f43d2144f9cf4bea9aff7e63898b6cf52f8f95f7f3f36bf6af6921d4d964e790e684d4c08a7bc8ea5d0203b253561bffe55b2f37533fc8fc30f4265612fe36ac6b7f36f918a8de75165e82ef5823853869c65cc9d84e5685c0d46bdbafb09a167f961f9a97d1d806f87bdd74fec52bc0d7dd11634d9f22fc8db8fc929be2123adf94deffd3eef62d5dccfc0a2b1cba3aea63dcb5c635378c90ca7a1ae4f97988897a74af7fbdfc1d497baeb2bf12d07de26b877b291154dd690811e354f9767c74cd7638746179487b9f7c4403e9a37c49a430638773156d1fc3868a49ffecbab9cbbf010d58c4b2b102cc2640e9377ca8b5d3a2ed33fc20d07e73ef0c7427d911ccca054e2a0cd7b9d00e029232ec1c00352cbe4c5fe428ed64ddc3c09303fb052b863476d82c2301ac532854be96ff02e4e96787ed53af7990102f1376e712bf1926424cec595ec6566142d656c074b298e4588db2b747bb04618491ae3076a9feeb4779a970745d4ce745b11654febc67fc7169ddc6e416dc6d6db7a04618da6a2b9d65797ad6976867847d9244f771e1204441c6fde56d0966f38e0bc212f14d0b47e17a3d9cdedff7140355efd5ef156d68bb2d9347bfedb31cead9ee07ac0168f245dcf991b751b271a7c0d60557764930c77b1eda576c309272585e32ce3888809c6459c23043f54ade70bb8115f7aaa81e381d4aafb1b01895410a47f2cab8ae696ac2883817a053e20eb5bc30a7254b5c4d43924dbdcb46af4642c0391ab59005613d22eb479f55b76a92dc5b1cb6c636d9b7d23b0bce61239bbda1ae08e83b28661961ce8fb9d23f598aef575a98297fd2f396d5bbed5cea90c6ee733f3e180864e0b180bc669da856af3dc6fd5dce9b385ecdfc3b246ee79ff71e48ea224fd640e0a92d2bda88ba73c69adbac14f8e28093a7734225bfe9e69046b75bfb1bef458be5a5b375d47c986a1660c0aff92161c0f94cdca46b90505e40e9d4eeec42ec84acf404642e2531054593aa2f9c9abf2b35269e8c2a19dbbca8cb384fa541cbd7ea51f0049c48945e55ead2e33739e43ac729feb29e092ba6abd4b11a58be29e3cc4f9d043dd48d202029fc9d1e9a653b6809e14673c491d0464caf275d02f3374c91e179e49571b12fe28250d763e4e050b19bb46a400e92971ef460ebfa5cdd7257df359afa6f6d3785e5b285b85a1a46d6c6d9127a506dc6403e74cbf4485f44c5bac19fb5d2ead339143d5983ca054e951a4e0dfeff6cccf5a93d76fd3fd5a938049aaf8ba88e416e2d5b205b3ebdfdd7c83f9238ae970e90d0b10937946d57b9ac752c203ccd6d95211b5fbe795c10bf791181ef1f1a6d37eb4f10dca28ea88a554b3651f754fe5b3a705f06a4703465d6defa185a616c8a481ed76f9c1bfc1d6de773ae3907c64e785139f3099d64d5f5c16f7b9b1103ff9bd1b9f14052d6f40bc2663f79ba47b978d88c78594119a51c1db682fc2f86237c95b23c72d4607c9b04a396674a75d93dccbc0ad5a752c9dbf908506fc35fad0ef8eaad8b167b8285b0c9e2a9dc85492ecf42e429d363ac526bb6f70a686356c3719d56dbd932b92fefce6493c6508d6da3d104e090a31768957eb73e2f077547c7bf9bf4331899ec1c0f91b66c6d98d020e36d02afd0e910591ebb23a5b45a3c0ff8004d394b2800d7fb680cdb52a07ed96c774fe79994dde48279d450294ecbe557f02860117c36d6f6cf7240b41f99c29ebd9cf50e8f0fdc2a6bd3c617556e9324872b8b7363eb655129ec487cd986bcf2cb2df9cdff834e31b009dd672c7fd13837765a3a1a755a9a38e23251e0ab745566e7e3694149d9124561a86800f0e7e68cc1f048ddfd1c21bfdc2459887e6d4a78bd8c1c74689be69edb48caf0cde76fb7fb2f1367966c33148ed1fa5c85b5d5acac50943591a0aafcae5451d788ebb6c4ab877e9357a48235fe7e0e9992d8f52956a424515f0fe99805c58a0f0b318d4bb3da628b975ea7c57a21546bc1f6909521a2cb96dfc3f937318e94a3ec5a66b6b3187b60fb1ed20bc5b3761d04518c2d085d1da6bc58bf1efb7874211002783ef04241c29bda549e33a7b412e5b1e8f323a25088b5fd2b0518f8fef31bb133685fd614f0ff75bbd68a40e9cebfccbb184564602fab04c00952f28c801c25dac084ca50dc91e73bb399b61250727be9a48511b64057ee990e8806a50534b3693da3ebfa4d530fd9aae4560f213ea99de47e3b22d13dcf614393edc125eb6a19ce7698d292ad26c65a1075370cc20ec1943abab2c32d85034939e4adc5f9f325a557796874e3aa4534891edb524d1c81ae8199154a22c6f3db1d2ff86ee77c2dcf32cb6b162fc33ed1ca625f6a2165de3fd76be6a9e425244762d284fd43dfd93ada35af641cb852474001eae5546671aefb0dc3407816db72ffd3aced7962eff15b30c4726f83862872fed9b9c01f284ba14ccf17d1ff75140978c97f6e2dc15c4dcd38f4ae53695fa14b24881ee9b574e57cb5a1cc35b345db1e07972bfa30028c6389f1191f5f4f9a33c3eebb2a8815a88fbed5fb242f4894b9c2ffd728c7c95f99273b56e41bea8d5ad29ae87030533d48cf3abf77b14bd67e165940318db0d1b53d6592a10abe5fe17ca87ba843c7ce75d84b7bd8c64aae96233d5c9f7c49d67add3118bced679383573bbdeb2e8650cabbdb3332fa2ed4cc9b9c7e56fd01e9e54e3770c262e47e93e86e6f4f98592c2c43f74942ed4f43b0db6d8e40218d4fd0ea53942df1b0f2079159a3b1c191b424bafabe920f5f330c0cf0fc5bd4aeef8ae803a256b072356ee9b6e08119c272a0840cb444785a4aa310986ba38325f70e2cbdfb4fae2ca7c2e30f17a4d22908d4755fa80eee5aaacf61a6ba9e087830e516ed35d3cbb4711c0e1263f3ccade9f1c84a3ac22c3b6e7f6c5c17305197ab5c92f7e09ada829d091bbf6bc04f71e81d3c869859774c987178643e4898549dfc12e8ea3510a61672ddae6c0c0762d56de0496510dd12c9dec1c52c2565697032b4223144093ed017c064e03e213ec873dcd9d55c3d8c9c478eaf14bfb6eacb269ae53c802688404a650e42d0e18f91f9895f5d659df6579df9f97c1f2a1b05ff275e3361f87e5abe7fa5023563327e948857274193ee2a91e11b636bdf9893fea2821b2ef209a01bf34a41d2c142ae571c82be16cfebf9ae0e0736ac9bfa0af5a7ac5a723660cfd3b680cea025a9a18b37d2c9cc8b17d962378db6c1ad5770bca26b30d48fa2067665a3be72d37347d1ac0fca54fe5345f56bebb96de99dcc29bf2295e729648794c8120207591672a6f9c4c60ffd08c5c4f4c6bd872e2b58d2f0e90082ea65b6feecc0173f9eaf953066472ad31266aae3deba681367d274c234c5dae82d91c3880b487100210e7faa0259b75bb5b9a6d9b64f2738f2af3579f1c73e359ff10173239fbd396c1422ff4081814eaf901a5aae1fe64327270359933b26ff7971cb23d80d8c4dded44af24112261a2d8f71a68bf4c5f42cc9e9fe4c35d68fbfd2d0ddde5af29776d59f82c350717a21d4211532c7486be792a6462c56765b93f09c251936427bb54dbb1f16c25551d0d860cb4b3b5dfb067cbc7390aee47a2f43b81991bc4ba5a8367538b9393e46642aed693a79a3af5c15fcb06b1073c469dab94956fae0a7ee52610204540efeb8e10cbec7bddb67d54c4ea87c281031964faf63a7038fd94fffc90824e90dfe713bd01f51bb8998cf2a6b4d81293827113a91cc777aedf557437adc23ecc7777701865c76e07b99f03ce806f3d4fe4edaab4110ca561fad75f04560281e81fdbec43d22b6beca99c71ba0f480d2aeb0580aae6a6cd22bfd750665a70290a817c3e0da44afc2995c1a47c85cd8797c665ad20f5d0d6e5f9ca88a9713e27eb3cd95f6acdacb3f33802fd45b7f541532bab2f4799811df54c35c8aeb2418e689be19dc9d7992025de21673e2d6c3d0f1a584fbca6bf74e8bd2016f883242bb8a078a8499dab1a32fbcba3d2f641d4c6642fd1410acc710f271cf25ba75f792910a313bdb81d0cdccae2a26f7f848f24f6cab98652a635ff70e8c05b23f60cc54896abd8f9255b7cb3306826ad21fa6d5dc5e11fd12c66281ec7cd1cbed41abc5b444228657e3033f99cbb63c35050f68907155f5cd3d3a8d99545e99f5d4267d562874f218673c4efa69a5388c69654c4c8093aa2a5ff2fbb387c17d983884003a29870c620942309378770308e8158edb316558fa780b1a03a96a434a1769c1a465c7220afc5646d02decf34d44bc64968832c40151ca3cf0e7e6b29360128f4787afc836869e12b53f06a086109d9308f3f71882abc5867f31973bb563c7c43abe13cd3180756e5fa33d48c19c2d3f4482ba2c01527f7fe4e909a6c2eff20ef024508d0e0c6d9ebd8024b1eaa0bec94851740fbda6bf94350455b006f5e448e0862061a16921300a407796971431bb353437efe0a520592a0df42ed5b2738710b36bf078a369e6ec4955310afdf20e734e4122e900a55aed6b408b900c3b8c279640502ab602f3b10e036237a9de83b523cdd532a937d532120e7feea9a87cfae549e22925b064e5b44c3b3fe5a007389d8171f40680f45b2af2bf4ed5fc8ba66919c61214bf3d987fbe19ab71738e9e2aed3493d848d62bf5617bfba15e84159be94b32ac45713f0eb01d23670fcface70f8fc53613cf2cd62fd3590c46f2fda313e45fd25875a20f2b813677ec3520524968496a60322e4adde7d757300e105701e069f891599d06571037f0a6aaf205c47dc7b8454b8f26b86784d304a5bac0a24348c554502a4280e09bab4be2426064c054be575e004254272de4bc12ca361923a80ce030adf2166940b28ac451f77d03c29af46c5f011dcebc98afa7daf1a8abc8a5a6725515d974f5731561a68bd9aa0ee3a0ae94684a7177af2f113e310b431aaafa74cea0ccfb7468d6208bc2c061af7e546f84176a04439a78f43f1d0be501694ca56716d8d87ba5c53b8ad69ac7faa64d6769a8a4d2148a92edec16fe3b25a95527b80f2149ab81091526ef1d608dfe59a94c4bed8e431fac0a69847dc3c5d728f1751d4e9b7b53e3369afac61b22b4ad76ccf25ff8d87c660c3bdc74e2fa08b80e99a391c901b844d614a4bed7420e46f5518d6f350cb17e0b590d53c2c9435c1ca2563852165ec9f95978b2da5536940006c3f99ae96137c09a3657e2a9cf10f31d22a5d7543fa6ebbaa8d1901d55270bf6345002817e086370fcdbe8d5748aefd6e83884ad295a760941377f6c11b8bb5fa768878a879142e37dec2831d980ee2439a50c0221fdf4e306a9fba48faac39944e8279b3ed6dc1cefb7fb973d6caa852c3ea9bb2c509e1a37e57738a295d67c73076faface1e6578f2b6f2e59bca8576c87fe43cce25ead01349ee774b36cc52ca62298d6dfc8a2f2457a6744f5181eda2fb2dcf0acac90647b41e5dec766c14a727be6d460210c7d258baaadf71ae62e22967037ef7caea94352ce8ce9f532fec6197233fdcf8585cf39c400cc0529a8b6de6477369d9b3a551a6f42d0e04e3d883ff8cc970acf73af54c0316de54d9564155dbb14aa3e929f5594ef0f9dac62e70421b72d377b8483b839ddcb81743a6f7f86133e777cc3fa2fd1e02c704b828a4dfe3e00e62cea5751f9ffbd0478bb3962435b9f282a80c737c8842137ff71de186988ccc8a10940a81acf370cf9e3c05f9b1907b9e831e113eb69becaaab3a8e75321e487d9b5ce8f38f49c26a501b739386b3612ad244fbe73677da0d8e1073b15b27c5f25827fcb19af458f3a0be90aee5c51d55d957e10423c5cb108933f21049bfacab7736feff53ee57610150eae34e435158e49012a2e32353d33fa7f8cc09301a57aa979748e74a72d2434db1f5ba4a6a7350774c4f576265d7c3b6bcaf1a62cbf917b7e21700ce7d68b18656ada44ebe1ab8bee62119da08fa6e1ca57afee905b2f5133e4d501f5d108c85e641db11976cdabd9729a4eec829913f74b67c542dcea1c4ab5f2e7126e150346dd87df8c89526d2f1775fa747592a9aae23d6616e12685ad7979a0183ea2d3a532598e7e74b0dde335d85f3ac9dcf5870ae1ff2a39571ed750783b028198d3261ce99c8e563be923a5534355f29db3daf1afa11473366beb12055cda2346d738f75a102aaa00805884bb866bc68e7fc6e956672e477d37a12224210beb1af8e0d25219d4ed9146a0e99f292f10c65a6bd6d40d9275f687353023932538c6557e6308eee58cce5395a76425674af3681edd6398daa88cbefeb5df3d6fdeeb61483dc59dab9d063b35b5b50f51037beb76fc5ce2c489760124c77cb5ebfeea4b19b87d39cb561a1d8db19b91d38adb0da4cf127f0d3d488b858f6e13bcda46a9ac0f2c6b5df3b862307c1c7d88fa5fd2615f25078b05b70c93b2081a5b8c0585ed1bcf50cafefe873912f52dac9b341695b96d549ec5a1cb4f151e3a6e37c2e8f222e5c4a3b418449154c6dad32ee2f6915fa3a1ff72a43b5022346184118447401b2f66dd88a131d4a0768a2b1f47b776906b8399a97b3d9dd0e61f0383475a22c422d72405b3ae5e3ee444ddc8ff3eae1d5bb111779a1cdc728545bf238087a1e02202c086bae883a9453ec6f6b31299893944e6f8d8c1184272660313c9e91d661bfcdce5d746eb6cf976128edc5b39b9797f5fb088662ff861d9bb0d6617ce132aa1c767ca87dfcf2093de0aea3af9d44b2d568d505c7c200e0bea6b750ba83d7b638a8d2da5b303f5fc9ebe571a6aa710fc1a64f6c8ad883763026502f34c78ea2df29eb432a9b69b741cee18fbc5adc24aa19cc2a21ff293e1aaa214e3b8d33c9d3aa4ed15722d8fa1b36f8c8fce3d8ac8fff7dd89cffc182f5992b1950597e45f0f5db50a80e794692fc4d8e34b17a93a4d0c467eee8bc5fb9ab6b8020724b51068ed62626ebfe498cb5cadd69fb5bf76649f7c8f7f750822707026a5c8d2665c4514452b2629829290f02e9efc2a62a855d7fa2437f590ca99ef4147e187685e7475c94f768f61b917e13642a4f2eef6ed8738ce39d7d468e18fe66eb83e02068d065abc9944ac69297d016341ca652ff7a33bb2f6541eba4a11c0fc1e17f5ef1f519001157f1425e328fb1d2e6464aad20ce3189d00b6c32544b55dbbe4784d503a00ef9295c0d101d711607fef92b91148f7edec4e4fef52fc02091d076a9d35503548746a36e79dd9b65c520374f3ba4868ff679a241af969e1c25fb7d18f4c2e7c9a99fd5a44814b103d824e5805f61feef57a91e15eedcb21ad3633c493e06979e98dc818cfca5c0b18fe32bbb38d34d50bd7ba4cb3a8bb0f8450319c68f6daec666358931cf6590c6b2398475e60a7b2553e723351f01e78dd5a57e151dee7442b82cc456c855d5fd4b39bbc7ba9f91972bb74b92f5b3b473a8db352b48ed02d6b75b848b0ac300ceefc7170e50c1e5aefd910f18dc6528144a04961ce1fe92ba61d499d2eff8ecd9362fd48622aae921815086ce16f98e077eec38c63c9547c3b7a6ad318d846f30b7f872c32fa98587dbbd28c64845f4820dd632532a668ccc2c6eb7177c1d5adfeaa580f2bc2a9bd45a869424398ffeb5e05ae9226074927068f8316c0af2fb1b9679021ecccbb366a2250eca7b4cbcc3a1fde085a035874e28f85ac9640eba23d392dcc7e7298b6fc435689b180f60c9a65e404b4c8db376b4e14abd2a9d4c0ee2fe2ac16a1a203bec7d1b1a82f0b4713c26ea2fd8f34976cce64fe49dfa8028a2efbd913671669dd74657969559aed1b4d18e58be417cdfdf62754e5f1d606c6e98d35943ea4c7ca11985891124df43af03a55770b53be8910cb264280011d891510393cfd8dd1e23f99a5753ceae50d4c144c5d01aeca694c12391932e807d1be53fbfb14ff868892d0d24e53a5120506764e3df0305fbca606647b40e4574d3d59e00eeb55ea766ec9b6e944e98182400d83e1faa7e1bc707c4aa7a61f31f4bc7dfe0cf4d035bccdee5a1a6f0c300d9186227bdc5671a8375fdfb52676f058ea7f6c64fe5c7d1106dcda2153f8aad85de43ea77f5b71c2f33238f868cbe392ab1c602caff8196e176588523a9461b05f1e097495f2ac87170cd4387e31ff10a104c30ec1fc41c65a7926f6b1d37388595b366d7513ebdf1ae102e78b2bafa719744241f56ea0e6daece8e83255ca0d790d3a4f7e297ef1fdac1ed3a7038adeaa38e7fe6c2b6cb55c90ee23543ce3d47dba1555b5fbb8a5fbf7634e29f54d66a6ed668190d6a96495082956be10a5e5efcb5d3bead42323f54eaa64b704b59cf15e4e292d34fedbf4970e5e96d9a355f06b3fca9ae5411d6ad430705ca53f39ade68e7be6a5f14e8cdbdfbb17625da4fd4f7daad54ebadae173562222e48ec59b3edcd63bff975c101138e22b41a1358003549d3e11c439d78749286fb0d36e0eca7267f8ab0a3404391fb069b1be7c1f5f8cb01081e8e275c6baeea93275fa93643fc8de2616f1c3eefd62e4fa9568f923523f11971d3f9f95c1268b0f5be7a3a8f098a97f84ec0a32efe0eac7390c9a83e3484a2ffe5f1b9663154418d9df63a8be5aceec30661215d9f598bec37ebe25b21ed6741b7402852091a34052ebd49136d702e6463ac2e2a667d68b6edfa65fe1b83ad9c3bd0f22c4f07b42f84d96f219401083453c2d72c5365042279df8f9b8cb6c230ce8c947e3125bffa22052962055ca40b3f70ea07abbab874028160ade8299c9a8d869e31676e004156d3e6d3fb4c05b884d9969f74016aebcdd9ec7e0029d3df0afa0769ff82c81e190fc2199e11766b36a2fe8f86d40cad9bfcdc2feb3bd5008703e8e27d33d77e949f899980d42c9c6ec8ece9bc5be510b4211829fbe093600f05072c4b5d8401df1c17a1bf0a10e478ffa975cab9be4b88d353fb87d069db89e42dee022f421778e33a107c0d4a13015a4cb6006655317d88ac8aaa889f5100988989b41614597bb3eab12f16cfe00bbbd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4983b9a47a2acb9e631d466cb031a504"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
