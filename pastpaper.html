<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>DPBuddy</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #F46C36;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #F46C36;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #00818F;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">DPBuddy</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Sign in " />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"21e8ac76e0786037dd2b49179ad518ca5d6f7eef14b77a66c8d4914edf857ed0266e1ff8e6b5932877d10f40c49e4eb1fa3f219cae00acb5846460b2aa8c0e81750ba4b76f3b4d31d00828bcbfba75188a326dec80c70975b75163b5ccb49fa58d5077cd1428e40ed2a199f21be409d409fe29766ef0f73a2b33ef7be05b7b669d187385952864819ece5abeb3951689298fbad8aab5a5f36e0966f88f6af38e36cea29ca0f9dcd77e61608e483482bd465ef9f98aa2cea6196b48adacb610384427f47cf5d7896d76104b58c4c1c7d7de8d1b1231836eca43f779b11c8f2f2bf65c594af5a9d3c7123a499212b7efe8bc6af6764e1d4a11a5261ce1e9b6bb7dedf15803a1b3d6caf8efe6d36f34441fc076f500a47c7c02b63f565449105f6648964f22570ff980ccd105acda9759b625d44714011f607294fa8ec11490f14935fe710d8941025903ce0f8b61fc4d7c1652857c7a6cca1461a9e37ee5ec1c4adc3811d857a56dbdcce89c44b26a7ba38513985c8824e65464485f237c5015c710c84429f1f5e428f300e05cae6994c75e84b47b5ce4702d9459670d8fb8bab8dd2e26662212d0e2b5fc13b3734577e387c06d33e09d63a729f6edb0dbb80fa3f14aedf5efa567f824f3920961f96c5211d6d5089e20b0025f76deabc0360fee27e87f099518762088c1c0544c0d068eab6d7bb4e938b6b200f3d2eb8eefba4d774d3c471f5d847b5a6acecbb94b4d92c6c9dccff2f2d7ac1f71edfcba26caf53c83fe3ede4bbe846e936847b1b555f02cb773e3e70fecd9395e43b8dad795f269bfce6a24e025713018f274bfd33bcdee1755f351fbc28b1b99be4acc3dac0d1d37c53cb55add42daa039d87186db06a4678903394c94428745ad1f021421ba61244eebccec44a287cd35d8c9ffeaaf698cb2ade260e7454ed4e520b0380d20e80f94ae3bc33d2a333ce875b147460a553ac1688a137631a7fad90a5b4f66f5ab6ad4e3bce2cdf0132327c638828ee97b8f2957ac4b43610b0437e4c2450de039a2a340c9adfe83a98424fa66a1cb915b62effe8c518664e046253aae8c43fbeeb9fe301adaeccaec3ae260aac2b6613aecf7dc3f5c6645d027b2f944e875780cb4fd7c8ae0c5a1f0da8feb8e2287f257761aeb52627b84fdef5a083539a3583d07baf7067053aae683b93fd2c630cd189e2c50f427994b52eec0b99a49275d1a0b76e176b21720cbc8b53d443ee813ed18e0d5022c7f025e0c3940fb5073034f875138ad08509fd03a0862c28ade94f38d85dc8101f3221b92eb06ea690baa9cdbd310528963da55bfe2788296c2e7746de5c0724391591cd7a99053cb7d01dfde3a2ab978a1e4930245869b64a0618c18ce8b36abafb5c4ee6693d7126bf47d9ff357fb69188c8754934f54fa88a513117ee7a4402dac8aeb2108e1641a3cb4e032e39a3a7572bf757d15bf90649deda86f1130071285fb8653518c0a6cf80a4a1cf9d65742e7a241ac467b9fb2e53e928dcde253a13280b2f8e3d76187523f5b04ffda675bd8681bd5217922ff7c60aebcfa169c2efa4bb03071e1db4efea1511d1de5862f02f78fb7abd70319494405e26936774860c40590053ab24b07b457e7157a0bca7e55abf27382e6f52f89193fa76d44ed5985b4676ce178813d9e5e555ea9d64aa4315edbe9b7aa7db705ad3767f1a89ffff7ce85770bc8cadd217469207b6cf786f42f13b18a6a26dc71fdf939a13ff6d798cbc4b5edb1635e3ebe1f342ae18bfa13ea91f5ba550c9850f37e0a1f2d8e91f1f227b6771697d655386ecc0cf8ac842f4393533d9cb4550ba8c27d40000f07a2e092faf717952ab664158779a7b901736b2bbe10ba560e1d3bc4504633f4a911eb4fdd19bedf3cdd80534f4b4d452fc71c16dcdb36f7ff6b7a80a7366e626db7534785005c83d00986bcbb6da7449fabd0d4bf898071e21259578cc92989e7560542909b1382df8c0db25639a6da4cb88d848872f5328d3f43c16c4fd3f277af4089f8ab504621a9b628b25f8102a4b10d42be9027ba9f2b981c5ce31eeecc0c6082bea32168077763cf48d3f5c9e40800254bfcb19f0e3ad0025fb03e268d6220654c690bc835ca99c62c4d4605284db5483f2f1175d6e391b9a4438b8f48989920bdf451f5c002c16f0b560669dec8a860a6d8569721430b71c8229e3431c59ac48c965ad34c66fe8ce49228980b799cb43ce84baacbf92f9862a33904aa6a4dee757827d9475d485986ce0178ce179d79be8774406ff8a30eedd8c71346decb5b956c8d92520ed97f748c31421b10a0362d6a878fc55e075db708cf019e18ffd91ff60d3c38bfbe796c2cb0ab43e1afc37313bdec3e1f4f230d87e71ddcc91cd31d8d5c2bba66a98218d9cb554e244874c372c682f4fd0f70c1446e46eb4d78839f382748081e9de937565f2f4788e072c3a969bd1006a55535c25e357cb4c08fb39ee6994c10686c03f626e4edd84bb83882693ad89b89877fdce10cad63bb4773efbfe8b0574228c46e32e9b2673c2b6e02dd11960d560d33506c8e901fe49bf9a80d72941bce8bf3e69b48b08d1e948d3340b648c1ee2e5614b73a9958b942790cba3102cc69cda4b46e05362900f92147f1b23156adaf61107ceca63e696d098828423c2ba8b5b3a9042f9c4fcbbaf929e9d59314511714b7c2137794158b684c7c976ff53273445f4be9614aa1e3a97c2b9dcaa6c279b323e439e10a4d1a0abf348f56468446f30d8c84bb07a09f84201903dfcf6dc44a6f51f1ed85390d0cf3a1175e4e79b7f202889b3d6e90ce6ec4c09f1023266688658e83c9ba947636b9e947316aef72621c1115f8dbf49646ed081a4e0da1a2bbc54dda8eed9f78a88de735851f8b06b8232e4b9e1d355ea953a7ac505bfd5d05e1116ac208ff6d734c08e5f7511502a9ea79ae590b2c42d3111692623cc390241bef3a9ad5037d916acf415bd8658b9d81bac9642e3e6b78352841a588b5a13094d401559c8ae1ae221d15b351029ddbf7c1ea2e20979701879eb4fd05e0237392a8d53b4563d2b7c96d6cf451f2778a147929b6dc61098c761a5caa3c57f6216416f0a2da52f2cc4e049a13be9f348faf8e50badab8a90d0aa383bc8cae14bc0606434060c8495deb2047a3ca8377b86e790882db7430c39b5d16db68abbae845a8556377dce426b5ee1dfa399c57e9e56b7995d5390c41fd783aa6507eeb43cf38de0b5fe753d68ba40451b140f4b89c694025fa289449946386b17d6f6b283c8f5a5db63263696c8eca5a620584e5966b2b63c277f64c8ef8ae8c8c46705cc4a9796171785dd9f719df462310e5dbbed6074e752ea95a27b5502bb0cf1544a61da91b0ff9f37cd58f07b279ea46fca11c04c9923799e2e81c7ee1743f706ca02ed7b1f2d9728988826c8e5d96e00740e8cdd09eecb5871805e2114b3511d815827cfe7890540d3be7f0b3a4721764a19285aee4b54367ad6676ad88043009b1e0273ba7761d43649de4529034a1263b652dbffb58a65be2180b97ceff0424ac14aac8ac9f3ba69b433a137a92b456c1d602b7a495c0a1e56984e3d781fae6cb2612d6ea974e00883501532d913798202dce14ddd8cc2df3095ded416e0c3933b1a98fca80381689c499b7b7ebeb3e1a95fe5e5a30697774bb7a2fbc9c4cc66517fb6a814fdeee2a32b803d92f02b2565343dc0f016cc35d68be6c211349b1b1ac366e42aafc185913a672d8231396ab55aceb66fa0bf85b1af205b5ed34dcf581b2844f53ec9115cc7f3d7afcf86ccbc8e9b82cf58e4c62160c8f5bd5f83125f102df71ae57b809bd32a9f759bde53e7bb1b18d08901d5544f6b5da05cfddc96dbc70dd3a85e1bbaadf2259d7f5faf5ae6439f1675781a30a4f1ae3ee16cdf27c9db8b8031ac060131b5b4e0d17916e5c266eb63872fb83d593bf319dd2463ffc43837e12bff8dc247c3747c4c8db68c30d3ca926f55243f193e0935cf74837ef78e2770126dacadbffcd03a3fc3c8b2ccf2b01c3c8fd481a0c5e7380bb847c48506f12174265a4f233163ddb3ebb1502c2da94c2e4a44f246aa297655db7a67ac221713e0db7947c54a50ac674b376430d639bf88a2786ef1497d9615707cfe98908708d03cbdd979f1125f2d735085b5b74ef5a240532dc0aae6230c5a90d49dac2eb2e984e31d408ed1237b513aaba51b41d795c57ad0f21818cd4834db9f30020c7af06b446183e1a399265e7a73dd11501d45e774992bb1c4ac464f48313ac44e6d0881fb51c96f45e44dc2081004885e501e255784db5e29467c5481a62695b9f4a0107aabbca0a0c22c16ba1de5b719363bd74531a444467c7ba0fe15da8f9baecb4e159bf8740606d7f71b87c0205f3529a88564ff0f661e1522c49323d21449eb52d9814a5f8022a9205a0dbf4c327ce908543882e9a94618791e3c2ab40fd04f22f2c5a92786a6449716141a76d87a6ff99dcc2869b3cc9799adefe58715d4735138e383be58fb71cdbc56a736ce66c2d4495fe7b9c0150c271161de8662d27ff748a446a1ceb2da61c7062c30cc21286fcb439890a02b556d29f323aba122346cc1ab810e1c814127378a19fdbfc339210d6061d8e1c57c20f346cd069d91e624ee9f6d3ceb2d1d77b5958e8de6993a8592b82c388d3cddb6dc07483cf0b15938295c6122d3de743deb09ea1fe40a774ab0a610c0d4423eb4d590dba240bb4891c6bd55d3ee3d0776024605895d9e81ff35bb81c4648a7c67eed6998e63ce976fdea6ba539611f2443d40d932bec9911126c8d84f192a24d4723d03f724af978dee8909908b19f2dfe0295b1c1dfe490fb44285970185b0819994aa6f4a379da8c827d408bce168b7d7eb88ab12da7bfcf4e4636492d625dd048f354b734ea70de3bbfdc1fc9684008374b05874c88e8892c28fbc2edefe0e61d6dfca68716294e0ff58ce854f6aeec5b8284448615ee7adbc546c22fd150be36023e2f2bc3df22fd5ae13b4b672a82455edcd30ea591f8410df36e115a02f9a43aa4820d006995161caac79f1cd13a36050c212bb1b21dc43817515fcca4054bf1e6305ec90ffd16c3cc235804ae8a805e21b6d1cace347c434b30c995f2bbfa6ee1422cdffb42823c930e258c045539958bdc5dc66ba9f413510c156c8d286c0e9a14002b5825c3ff096761e82086d4112b42c110a88040acd592fa2fc0e47ea48900f7f74461a564a5dfce7c91c9419cb0a75de28911162145a7a2ca018acd590110d34ba877b2b709ed5350e75241ef954a861c4e3c664973b97d148f271b0e56c14790ffe9ae8d44b792e671d6c4c8b579df6f5f9eab6bac2c6daffd042f844c141d51a7986cef0629d78cc4b77cc1e37df289859e77bc11eb23b95ce2a03f729bae52e35e20772b52c093b1060baf305f89a586ba951fbb9983f9156a64fb7efd2741289888cf933fa8a36dd4da75ee4bda24974fbe821e3b2933b4080ca3955e973ae527989fa2dda4bfd5c65e15436c972bd788bb19e72a76b59c9a760a893f3be30f26b28760bfed553b514b1c6facb8975644d2de7b130032b2a3d9dcc6087f5d89180448ab3a4cf9aba46b2ff47e64709533e4735a82bde8169a30babfb666e15c0c2db47d0ab12746364d7d72331e270b59567f83d007701a88b45060dfc4ccd62706666b00f39b52f8588d38e21d1e8ce12307fec127e64aa66b031253df1882653810e4d046f104d6331fbed6b3170c797599e320b90cd53ae8298326553514174c6e20230ea0d1f053c23e48213d8cef1d7f0cc4f956946d379f76238c7ff71951c347f7fe6e1d8fe5a724538fda609950ddd279c22e4e15b1fd65d347f4eab9abf346b52defee94eccc9f305201d0104af461086bd2753231072d6122a1b3d9786194dd544d3834fb1781a9064ff5bb44854314538ed44aa047e3bd38a773cef56e0b72f211ec3b11af8c5fac69f805dc4c85297afd53c8fee826b134acc1c14536a10def9a80157d64b309b4ebe1936b52ce68de59063aed7832bf1bf10d4a5305ce0db34d2eee45cac85680ae131bda0afd47adb1b45293a9d04e0ef0cee7168faf4979308a6395ba63d0ec5431dbdee16268d9a5117eaff5bae7fda72f1301ea9d23efc5e8e1c46667602f6efa9044dd7795cb4d24d91ba5c47dfe3023bc4a8c71c8ba87838960cefaeb45a1c7ab630803d9dfa24161e57d5db619f3a74477b0f0d41950193d6a9711bb4305ca0eae195a90f41ab0f8804176170548914e2f1a653a7b39b217459e7476804285dd9e0e60c0f146641e801d64d34cfaba5de05ba3126891415ca5696f5fa78cf6d85096a30a092f786ef2940d8d4a240840d62a7a61b22ad0247f28c3018303eb4674621d9bd36df47ac21cdc1538f89bead2ff9be7a7f3e90bc2a4da874a381f79eff5ff44ee363658c6f80131b00cf07d3a0abb655668263c4d178b7c9b637630fac8588f83ebca8d80f2aa23dddca5eef535f41b70940277d600452e1e46098725803540e8227d78c08b4f872a4816b47da8a54c6b8db1e459194c0e0b1949fc112c88e10c3fe08e37db574cbbea836cc4889115d90d9a1f21d02e51f1b4c3e2f12f31273ccf562b4d5b27209ec12d222b1e79986b2fa0a96850d813ed98c68c1f9f366038ea099f6fe6f733913177b5b4595af1473a9b7b4d27d9155445f502567c1adfeaa4bc648406a9169ec09d4fdedadbad06f93edfe27352de7edcfd85a0d6093b5c5c5c8ebe1f86b81585ba91781ab0f46571365f830e4b9317a22ca21d4d1781aa594dffd8e6e350c88f7de6630cc731f3f38e90caaa0db8968b5a17ae291f7826dba57a083e9be8670540a7ca2a2fba40b074dc55d9b686dfe9a1069727211d6c03f446cf8fd8c787748b1135ef03f476dcbd53477cc493dcba1081a875cf9e8d80f8f3c60f34a22808a4c044fb259d69091bfe28bdb6021eb71d864116baa31820ac255ab0f3be43ce02a48e3cd444b61419ad02e2ac1856b1220594e789809f3a50d918f7e156cb87a46ab03299f270ce92bc165616cc7e1e0813b1d9a74d8f58eb6ff91e4f52b138fc2a0680dfbe8922dfc2416ea658ead6a9409192708fe1ceaa139a3da8756b91e752d7b63e5dd6b5431102feaa27e9ddf8b65e2b91c8cdebdd8ba9a661a6cdb32557d302a5d2d25055c0a56475629a99edc211eb10a8f57c36b36e20f6f603d35af9c75cd58c921b1e97a1343a57699dac6d660cbeff9190fc864fff19ab40d99860965dd6e1b6d056645791ed0208472660ee6172a88917f5b815429bfcbf45f1640beb7e74af9099c0f2d59036b385ee1908db749ef94ab04863bb3c544b00fcefc558ac6791d60d19af640a33ecb468ab28fde1358a3b7446f4528666b3345768d44efdcd315179890a7df14674671841b01a1051a47752690e2950be522fe1aa30dc9d9b41bd2040ba59ba33261b9d6bb52805a5ad4432261c213abd790a55125bff7472b95bb368cc403809acf055a919d1df76aa398b5b3c09fb7d03535869254fd58a0b0d69f6ae573d2a95d65386d4d2aff4507da60d76ec1828ee1960d6180a5387ec6f8f60a7906299f5bbbf1793977b906fd9105fc9ecc9f439dc4ae7c2a683f8c3c6870d8812d6132f5135e21b838dd6bcda67d78264a07f9199fc6175980820b0af72bb237a9e5209ffd5ba30b6fe3379641c5fbb1ca9cb336e8a3fbbfea03c22641e104c4a6e00b425d93f23ddd7deae05b943b4b7b6789ab2620fd3712efc8eee5336d64043b6df718bffdbb292bd9035dbb5011926a7461644f71f32d50d6e80b3bc892d7566142b9e9f5745f287fca2a18289dc900c9441e93f6aef77067177929bf2065cdcfbcac32e661d0c49357cc22748ec804e79156b1bb8f2bc2a95da07d1bfe9a8b9b97f774ed6161ebc8de5910e1c41720408e27dddeec4ca156aac7090edfdc663dba0a6ab8770ff93c80e1cfeeb883c34e5f8791a27177113d245d4007ca058db93af2bd438f9aa3b946fe8ba5437528c326588d2eaf023135c2b32b34d17de8449f8c0901421de4f3022e9728781fad1329915a2d96febf0f9dc0d5ba85d48b0647d1afa90db4d69672b9e11b605e6605917787dc041fee0a393b8286f0aa6c5eea94d2801e388bdfdf6e9161df4d9605a3a67d9186c4c581537ca7186d0ae4d0f80ecf4bd23b9d0d631a4be1b23f495c30b1fac20631696cf49f1f34ef6b5e5709f18c2e5add2283b1c65822836c521af4a3bfdb07347b5b8f3a6cc0223415d073f9cfe7f09e0f69a26cdc5f7de98869c605d69c83f216e46403b4bfcb8cda14723c782bd16b1572e9731d7817bf78dcfafc05e3934d4b94c7466d5f6dbe7387b8612ae130b80fe566e58a56553fdf1f8b9d351bdaa5115fe88373118f0a650baa70d12ce32ac2467505679e5e55050334a2019a0794e4c234ebf6f9e9a71ca539a4b0ad39c23e48186d6e8dea6e29a357bf09dc7bedaa0162ed3eece4221518a4e8dd895c0f36a3e4a1b39bd8d24558576b4cd42eddfeeae1cae9b3661051e0de6fa4c98c399b906284a3f6ce1498aa5f368cba31175d37e21acdeb799898cabf25cfafeba0fe441acbaf6756d23b46643e8321edae762689ed934d36d5a1b4f7a4a244298eb48164d74c29136b7107340e0df78b3c60d8cfff6112b2e8a7c6e76cdf89fda12a92c1e8cefad9761ffbe97d67fa471a1871350db7e5272bccf9003161802e19a7f2fe7ee218f334dbce42315b14b952fc37f21e89572fc196c7151e06c22e8ffcff2e11beccbee4198ec3460ae4c9d4ffe57f1905d6475343e8f0a619cb4f24fca78afbf39b1efd3efbd97e48587ac55fbf9fd9d36589b78de4049e5c062f89ce444beffe22e5797b6bfcf1b35865ec17e9e5030093dfa70f712622acae727c0d0fe349212953e2b2e06d1c028da1a17b861923cf78ecd7e7293710c2c06d19ca48b13425d10bf2a092d78f95c756743d39405431ee3429f1dce3bdf7b9edec4778d6e39dbe717c4521cad909f8ddcefb19b6d7415905b78390405dc5b7c959610349e9cd8ec6144dc4a9e8f3b054a5c54940c293e9fd1669b4322e98571a9d3c4c70a6d98f5cbbac49f8921c31db0eadf087f9d3e357ced03fd2ed79faed766a1104177b46e589c7d07b9b19633b6ff0591572109156388302471d4285d4a5fb259dc76d44aa26010bc849e27c45b47d2b6ff7970f6b1bd645c8135c00dde445d9d417d032b7f90e4bccb11e6da93f8fcdf40641a023dbc8430fa4997076f6a06bac883e9f427867db62754341f7e73dff8b1e002cae4b416a9d9e7b3c95a80815dbfc303c353dceac0cf2d401c664bb857746c818b1d2d02fe7deeca32e9a8f07e4396533dbcbae356a3059356e883cf191b49fd40acfe84513d85a70bfdf25d4bf2d3b9e1cf894a1cce014778467a26626973d171215f1f93301fbb28161601a533133c3541dba5909dd022f7daaa2df5d671f439b02f15b7d1dbd7535df36db0c052f923d89d8c7a416c63e8d6ab4fc50e5208f23a5f22ff4db26430ac62e6e8b30381df5f06a2e235a47a96ac5ab651099a2cd8d9acd79b8709fb66222a164d56b122d8ec5292af23bde457c8a0f2bf4a6971567efca6b747d1ac05c79d0566d0a201b45d8874f1d62834a4288fb905c9fd4c9c4aa9eb77cd4b1936919b6d73e090cca88cf8ecdf51704db1542354f0fc51a51da8e4295937a150227ac5e0b6cf0abc301685ba1f7f3ea6d34fe3937998773e9c83d2228f822457507908b52400d739bc58cade28f1ac73f8da422a7e4547f052831f91dfb0a13d2f736b6f24bb535fd04428743ba054e256ebbee43b75813895d3f136fc274770012aec00fba6233a70af22a41749bfb64dc10d97a4b47284c5c6f854aef26dc47c083a8ddf7d01292ad9605b67b318cffc8157dd23a7c40995c1aee0c678d5ace40ac5eb90817421f1137655e5aa7f886122dc43f83c6db7c8d36565361a2c3053d1c98941cbf4f1cd10070b73a6c7051d89e962708dc1e845e1f5476b2a1beeae8942c96fe41665e202080e8d6072a6956a97644216cf2d24b933d6eaf3baccd0846fdf8b10ba6f8fa25b536b6eb846514b29ba3a02f899be1f78210ddc8d97e91a1203558c4eedc650c41c34fe429f03dbd1655288a3fb23aae83de69e2e3d36abebe033b8b8660f810bf915beb3e9d3789c0b4f248a5ddb445acc951fb24cfe408f77c1be48108ed0844ded3545d27bff472569df1ddbaa23ca8292e03d5e4c0186b3d92f51eb63b11f3deef129566c472d296e60b9617c2f735c18a29609e98d445160ee015bc0b8122748efa72a2aadab4d17627406b236a76227a28eae12807946b8f6719359fb99fe293ea95a07826ac493dbc85783602409d58e4ed9b09127956837e287446ba4c35a5f4082d079e54fe3553b853c1740af0ced62f9dd98443010e8faa77a082d95e9ca0573c1d1a14429fb579199d43accaaf78652e07bae19a76499e483520d584668d20eb3292e219de7690a0f30b2fd2f80904b9650eaa69b711e86325ce1868e367bcebd93497c6814686fbc4a0f568e4ae7464bae87daf5a7be2b29b2ef06124ce7067673256154fb916c7de37c0ae5d94a6f4bfa3b49f54afe964c69a7d06c21f2df0d4fd4e1ffa4417b09e84a7efae80a45848aee9dde2774fc0043ab00aea3bafbc73805de6823b2400fc4dcb4346d01c72e2c2710900e7dfb85261e96ae0b822a98ecabfaf7c515e34506535bc9ee75678fd23391f3046c11eb62c2c99a5bf58ba6f6cd4d26ae4b7bc468f0159d98896a5adf81866c5fa8aeb088ecc3365a45eabab5841b5cd7dfd6fd602591b9034543c7b4fda397f7c7a503fe110daa01d16d0bf16ece64a5c9e7a5d1e41779e0b86dd4f087652f5e78f4e0f0f486d924aa3c37217d9bd5fd23c09e330773c445e00e1f376379509e8d83ba3b278095967663eafe78d4cbb3e751e776516500c9be4ee2aa1db7f7b0fa464fc7d2c40534d80ed8d8474848985e5ae5132930d9f6500e1d6fc96bdf90a89f2cd79b6df63ae0147465ddf007acf7ba1cbb6b815427b83512ffbe1abb708183e2ddc73f9cb49cd206208cc3e29283d2acd870f6eca11edd13c5347e5ee9bbb0aeed23d7d0dadf44e3d0c0ccd83ef626436eac897e7c28a942a663675085a138c92beac80eb9463cd966f5593aa9cafbe953fade2556b3ddaa47c29988c77aed118dce0eeeb76bf390143b949ade5118b3b0d2a6c5ccef9627deb741cbcf5c06ac0530be16d41c572755c043046f1d11aaf982be2f8750579ff354bcda176a6693f21a3321d2ad9754f8210ae7178169e7b59f82aa053c10129da5bf78b50e0d87666a351526f0c2c598cab15947823da0e3b6f092a7aa73439519cf0d02da9576121ef2b58fb768bb1ebc9bb34558538cf867fb915aa5a173ae00f54f716854724ebacfdae863a241e7bdd0f9b6b0eb8212536b51cba480f5d112227bcea6039728adefd586d0dae843c9de85f5347b944c12230afb7bb29d2d51356998a0c8732a19dc03e1aa416a6460d976a7230c6ebac610599e050a04972ebe76a7522b6df6bd4d9de72f5d0c81090572832d4a08e4576677859bf8b219327edf7d519a28f497b513337a998e20cb023b998179bb0dfba89510b7499c845490aa8c75d37bc7168da5a4af0958d7fc38a9976f8e6cc3ce86c196287433d498c60cb7f622083edfac6cc82b65ba75e110774ebe1550f3e30761a9b7159af9b8a43d1d3df23731aa6ce8f7f743cef041527c86e4cbd159cb481d7ebc052c06235d4a72403580ec272039e1baf3e895218ce2f47362061d4314013a79c2cff58bee10f8d92af4eac6679a5fe04ed5c787b4761eaa5667aeabc36d303ddf93bd69e0727c57032b2ef8c00eead390f6d74322d0c6d40a1a3e142e1ba4c661b877be19bf72a438f5b46264d8c5af2169fd6c1db4b66561b72524783075e31f6e3ab70febe822fc01ddfd3a695902e611c8719c927dee12f6dd0e994c1c55cc62d795b7d6fbc890b8fab021ae2779506edf9806f7175648e0fc690f09bdfde11bd147ed4928af88e85fdd71649d84d281eaccd0bac2aa8d2aa06ea4993075bf54edc73a79778c49f07771ad3d081b6330ca4e855e930bab100aa6329e4d64f829e63d7297c42f0398ba89981de79c45d6b0acb687bcedb526e00fe4ab30c0271e9fe38b0032cc5f6f28a3feabd6b535d571698fc768f3087b1e3f695b92baa257636a908f77815af5b7bce4f581774448f782828fc2691ce67d0ba16230a593875751fd788a9f993c86632ea5ebd9e7d2eb2398e7c5071e0e0351a16d6a0c21f4727d7696dd282ec6022300f25bacea26adf90862b95687453a350c03a69b09c57f076245d6c7b253e2573f2b922e16e6997c0d042e92394a1e79b077e2c9c0ceaac207d91cc02b5967e2c2d68e103d5730e1fcb78349fc897e60eddd8b6a379293c904479f60bf1813874fa42bc33e4f5e0d99cbff5f3a8a5b671bd8dd7fa9908910f404fd8a43108281f0708dd09c5be05cb61041ac7c6ff7bfec2e1ccdd83ea54742987a4316cbd7ba023c7ee71c9fab318ae899d1e58c772c66d91ba562472fb50cfafb6688c73c9f9d6578d40bb8c78422456636fa2ca1a2ef535b293bf066cad8ee7125186b3bbac49250af7d6d5a50e6d56111b49a17d88026df1d816ef1f12cb1b4019007ed47c2c7219003323713ada46cf9d8263a484496651dbca557afc93022b4093462d98e7248af4bb4105e65fbdb36c30ae90f1863c6fbca107488f6314764bb0385466e87fc9f4992b32a2487b04ec4266f0e1326827f57715018f033491ee64533c8a01aec249494d5303b4dc1a10be1afc66f2480dd58e0bcaff0459b4f88666fe851cb186b40acb113fdac0985cc6900f468b3efa71a23999af51fd58ae335bb907d5a05609e4029a25e46e1e4df6918ce26100b6eb2703fb4d68c288f742661956967e1175362570a7d3e31bef91a064f6394389477478116111b5c670cfce7f5deb0638668f678f5d760c73d8b9eb5add46deadc8539b143ace4a957d7ecddf4b19594f4d69307b08b51a2f454e3fe77764241f3c40f84516ec90af8d37207b9b928facbe172c6050c65eefcb55a9552acdee549146ee147dabb24fe5cde83ae1464928617aec6b7b57cd035ca124dd41cdddb72a19c0784bff609e85d59d199c030b325a362293f4901adf8240c8b4b5f3ba1f6cb933857a29f7dbd72258e5f73c14a404820454e37bdb27900630fe8845f87d832b8028c213f67256ce781cb5f8a4792b000a57fb6043f11f970a65541ad714ac3e0b85681424819743781977159fa3d174acd8293691bb0d0e47f0952b4e1d85449a09c7ff50c224231d12d1b503c5e0544706a38b0e1fe62f73fecfb6984e023d21fa02af183fd5d7503ed1e7e52b020c43a4bbdf312753498efce6f9ae4b456212bbcd0920f53168f6cb9104aa4f55cfe820ae954819fbc677a196af047d833d6af7cf55c3c8bba5f904ebc5e791fcbc8c6aabd9fefc7122450df7e4732967ed42eb69b950709ae7f6ce4a6af9ac33c9b5334cb98cad0fa28e5f4fd43ab1ca9737a72b5dcfd32048342c47371e187807040eaf5d638c2deb9e2ff1f10e90c195b4ad5d526efa563248e1485a89d2d152c9791ad629c10cde92b5ae34e13f518b2bb0b422b18775583e0148b933f103315f502747cf5f918e271c1f1801e0be28906550628244a2d203da95c63c262a8d9dd6b6f012ac49803f88e7bfd1cd19b6503ad8a53f1c141702ad990e57bff26d545d2031973ac6bc9ca22854ba69a5ad70991767027266a1059f6fd0a4656957392ed23b959d80f8a1480a7744756628ecd49c441b2468f86cf6d2cbf5a74f221034bae2f47839b4d8d47a60aaf99b5cfedc90a98f5b50d8503c2a7734f92a0aada5eec945afdef0f2235de7673a2102547ea30fe9bbb3cebb8bba3c6f7b0e849e653077b50dd9adca1bd5a7a8f8c96efdb6009bba6920b82057b2903b4f9a24d58e0c3673f66a326e9dc0a2c4dc9da46a5465e4d74abc664bd1b0b548b9c7b9f33d1ea38ada25b32cf2eaf413e4f9412c881a4729895bb181d3dd0db9fefa9a2d87bc624ce6c41242cc48bf94d23b364529c3a1fd97dd64193e25f7ac0921d3e1e8e99b7cb6482afff0e11bc71b6e7930159248e429467c4bd9586a3b2ceedc93e6150e5bd2d86d00ba79ab3c87fa7aa1fb44389f5f9265e64ae1066ed557905e7af4bbf0a405d50d96514bdb75a85c53f36edc8d6261d243db4af6bcf291b11cdf5935a80c717d527468f008ebb5b3f3118c573e11a434138f421ea8987f4633f1f732e6b03539aab9d8e40a6144744ac6d7c14a9dd6b0de50c2457b568bdf6fb9786f8ba5e1b1636c45ea82682b12f32ad9b2fa97f30f94c8d0f5536d35a1b1a791d6cb55b0ee1a3c1c4be7264a714a54e1077834c5c47604c30fe5091f4ee1e1fdb1de7954d4b9445fd3d6d97017c934f1b7c9d920f34edd549f15574973804e30ee9509f8a3dbe1c4d14e288c4e2af552ec3ffa9b4e0bb2f8d8e64604941af25e97fc7d62c9a5eb14a476b45e70fcef00b7fd17bb321c6e938968751040382f4db530cc4121b0772386931d8da4b20b69f9179a651ef548d4071c172195d0fb8f2bc270a99a2d1a20728fa702d6678e6a0231f99e3a6fc76fcc84d700b95c73a09408c767086f63cce70c8ab243494a29c4231fcd0bfbee9b0822026846503a2437485faeb675d91f612223f0027e85e99909de4c5ac10fbc2d7b48008924d95972192eee7525c0ba75d6a3027fe14391ba0d26d69df800918afa41ea1245febce21282b4cdb0c4f2ddc30184145a85480e269c26173aa777d4e1f0af7f213c383c92606154b9a5240177936eafc616ae23c369bf516fe087e72b8cd177bdeccd3becf6029aa25b63cf2564f91a2d24a7664f5d23503cb2638866f55b21d3e47ac2d98a37fa4c30ed516c230d732a745f28c6ee2a578dd2892fe32aa3eaf3d8f5925af4dddd1b59e6470342a5fc42e85ac162cf27c632c2ae58885ac3ffe90a4c6084d5477d5e02b6c1db7523628dd101dfb35b95d4d807ef7c4a222ef4a48a3c16a1355eb7b4a707b1a59b8a60241912cb231bc45cf6f2198daf671c9dcc3ed15f411dbf5d66535353d350b5e41cb2bdad809536a73d1202cb28f423c94e3187e742dc877b613cb46a5e5cc80b81aa1f294ba553917b764401258c91229f65458ef0be94dfc542865a758578c99ac2b5e6447aa9db9927dee428812a44bea7997aeae9aa36d0f800e66d247c3eb11b766d578a58f51cad6204a2d8468dd421f7c6ec6ce6acc1c7ec79bc88ca7a43a00431987485ac5224439f3698a2dad908e2105577e02280f9a418c656f51b28a3f86de7e4256347bd21b5bc44435cfcd20350a71f3cb58e4b938612aa75b1898a40ca35b5e01e2e8d36b8f1e8b1ccf5793b5cf1924fac745b8487b1f2d3bbdc7fa6a158fe6c868326fcb533c659b3cd6e2e1d1b2c03b7e3d31627ed7c2462be44331c94cd399a2899fa7b111aaddc34beb39fa233395e07dcd4d906c95b946409718a1803d0221edf6b80e14b5cd4936cd4494b15d5ea810e419cdcbebe8eb02daf1c423a0e3aa6468bde581fe29a00659e691858a522f6256c9173a93b6437360a3926d26e04187107d53a6a344b82b34a2b39fef35744b6188356fcb729651984b4071db2dfe2a5d8179c152b415b76c27e11ce19272ea3ee7cf0b1592ef9a299efb0602673ad97a6287cb3746fab9e7334d02e26cb2c612f4a65c5937f8be1a869226bab7ea80de47ba6be5bf9c72a9bb655c6be43dd5043d3aa1f7c4d2708f88f4f27c75d34748a18daa76871241d34e6bee7e3e9020c1a2d1b9f374da0bc1c2c202a2c98914067d3622d7d668fda7f3a0d5df1e9132934efe03570af7fcaad21edc4e2d4a48a10fbebb1ba3a04104e568471983439fa68f399da61ed8520f18c395fd5596a4b6c3bebc3b00ee5bc738d356603885351e84ded05834bd0665233258d6706bd8dbb06a5351e53dc9e85db04001853691ed097132dbbb22e9cc2bd50bc223846d94232c33e74b2fa90b516b2494a7bde29c0d6a45c7c9ad898807cda957853916e71aa393a0852fd09971069e23b3013c3c8a4e0543d0964b392fa8146505cfbe9399b5b4562a9122bf15c27ae17e1cc92da64c796a382a931203c850cd8597739700d01df14502161bcc83bec53007693a00259463bb1adbe90fce223d58edcbe2f264f026bac6bf856f178f1add729c7866a91a66347a6fdd93bd210af2c07fad2fbaf9992cbd0bd9ee259a3d7c72f9aa8b97b40f83f039b0209e64ef7e66fe8c8cdd9ca238e7286bc49db5e3705b0f102affba7eabd1532ae3e6090eff2e32e1daee10e71dd30b9c00bdd96d59cea1aa4f9c525b76905dd9014f6b4bd585403ac46b951911414e3e6bbd1d74079e32fded44682ad7c473cffdedb3f9a0f40f0a2c20fcce7c0899734d6edc2461158118a9225738f94c8d2ccfc055763d13711dabe1660b4aa04a773c7ed42268f237b0416eafe4f4d43b55ddf2c62d4ae86cb54d461a73c45b58a6eb01083610d1c6cc5726b38f9fdaee9e6768559c1d01d81c3e4919904f43a68f85358609e11992542e33545da2a3fe301c0b637f9b14db7f6e9681ee878935812f3d91f10dd2f022c887ee6c531710befca626d4eecf4cb37b9d001fff7c72b1420ea00a9427902237e99ab2b96d08112b6ce096b45d17d01f9f71a026ae636996047ee61d1de5103efac7810e99934cf0c6f321ef59259f4c742393752db3c6b2a002af378f07b82343a22a20abfb14afbb3b91f15c849bbffbfb101de7b18cfd28688f4c918e520403c71c7a354439a9d3cd3c311ca1f79a6608d16c583200ba365816c056783d5a64007eaf61829882092b4a653350182121e0c99e30d00b92b0fc3cb03faf885a743d5eb6e1fd3e17f3b24f078a8cf0e3352592b75885f8245f104dcb2253c19bb1e8f5fabb8177daa60278f090cdc02aea6ddf841f13a865883bfac6cfff1ef63d2df4dcc900ae8d81c4b83508918b02ca3fb10382de3a20097bcb3d403078b4920fc62b27dac83bdd3f4e78488514e93cfbd872f12efc03f09ca2ff0312f20107a68c59241375f20f480d768959bee1741ca8db4c4976a14ed8142502789510244555e0c673ca4ee92e0f374484f294af2d9c119dd7732dabbbc0bdca057006ff583d4e7b7045ec06fa56327e220d966b997097963f5e926a95da74b67442df4befe9c975c336a4943e9546fdb0a4f7b0fdfbf1fa660b020311c7d15c64054adf6cfdf7ab0561bed0563ecf5fef28d51498a7f80668b831f60428b19c47f86e81995abc908430cee9b112621f13d865f917af0a3f3d9da8094e8ec5477463ba4e44f753e07029fc3334ac27422971fa533b05aa3116716a6f8565a10810a7a2a6715e65e2da5ddc1b7fb2aa699b16c2a72eb548eaffc29d63f33aaa0102c087be58bcd0a452bc6e289c1361d6b212572345a16a4537fc43497c94ca3ecb11390f2318b4ac9082c7b4bb04a909db9fe61895ea5ea5abfa8f9e4a4172b7662710673bc79988586583e7f90f45915ec06619fb2621b9987097ff006adcacd58eb66a2db2e278b9a760cb0de66172b95bea93e7546acbbdbe3e9c19f0a03b9875c0267d44be03719c8e1d45916ae3c8b373af5a45cca30bd780871d74359c5ec58a277710f45c09a919503e9180e22eb20668c12778a9d74d9acae8940d860612330fbe02d5d85b1f93ba2da0c175c0b6bab0fca21de5131b255031a18caa495cedc2cd516a78265e206ac50c6aa5fd0febd784c530c72d1ff87378f65343bf492aa00c5a1eb3bc583dd2987a7179386faf957a3db615eef90e7e73bec68beaaea58911678c9a6fe99fbd2d494e17afd0887c3c99cda54a1641a098fcf2da51460c60d42d48de8b4be43eb3831e7dd837a794cfbcdac527a53b24bcac35376b3a27bceeddb34ab3f3c1476a02f27402f652a43807693676d7294bdc63fed9da4fc0244d370b624b5399bcb9e2d324c9198215384480f2a239497235c4ca9b5f5b3fb8ecac21f1aa098d4faf0ec9699e4e0631e3b9365b9f5a6037703f90236b0de559a774c6fa543c14c3bd95d7e84e5fa09745b50821fe726dc205118b9f04340dad143ac857d32e7e23035187551082e5c8460584405d4ebd7544d4df4eaac98757266f01bded059c0035679456e25eb4921923dfb9da1e06a7c3c290e1bcfbd26b6df776f26deb9606375564313924ee44aab492635d2b6d54178d67e9a01ba6401978c99c0c75c369285a2a3af6ce383981f3e8c6711d0658f4795e27f98423c5e51df91529dff22e614d661851ede3caf51f25550a865255f51f5cdf4647e9857e808c0ec19e11290a09f4e1372e08c868d943ff77b81eb3aebdc74a26fdd7e796b453cbe4ead8f4950fa86032ab1e4372318a80d4991ec0a84645bcb7b4cf80d7312ac239727b4c0e73aa8fba78e013399f8cff52be948f7a4f3373d0a9e8d8757414de142349a87ef54e11bbb6a93d9c57e260c3473e39884e5b1406e974264c08385caabb93c7c3b0f7060f2d66dab4289d40995e2be60aeb78b7726ccdded6dd9c764ef76cbe742824d0e191590a6901dc2bef0d1a8689f151d3a7b09a9e92dd37242dd705f398b57379dffa48f85f90a257e790953f5b3b08549d43757dfa0f25afffbc72f84ee6a0afbfcd660b50badcfe15d49e718429748402c52e24cd0270dfe2b2de515fdf2a63ce4048909ba6a3ac851904d30af9966ced5f6e0e9ba023c584439ee0c859b639bf4e4b852dbaac1afa75293963fe4e19a3b7c3c0c237ddfb29340afd2cfabc7aa60ebb5c25538297c93f243fc0b5987d021a09e091f255f51e6b49b7b437b29f2a4907b4750b873725fe95f10964c6e674f21ed9f5a9a10e6e5fdef150e31c3c0df9603212a172180b1b69cbfc14ff336a8155e2360579775cf2d1e095e55d055bda1357b01c93db189e0591fd821b740d5f5cd9c4408418c74795628c1095476f9edfd5b3a3e7c87301d424c62eeb80bc439395dc3e609921c3ed4e12346d112b3ca99cb2f02413ff878dc7ed3ef102829db22676e17e43375f12f7a85e949b27889ef7d2fd26c60144c9769a6fdb270ef1ed877e58965c95699e5ebdb65b0e5bed01179073c57dc0a19735421d45356b227dfbcdcb01962a8bd4bfa090990047fbb966780caa163ca576ff0384a75b62e00a0e06e46fbad5d45ad5e875b3939ab638671922d2f45cb1a4589af7e2aea30f662c9f7bf3b1ba3c377d7e08e75763af4171371a72d7f2183e3883e98b2189e7abba2390bad7b5ba43138d07ea09819490ec92f083cccb7ae62889a4491480365f51e5d787d03cd71082de8298b48d61bf8dbde2ee198fa0fe1a5635baeb70e83680bbba41d1aa290f1256ff5a33a082e6800defd8818bf421c24be8dc670ece0e7301b91ab8d5bda2972a1fd476a53a00e09fe752667e510a2868ec09a5e89c2d9e7176ea5906f94838eebb37035d0639d47c534b090349d0c52d3c05608cd0b7de80438de935ce75e9085dc4a10dc630190151a216d8baf0d1bbf73bdc9866137795c957d87b5125","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"06b93171d189cc77504162ccf4608c3e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
