<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>PhysicsBuddy</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #F46C36;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #F46C36;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #00818F;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">PhysicsBuddy</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Sign in " />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c9e8d15fa39ba04d42625200ded220b5176c38cf46f7833f2899a420f5bdbf28c1f0b77829d06eefd851388dee04233e61dfd8393638f0b34bdb990e56877a219ee1d97179518ad7969065db8523ec9297ba39550943400e3556f322e466cb2b47e427db4528e7657110b89873adc110f9139b380b94a2250d5e5194e1220578f08f80829110cb1d8b0a3f4267e8868857836ac58a918fd87a155ab2fa420ae3e26a29e33d8d799be76d5cee5170caca23e7f199c5a6d7ccb236ff7966715f97109624970f7d45dd85705baee52b70c481e44f9380d83fc0aaab455262276e56c9233ac5aef21dfae8edbe77cf7991cf82c2676a828fdf98f4c192ddcd3af727262fcecb0f9312559c59b1833558330f1f7758da4d11efb478dda76df282a481d3069b28e0c04083d4d60d78ba1ee3616e07d72b0d7aa38a7e39367faf7f7395bca48377c6eaad72c86ea7b4b6ac1d17c63e69545ddc98b74827c09a811eacf112a887b8e905bb47d2b21e5d7744194044105eb16afdada318672c7fbf049a5cf136776630f94a31b660a0cc0b0c29cf6a652c6f9cdc8aa92d2db8e84fcdb5233e688897431afc50c6bbaf285fea3400d21b182083bfff48820402045bd35f49ee938594269cc09f8088a52512d35839952782b739c05f259842b9f96af124efd734f72a0ad01816fc38f7a81207c5ec10540044e8373e7c451f863370d6bca658c35fb651fa5ad875e36b0f80392356eba19558bc9452d5e1ac67339cbd3781332d564c368958f25de98aee636d050325f3d2b05dbd8a6c7b5b25442516f6f691763d70987c95e123a229431ecd0dd5664cbd805de961e37b40aaaaf3592741faf535902b36d23716723af5d8e0e6ba30a0b5d2f717d652a1f737bfac308cf421a5ebef3615c155996701a3c7c9b87ca6b6c8a8d16f7cfc77eff19f29dcaf374fd85fd749088e642d0cc189cee0c2f30d40640e7e730cf6ebc2708cfdb4d272a14f60dc1871507139abff8b9b04b8eb63ff249ba593feeb295af79e33df41e3f6ed622a53af8c9d6462905de1e375546dc1e628ceddb2df324f07f8a33b04150b5c6bc9f78358d0795d2911ca657e4502ea8605e8378326c6ae01cac0540df28e1e0966d159ed06bb009c81023080d77eebaede841362c0b63bddb6558209695efc663aa91e9242a88b847462defdf5dbf0715f1b5ebbfbdaed03b4fd099f052aa63c5cb59efba2d827a89e50fe0a00cb44e1d454c08db3f4f717c86216bf6882524ec706758136d24f0ffed6d00af21146fda746979164138dc532113444eec0ce0519cb35bc732866b9f3c5f2b141a09c7fed7017fa55df613b554d5de131d8890ff03907db0c19b941ba28a7c3c4dba8e11e31151fc2b380be377acd8d1bf1b02773fab7ec28d48aa448087dd47d914aadca8b118ad7fbabe735a69e5c8bd080e5c4278e04d52557785260e4fd6b35f00f2db3cdeb84b443583a5dc3352490ee9993aebc6f5050111fe487efcef21c94eddc6a70f4a7ea8c7f4f3fda70a3176a216c96454cc8dae006a954bda8a0f69e964d5f824229c8af7aac4130f60d84ffaf6377575a387bdff0eca1c725db085ddeffc955b22d885d3ed7a5a63a4dade0fe4fb87a62122eab3d70c43946d1e9bb7bc2c0a5761f94b4e21023db85a9e1c8dae8aff2cad8c078332c7ece64044abbafe78912dce6aa50bc92779f18ed6109f387695c5e10dd6ac1c722a8b42f49450221759cf9200d136ecc645f1c5225694ccbce9700a9a331a516abd44e52dc77ad07113eaf176f9469dedd4fc5a4321565dec39e98f63fc74b45722752625dda6d14277febfd93385e574fbde4ec9bbe4bd920ea87d1880f90c6227178753acedd48f87f97c859f0cdebcb461aacc36c1fb2ad18250a8417b2f92595882eff262591b9b42b3a3841c5589ae93d932ace8f1d76a57ab829b0dc6de31f58395eadb0d6504085c33bf66d4890cf55d59de7e6cb8954d831af860faa3214a8c6e6078311b16311f9c9edf50de1123ac7d25e8b1432db73cf43e24ac543f95a08c51e1df7dcd6770f4f8152a0f72428d569b52fb002c20b18ff987a5869175020d5fa68665de23d2e3ad8d28cecb2e3ccd57fb629bbad5bc2ad6798d755a94046dfb08b7b02cddee103edf21238021468acb61084ae97814ff56fe3e92caf6286ddad21bbe1e048425efd94c9d2b5ff714a6623d179d6604b9fd793d4dde4567c0312fa64d63ebef406089ebf012049f16be8c31da867dc2fbd18589e421d258d1f0bf851e792c27ca9361f39d1b61071e4776480e852e1eb83a06c0c2a5bb3d90771993bfc6025b6459e8da0da86274c186367d6067366645265dba97a8242639965cdf24249e526b33c73d55d4d5eff82b74b4e917d750ba5af85343ee55d58dae757a3704c6084e4cf5b06b3e454aadc51f8cf6f3d22b22fdea79b6bc87bf6a9e160d1edeeadb4638ede609ba313a9bcc9dddc424fdb236e2fd6f7158ecba0cc696031143bb1a450c4056004e2dcd740ed8ec9778ff67510a3c76d38f132b7c5e980819abd88d36ceca950290e05d16a57c16dbf3a6c7926e541ac8dae5352de8a4faa714f62fe336f5936d8ef410d7cffe6d3acaf81c35fada6af9417ae9acdf27ad044e6b472665217c9ee647e6b780e629fa55ea783ae8cce2af047d737501a4e226608c91862cc64a6e9119b69ce72f99f3f71d2c07f7884ae21b0ee8bdecc8f7aa85e8aacc68a08365f0284b67cbe6f3c6d378b002697dda213871815f9bce39a89f30fc5f5103fb4342d85afe57dc01f63d59aa72f9e8f21c2cfe6a0ec4fe43156839f07ff79311e54b1d90559d0297109e9166ed2e64ce30772bc2355100f4803cec1a3d6ff6cac24bb5b8e3b2d0442a10f881053b78f26dcd7e5a37079ce4f11547f66c5d6d6342a138479b3f15d88edd42362215739d30dc1a3fa0e85ffc5ff47b0ae4f002c2e7f197589f79c4240b1e682e97a56c96fd23d7dc20c485448fb8b8f00556fb6e5b0cc961ebf4727775a3c56e73b4e62c136cc82354eebd4a048435774c6a8db66d8ae163c8a2f884d71f0f72813b84c6b03a6dcdce212b649a6c75b2434b0130c340d34017508d3b0f9eda997530b1d4696171d8cd7e173624bb8308198febdb62bcb45aae55ba0258198d8bfe57d91df75718a963deb7332507618963780dfbd2d35bc1edb2dd993c49742318da3895e0f86782e6a8bfb6743fd0ecd2dcef56bef860043bc59c8148e514188b67aa5e454dc3d1644b88056a00eb2c8c3c76e1ddfa39323edb69cd3e74bcdeca6e9c993dca2c5ec54474388a49574ce5c0880deef734f6ff326973a3c9a1a7b37a3ff8614ed3a0304d9afbcc4e74d5416b1064fdb622b072c27848a01bdcf65ef5ebacd8333a449e054cb5cd9f6e21b2449c6bc5b4e69a3fdd42a8a36363309f8271b9ac83ef9bf763732786fe391e4a6b9751f0ad40d1eb87556348b9311c058cb67481682ffa049bd4ba2ca2bded0aff77c23a227f7ecb3921f87680fd2e6836ea0ff97634e42b0113170099f6d8eb5390b69130850599c20687f34edb7cf965192e779a17229f7653a0f6e7f36beb29c66446ff8e39b5046be690873328635965a99d8e6089f796291bf298e7af67efa9431e1639aa8a85e72123b2466d4052550727abe9eed045e3622692208fa228f7f0210d13fe6231bbfaaaae3f9a21d3c5408c3377c49d128960106c57a270c51915864b9ea2c8bfad1af2d3f8ed841a2b3fe85738cf8ab2391dce56b40fccfee2e69dae2ff5f4f4a12528acd0b557d71d62ebc0b8d638cd1189ab3fa32332a259eb6fc8f1255d6a9f5e84f9bf92ec7a5ddd3d825814f10ab77961aa17e085387c7a2a66f3ce0678a878f207812b1a5b3db7974082c10b52223ece55d39e079d9e52e85bd7e35fb37d515b1159c9f944ed50d12baa14c73cc632bff6d74a1d63f62ba0745299b380e18a0af41a1f11771134893e5ba36ab77e57b499528ea15f0c0a59ce4c5c500355fa57e452eee35ce01bc082da7f7b2b02f8d8d5e697a2a6aabeeee019ac48d038374ae9b5f07d52d68b6ff19e78e2d22a31a9bbe8a0436a319e437cc20a1bf83f799ce2d8cbb94d3b87c20af431ff12c654a83f1382a1dbcc9c9b69e4573e0dd374aff422a42831f2d065a8347ab5e4ed8e43337a8f8a5de794c03b1158ba81a403bdd0cdb03e75d2c62766912e894ac8a7e6168400f134864c30dca99e1b91547b448e17ba53512be1d0e748cb71e84bf268b2758aac3d469a044d1135ed640dbe9b3d08c75c6de8eb2a5d7ae1e307aae1bf80e1e1e5f398a59264a8ae505a84c5c33a866a3ee1f7fcbeb5813e5fb66b5a63a09d3fbe393f72dff87ad51b59f4805e362a717d6b8d077dc4679b3a4622c4e774e16933160949a9b540d4633868645795e6829b8c2a01f2330029c82b521df91117bb9cea89d9f22d99e0aba2baaebdb9648cc2a1cde93ced195bb6661a59d798827bc022e8fb078dd20de7973c4a49dab6628d6f659e6655b6a2fb5baf474171fc828b3c498b26238a869904f1824d8515f0ba30e72262076c03b5cb748b925d606e05f6e0d7a9059ce32d8d58dead128bf05c1ede749ae740129e18b35286e12ab4fe253222f17fda502378bda38e4d398cb4e94066a5f749dc99185d16da37ae1b7e441a403858b3bdfa88e8b3232b3cf95be1cd43b0e2a6ea0d075e62ce4a8487c792f49bf8a8973f20bd1107725fb82bcdebbf0d80674dc75df72cb0c78180a06548020051d797361c8c37ecfbe3573cae8edc918eeb122e075001a29ce53e7d14980451d3a7169c8ac90b1abcb11aa58756fd705993cb0b23bc6eaa68f3ec9f79904bbbd8d6b0edc79385d3a76b86c1b41cb3470f1a0b02561f07b03b60b7bcd403fd8306e3099db1f2aedd69e1a61fa375d3be9ec85a9d092f7b8e3960d26dfdb62238db793934dcb2fd103628cdb75b3943b95d2f4642f7162d9c6de5537f6db0efe0e7ac6adfbb1a1b6eb79f16cf746cec829176772f856a8d4cd65d5ec1ee7c0551a441eefac3ea60377bc6d5824efba5e745a61c49ad7d2ff027f59f1b1e9b7d87705509bc1399ab0970226f67f030d10be904564e618549f64f520c7fa2e1644e1997a39be1002e400cd288bbb9f8d9ab201235f1482762e3de3e6c3207a1a798e1007035b2bcf4649ec8bbfef1e29e225b4ce4d28fe219a7bbc1dfe518164c2771adb6f913c6dda842cca81597c7b160614d29a01fa6037bfc850a2194caf11515267fc56ea71a25267210636678a9762b255f8583f7826d2e7d765244e4744e9c56d9c941cf7dd97aaa4f64961887d7d4bf80076bf0c88bbfbdf701a04536e0276406e569b6196e9353d29c39fb82b7db6ef93a9b6e01e23067d8c99f8c3f5c3134a5b3f8f3ce53d3c6d02adc11f80a14a2f7ed1aebba25a3b5d5e5a4d0126908713f2e89905733585c57e3f423a4af0f7fa82d7c759283fa1150e910db9862c9b19cd5eb8d4ed85ac830ceee4eb68b3a490446461c3dec41183a8f6cfb5ae96d9bc3342d4f27afb40b00e6d09c09a9b34c02d024a35525b63e26909303cab6ccb0f0b6c00cc5b6cb80492be0690143a9c31d2737846972a58cf3b30653a012b4be8d9d392efe5889e2eae86ce120a4056c8c1f4d27cde71209e79d844c10201d8358158a5707dd09c7f7a29da14b9842abb9decc9874cf75e5d92411c095186d05a508b3295631daf06f5731883c6b2c5e28da27bb3bec647791e4c06b0b028b60d4d9ea19ab987b0e6f2e8dca8b969818d4d77ed39de5652c5aba2c91627f574130b44f396121a387248a10e770a308e3142e6ee9f51539d11ed2f5b76ebb2141cb7d86fc9031472bd4780fd575bd08495cd5eb9c46255f79b134153f1ce5b6693eb4b02b2b3a72f022e5bd6e2ba4a3e49b2e83bd9be8fb5f34196c88be2d4e892d15cfda6246a0f300f9ccf99e248165b67337a43fee0182cbe60c83779baf8cecf11fc0ee383cd7e287fbbf31cfdc76996040accb99a325f8a5b89b198dcb893c86dc6d67b3b0c21e5f4b221d5767ba8844a4a81e7cbe21268eb9a5976e44e3ca0b3c72194cbdad8bda91429566fce5a64c96ed7b78108a3a161611a3d7c9b75e6161348380e8dc7239fc101dc6323508c1619eafe18b0f3a317bfec19974406dfe8fa4aa776858b8fa5d743035c98a31f8fc2498250b07229a0ae1bdd0e523859a2893c89b0a7209b45a9311dcd5b7abe99c6bb49f0d5a8f6da762e1edd2e3bbf1666757708608550d62ab8448eea3d7f3aab5b0aa62185e81a94e33af0440e2e5bed8cab4f60d3c716157dffbb56b62d0ed892ab7f7bec60e139bcaaf9add9f3241129e323e337dfce25f471bd1009d33305e9e41c36c3fcf54163f95274018f74f52fc89009d32391e7329a1f24594f55d21d4789d51c126bc26d2d28a7875afc75d3f06a4e8a5fe072469d0593223c53ad4f0ea9314f16cb6b43b1b1b3ccaf999a908cb696833d71c39b1b7102ae6ce29877536b8fa1106da0425dbb541606ebf966b9c9ee95db78c704c831627c18a0f9d2430fd4cf14bf15f09743f2383f1c3ec433314c1d9e5589391695bd179c5b3a92f1176a20ca0b0e85f9d4ce5785811943236b2cd546055286a28b973a0a96eec54d12ea78b8359a181346ae9d23add35a5e179b7300b5cd7870d169707c35c3fb56d927366a52bb94354f2738871fd586db8da4450312bd587a9dc1294b064905656a582cd419adcbbf28d0c69330178de3ca04797286f717f74669e4266268ad664bdab90908f34c261cc44df2fee3cc287a3387b6dce872876342f5ca4c236e4aa12c89a7ea0a822dd5b4d5051bb981312f545a6d3a7dab37b2659810257e7e3b20cd386a26335d3b07780c5aca221fa7b31b767603916e525e9ab1e84fca594babbad6194cce01c8824ddff2f0413e7d2bf048b9381e6495f3d1292b7de881b587fa6b2ced2d886d74c4eb1ee7adbd76a881fcb4dc848055251eee631e355c1fce5f87754cf27e0a95502767add5a006e4a019e2c3adb1a6cdaf7a9ee3a01d0d8912cecca4b9f886ce2b0000d36f1e956f3ba785585d4070e6428cc5dc1cb903090728f321552b895043019f8942d838a81b2e9ded4c49c1519abe57b73063626bfb3bad00ad5f472bd920b9e03b97db75d04e1462c15983940502f9581af56ec9d7a6df02fbfe391606d1c72ea77e91dfbbcb7ae6c46532f277240f7d0b2cd91eb034b31ec4f5b13342de130b5e378d32d2d855b5e1ff1ceda0f2864b1d914806fc909fe41e68e58a198b7d00365ad16897e3ebc221004ad0b0e5dce74ff945d890cee23ad5e0ec06abce671ce0ed532d38687e186640f531ffc7229a9b50aab3b0aa2a96647ff3b80cee73fbd66c7f6fb43981f013b98ab11e5d64ef4fbb85af0a30bf7baa1a4662ea77cd40a8001b6352c4619dc9b72fc72b4314d11712ad378ce3be7f31003eebaf56ff49931d7c91271381da9c97131a18e9d7b82b0259529e4c8c228e7d5e3e56db7ae0376221a17a9cf4751750d8b253bed34b6fc00951709cd929858137e4864df5d2a81b30f06a52b8b8745f95830e6c2fc81dec7294e344fdc671d01e37320a740397d51fa9bd8b7b13588b06c66513642817cca0204bd435b186bc0899dc3d6ab19e7f087fe544ae38038542b2cae10ddd993069d70b686a4d4cb336aa243899b20dec11068e7ca8ea648f305fc3c5e4d5a9fa7d5c8cc5ccd4286f9739b65a1a1de11e0b8ccaaaae138d645deebe1c3290a80afaf0d933d8ce34d4edff17b8aca3859d9b8e254cebb6bff4f8ac58e0c44f49263e3b05b5f7084e6cc7278942b9c103c0895d1f89f92b610e314956361eb5ebbc419466bf740250cec0cb9e0f74d2160754dd13f04fd3ca909e2093b99267ed0ab455cc514b31f068fc00efdec162a6fdae3ce5181f8e8c65eda02bc38fe6fefe56e42f31d5ccfcfde7b2086099806984cb874597a82b8a5e3b4537c11bf09315e4eb3730a7d70ed156d78321208290699d18ef9028a7d0b44d15e7110593904bacd359926e726cae34afd58a456a03a65cebeb7025bd47afa8c52ce717f2182f737194d9df33705c999cbd3245b4a0492bc86f30ded5f47c7185e57d9e4a27e98614cfb3c99e1b7033542d999612070d4be60464271aed747768ea852fad7fdf5505c64e3da7b39501b8359058a14741de269fae7557b897200f4be5d8151853c990be05a6dd3fcd9c5ce966a4e196a5437a37a245fa5bc45d3ac1b177bf998d163d786435b5847e35234215448edba45f0fd5728e1f6936b280612c252fb19cf9ebe64346fe4b31d1d2a86424ec16ec5aeebc39483a36946043dbb1b06ec4c6916fce3834869af098ce1ca9cb98de19d7ae95a26e475483044a52ad31dc08a37a62490cc3781f2023cdd5fb170136840affda16586929c5b71e8139a0f3551f3a6a337cf4a62c6af806f1b9eb1a61e485cf6292667960146b7dfb5840258a0c25ed53000fa32ad8f829d43fcff9c047ee51852ee686ebb707c4e20b440d3dc7df5b2b2819f1771ac27bb7ae8b095ffb1dbd075443d83b26b9d1ce4b3ee44d509536291acefa61630ae79693c93dec3dc7a742e48c613ae288695c09c1affe5c2dd8abd3a503ddcf2dec42419f296ed4d21279a0e73a0927c0b1883e0e872411219b90f7e73b1fa2c024609612f956a12818ac67dc86e60f2d66c09c967a5b9cccd3347a2ac03e14262503a27a762b4b920fe4f14b105a93e03cde136067ab37ee422f4980cdf46b73a6172c25feb9305ea4aa950c95d2cf8c8284952c42fa7a03b6a1dac59a610e701e8e3fabbbe074005dd050d5da1f7732003cf6e93438eddf357733781a8d32576e61f478a495f06cfdd1b1cf53cdf965f21c971dda6d1848ca385091d1c2de0290f668f5957dfc0f2bd1dbc6c0e8707f43db9aaea925ce67bc4ef342e8ef9210b19ff62e6248b894216eea6d59344ed2d2f6a6834373463b5ce26652b1a80e304da6ab8acd1b560c4d99cc5adcfb7dd0a7e41a4a4357e8a17813dc1d89a0dc14e8256d164ff25e621ea65f90580dbb023d8b145608760496a6cf9385a3be07d5e68438f4c5af15becaaa4b556fbc93d0521005b11cd5309794ad3a7061371505f6a6dbac7abf069a944db051dd777a9de803e9051f2bb4040ae5af9209abef75fd440e23075d91f3f36e1c1ab082743987da2e83273e629a3ad534a8a2d0dca20f18176cb6935e2ea83d47b3c19618947236b745be24c3a20f2524e2ab60af523449a3215d392471c6649454dd7bf6398b9f73e22d016797574b51323b60fc7e48c1cebec9329b6689f5c4488b0c2930851b9f6c6f323b0f6ec93081aa592add8e8854042988d338a695cc80aef05ed30cd8686ba2ff28bdd61d0e6e340e41255ad4c0d062da48506db6d753839095fb9d1985b2bbc5d88dfcb59416e0f2026ebdc8f008d0261bd1c7b0d1ecbc16effccb0dadcfe7f3fa06f7af28c0a0e1aec461f75aeb620254c85549d99db82e62eca673c91e10777e8dff97c90404b3dac331b738071c0df467e99b0c035dbe9ca1f3cc3f9c6b701ff79f34fb3dd84c6c79f1403add275e3687e7afa988e8885cc2a2e03c84268bdc4aa82f4f1fa28b91658eb239b3628308168382fda7245b74ea4e4afcd5ea3c17331a892dc13dd8d4b8c4ea265637e7ec8cd7259f941ae83a058272b530d8e6fe0da12b329e9ea482a2e5eedb50c98fc71ddbe57644c91a507a65ab33e15911e857055184f083a35c7f687fffddbadc0a91c5eb31d4819e64912bb101262d36b22f1e95bec2f6ccc63d42886dfb154d3d5541897480eee62ae36c79c07a3690ca312941ce9c520a8786bcacc2c67da4e21b3a8b4c8bfbd367b8ff84622f68ecf882f6bb6aa3a528f173901971c6b99fe77fea942a2a0f185803ce900bba65568ce8debbbd6a02d0d818c5cd32cd13036f01a2369b6eb0aa94b701dc32370fdc268968eedaf36c56dae022d7e0b77d99e1bdd6c80b2bc4f2131467d1ec951587fa988f6e4f67cb8a32dc1dfe79f905a12869917b56e2b743696f5a685f1c0b3985945ee13a0ba0194a1bb4fbaec337d8a5cbe90011ad150cee25636385fb8eaf0e0c0e659a1f290d18ee0aa5f3814bb5abf23c5da268f0d1f5268f7eb3b4fc14a139510cba2654bb57dd530582b409b6e5165ea7ca435f7b2aae2ad15065225a592fb1dae04a24fcffdf527c7ab347f0fdabb526a9c6ebe1ca1a5b63792b8d4638288f6a63406cee47311d4a4b6c0209f1a52d5795421e2ff9b19064e4d94ee6b989ef6cdbcd723e5f48cb0447d4b3a7a24691dd3b5d58a300d5051e3c65acc90e8e51987ff1094278ecc01c7577057d08297c1933a9aa38594ff2e2555373d9d4657b744934e197fe6e68fdc9b3cc282aa56013ed59cb6304befa5165576678d42fa91cc88a6d7c8f4e7df34802506a24a0b6dd93a2fa88d1b34e43b6dc6e1b412ebf78e2bd5a55d5129217b7acf6551cb9861a72427216b8bfa1eab5b0b43391eb30787306fe41f967256a960501ffedd3c25960578db86c1b74c478edb3da47ae56e90250161e82d18949e146f6b90f174dbd8176d1a391ea33004e1054a3f112db2a2c7caf129a313ec95cc7d86edc66ef2ab9c2ba083257cad100de5a0539e9dccccfc6435213420811d0ba64da6d7bdb5279200052fdb45a63e0ecb09412830a069db865419c1b5d52ed01f6685e1dec5785eb1238c0fd88627037f368456d6abccf58dcb3881af9db9b5c36059dbacae36330be0362749b3b08c638d503dd13c3d42869dca090ec54c85c36ea304ad6dd4e57fb1d8131adea749fc759fb880a4f84fe54e7b9472650860fbcca320d7c8b3e0e425ff1764a3dfb2b4bff62d34522a1ba1a6e969f8bfc352a86d27fad00b1bae9b8a1263394f548faeb63010c97ab2b14d7778757f8861934bfddb97833b8235a008bfad05792c737594e24d6307c1393043f6e4ae96f1d309aa888c9001e15e92de400edea05b0dea2ea82396f40c85215587006a6260414acb537f50cfc1aa8c71db2f9862a1b96bf0ae1b652a5f366dfa4c6f2d068e0d80641f91ce05b1bd3a0a5c37d4b04e22d3db2ddd4344b45d8e2830de41dedcabe0f2517aa4145a9f362da5e797b61afa16dde9ea01e576a217db603d7b87cbb25f708169366cffae50eb030cfe1aa366430e6ec5b5f7ff49d5cd608bd840cc1447c633695f464bbcbcf646fec16ce7b3cd9f22adcbcf68add34cc30ef758ef17aaaeb5b7d3f0a019f1964abb47e58152ac91ba50dfbbb6c7c6be170b8982742c5a161e5926d639489c2e519afbf988174d923a6b55ff778943970a1e14a9b1c59a5603f1608cc3c7bb2d72efb7ea6a676f850196633977a704f4b0feab8523d6af127f3a8820087179bae177e14c50503e274b69ed9d0d6f2107a467786950f1c0dd6d34b6395315a143465ba3da152c0b9d635d677382760d0784df7d2a7bd3c7ddedf55aae5310de54da125445390e8c07f4fdfd8094fd11a48c366c944785c128b7e86d48408fa3ea4a968bc74634608ae8d254b27e16f4c4d6da760fd9ad7ffe53f3792b31481bc0a7bd26c4705ff4c326bf8c2eec5e5b4c8c4d9d1c12eb9f66e008abb6173ef3415e0c8ee9559c0134e2ff4490b6ce6a67e9d6431142c2ea18d0415fa395cba9efd2835016af9e0ae35018d4db8fe2116171d1f7836f3687b988aec2a75e498675a192b29c23453642820dff5815718aff2b6595422800dcddc9fc383f0c0303d73b30386768ceddb65250b3adb56dfa1950b3d2ce4d5628b80f6abd3d867602ff98bcfa7247c98ee5df252ba5d8d7abab43cf2c0d7e5efaf635f4e49728815a0af6b0c19c852b58e24d3398488350de1f59fbbc5485a4a20da17d7d17815a90043ebf2f5eb59d011660f4f2ad4a23401beefa599c31bd333b4cc1d4a22b53e51c3a1cead9ef8959a1a183c1407b322edbe754333c153b94c16728ac295acc5dae49ad129d11a87567e085fc74e1a5b3edbdb556ddffd0065cd12fbee7d359fd546c0a27b3814d930f046f489802d4a9d3f73951ee9bae420596ef9e56bb887e7619af483dd79f72287ffdd0cb398658703341c0faee9058c19ee874ff8a6e9b46a984312091767ac542659ed5b84b830b03c4dc75f63bf003dce30cab34084dad42b28bf854a937a36668ad7e9da69dbed0e45329c33dc3809cf0ff3987c2f23a95fbd6007dfbb4db13e7ef235397d1b5211e161766ce8ee7616a26dcdb82717fda763347617d3c0d4984d5654071b048c76c67610aef7dc05ce2fb7c3643df25abdc5cc1bab2995bd0c69348a57575f811a170cd77b24f78d4bdc3a9f5913aec267c7485f531a80502ecb25a018d3b37256aaf17828159b10e0ff9051a362c21f360d81cf60c29c8803c5860942244a004386390fbe68fde72553154d6e84b413bc4173e294771787b91b36b1e067705475d2baa495e970e02d6479b2a1ba8372fdae420924dbcce710a6734854a509a71f1d2d2b140164992870d2d535ab69414bb264bbd4b1cfe9dd2f1361428f013e879ccaf3f42260fcce8c32a4c10c39155f746ee5e0721c6d5ec97d9c07c4e2a59206101fbc4dd399380cb2a98ac7383fe3ed61f9fe5ec6fcfd3f55dca0f32cbcccfe5cf87d0c74e57846c13cbd9a58e959c95a8900180012e16da277c9cd63835a7ecec96be7168f939f9d1c89c62833c590162a6ef3bdc4fb3b7fbfa6901847e8858c778025e9ae6c94ac40fab6bf883cc11ffea8dc2aa9871c4f0e17cc9031b20685b7670377355bf3d6cdd87693b9e6dbb984d54ebaa33f573356a59d9a9a42c4360556df71816659454371b261d95fd993f52d6fa8484ff2e41f42884a100ee336ff964ae9cd63ebfd21ecfb5b2e3247b24dec2a1daf7d5c8f4cbaea30fb6d07f32ffc7424e49b0398a5a7790d90ec7ddb6d3b06bb13d65eb9984cc31600d523b6b8eccd56abb61e1d165f54521c66ea37b6b8b025f8a337259480a4089ca31d9dcf2ea62dcd938b076f650778f063a08b8d374015a2ad51cedd716def201f37294f9e3aa30cf6bf15b8a62e9cac22623a17c000851fb6a575ca425d9318c2de2d17f1c6a00143ef0e6b2868017bf3e36e685cb49cb3b91bfbfbf1a482d9dfce96206fa12e525a0da43334097486e064dd7d2d916cb059e5b61c7471866b9d256482e30d1691557e610a118dcb8e1f85f29f17965e43744f10862436bb6fa869e846e414ebffc0f59bce0f1e1c8f15461fa553041c71b213e2b1acffdd7327740388d0c205080aef7509635a29adbeba938a5eff44e4d332070206dcb5413546d31bb09742aa418acb58a37f84fd187c2e89dc5b87e8629bc21dfc5f26f00b7797a5cfd76422c794a58423a924148eb636220862201f839ea1af802bed1d9f15a2d04ac01481803c50ceec52c7382127324df20e12d384f97708ffc3219f83764265e6e67eb4dbb5191fe405db76200d27bf28bdc0ce27da6d6b62ffa08bd7bdabf159bfd4b535a5f0fdf4c9dce4c041564297ba538aed0c70e4bfdf13e3986c0c09bc715101e17ba45df663d88cbbef6925ebfb43f76eeb708480cae101cda3bf64edc84a3caa1df4de202e46e22113adc2c2167f21ae721724be5089ed41c915854e903401ded506e6fb4cd86c4f97612e25b012d0507abc2525d4c8a0e578a755352b59ec102c9b1045de9bf0d935dcc09fae7474ac10f153632790fe120b919b7d883dde58c8ab22aea129ad63c535bee9b1d7f52c3ac4f2b1c3e52c557969a7a32e34ab5becab5c5b4b65ce2793084d4fff1d67414686f33298f48d73bcfc884660b0403e038b302e88112362eb04b57a91785dc4dbb0c2a9de65f13f355fe4ee3d418285ebd6c132b7e3cf81df738a155ecee998b2db24b4e42b8b4194aeff0f612c174a32a18e9c5745241fce86ce145f0c8689d781ac27dc41b46d671b5537608fb04674c9234d3d0386190ecd2ae279501369047eab631101db3186e72c6317d41e9a7f999ef4beca0097798691904a0f30d21ab14060c9aa987e340c80cc8800735a91b13bf96ef3d4882d7deb22e379a7764fe38719701a997ddbe104432d0c243af6d2505245a889f4847e2f29624ab24d9e41d7aefcfbca7563bd126dcc75bc61fac3bbf1790d08c40c47dcf03ced5046bed8b8c1226832191b7c014ef357ac8e7612afa5c1786a016d7fb8ce25a1bc86fb74a12ad58785387c9281b9d503784da1df481c907ae7d42d583a0ebd9455b5be0a0e9f62eb4bd19d31099e711fe05ab4a3db21ca8eefd763ee2636daa4c5b56188286fdf3dcb974d975440f48bb98b27be7602c7fb6f3b8e5499dfb993332730429ce6b7663f90adb9fbf340631db0f7d4d48b41d5256cfa397e60d0b167d1057e94a749d192d454d093aacef56a0afa60ff678bacfb487f412989a47f1c76691844673a10a6a68ed334ebfd9a9e77f81fe132fbfc85d848773fb259f766b976cadf148695fd43f64de65685e24b0c8e123e92710e739064868081a66858adbe7b1c51ec43a5d24c290b39a74b3ad0f9608fb785ae7e7edb0b071e16d628582db455b96a3639843c5f22ebf31ee09c16f0dfb77b47a07ef647341168087f1b6dfeb2e87b701a4906ffd7bfbb6e10578390a3bb6372e2b79d2cb6d1415a3a0fe2035712d26b4458b3dce02fb516ed1b812b126f7f0484b7913874b2cd8a0e769393a21c709c7b3bbda805ca4dca23b2eeb4f0f49235c1ab35a6e6c38b68b0865d4048aa5425b3ea9225c057fd1a7d497de30053b7bde43aa956d949c6b09ca668e6e463f6919fafe12f48c4f41fc3a412c888f9da2afa1ce0b4946ca543080856f640420e61e97aeca279c83beb03f8b8ec49ea555dc1f78d91c3ceae3528af748df3d6ddb393d9bb445250c8a0464529c44d70d013dbedb1c4e4615fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1469297d24c8e4bf6d6308b39472e0bf"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
