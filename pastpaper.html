<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>DPBuddy</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #F46C36;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #F46C36;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #00818F;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">DPBuddy</p>
                        <p><p>Please check lastest email for password change&nbsp;thankyou!</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Sign in " />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a05cc1e5a29cef08001bc3599e48b757a150bf7ad89b4601e45229d51710c513b0ccf0b1050babaa48fcc2431eb5694c31559df4d993543a33cb2e22b8a643f6950371e48e84f646f54c76a1afe012c4080dedcedee186fc05c620c26c22f5e2adb1e15c64672fd5f703675c204f49fa44751ebf6b6072a1b5164f6dd33a8e531f6169b05d722cac6b247e07b60994d8c05e5ff65c92bd32b844a2e4f843c392f6aab8cbbb68712e929ffd4c76dc111846274cd7f66ac0017f723b7b61322aa074a11051938e42c53d08bcf06ae45a7dba44dd3f4f33e7ef828722a9611f60871caf209fb40897abb841079267707a2389f1021ff3fe653a6bacb8e70e905059bd54e4fe0320078b9725b6a861a3f0a4d164583ef0fdf92e60d741a24721dbd317cb53c171b93015044c73453454dd41bdad12bbf7d639b8efc5293f934faad5ae60107bbdfcdfabcbd1a0d273f373037349a6544539386f973df2d0d43405f1f7e2f250be10c0b9750f107fa463e3dc45dfb5611f774c37f319d2b0062799ed940aacce3d48d72e3656cf10f90aa48b393d72035608bfe1d4f076d38f69615e515a859070ec58250f3bc8690494aac9797f425aa73a4e410792b4039c13af2f7c8dc5c26e5d646c3e30604214513541212506f06cbdb5c1af711d2f4f4b2abbff495bdef54bfc2958e25844e0873c2876a89cf9297a7f31d3f15607cbbadbeeaffc1a500d2671354ac4d1eef32af9ea29d34baf29518906625f35c6517e654e964174b357e53639c70562d3e094d9059dcbc4d5de5a5ba05aab22a869c54c6ee6af6900b7a1f7c53a67f1b9b4fa4701415bea08000172c2edaa2a628b90253f601569009068fec7f9816ae7caa32668fa9e7d884e67866aa6a4d2f0b2b436d09024abec14422b6154eac89dcec530ec1e26a6a8755f930923bb33a5b537f7cc849341491cc01ff112fe277ba5f3a3970d9e6a9b73b8c3e3d591ade05b528b4d2ce0d597378b7e08b939496d7eb4096adbe4fef562915a66daf115499247f08690cc3d78c376829112ca1128e793610d79b01c545aee2e473284660ae6ca9a610feb654fa171157bfb1e0cf18f13951dc975620e674245443b240e03cc4a55c8cc244b58f996670573245dd13995c792ac27bae32ea6d0ab3ccb084d63ef5766363f288368e1c47a25ed588582c5a37495ddd3777b2398092de426739c24742263e076152ed28b5897c870df0a3dda92122803710a01b281df2c9f1fcb4fbc5b333e39e04b8107afea226819b6953159592a1a5b9e98dbf2e337a073aeda4331510432784efa41fec9d0860aa3306c5d6098490a22a3ff8a6141bae6512f7cdda0f003b1949f0193c14ca4445e710495f60e6f3cc61bedb77e7a488ae68a758751577b2987b96dc87511d1c508bf0439a543251603f14fbd3093770e05f11ce6357d77b212fdc3e824ca193f300eecfb0e74b75f1029ef1c81735c4ca507d9e5e56f65844a9395b48f06f60283f0e192e7aaaa946adad0e12f4ec007b429f11dbfc83b58c9f1d00c8691496e6ea794de67cb98e1a9b03929e3307288267af3939aebe3543cd7d33b37ecf525f56bd787f4eb4500e062efa0a33ce970fc61045c868b643d3f9202fe2ad7d6c75621c90c177d769a3ca14a00fcb15bb9208b15b9e3f4d9e4156b4eecbd9baf3451ba7e2c4bd1d343c892feb127f2179b09aee45159641591e54f912c2458833d636421b6be4b9181b69b48eb9bf735a8f6c3a7c92a03d5b9d58b03510cf091bffc6f4099c2d23143ae6525f08680498bdeaefad73a58a557e1d977c8fb6130cc3e351685f15a422c474736ad710961413bca0d45c5417616644c3fbfa759c5ff10e7b283417b0215fb3cc5004c11bf0c8b76a5e1e02274259fe8ca5b30f2e6addc6251eba60d19e0bc5834e9acf1bcaf8c205175ed9e35f3c7edf068d35a4e99a816810152ba0df0ef2c154e9aba1b43a2bfab99400a5ed2b6a66cc125b383e31faad173b2d5a9929e6af26109a3e5d7784b494272e175f9dc63e869a0147bf0ea0e7f173b731464b5fa195fab9880ea023be8d1c728749747a5c830a80e681261126aea5d674715c841c51e88b7435aeb6e085ac2350fc488ab8fa009ea8ecde4b6296153b8913dfadde1df02de35890575a48f6a75fa39d819e93d28b3fa13bd21de39fd054ff3ae4e91612b1102d55ac384238a300b51bf14190a3ebdd5707313f309966208df6750ea722ca248a1518d2379f047026579136eb58380aa00162dbfb1cec55b041ddb5feb3cc20aac31522a9a276096f7105f78c8ca34d4d6c71b147dab4d3fcef71856654782cf0f613a9cb264fc591d997fd4132714ce66acefceb18ac67b8e9bb83bccace466b88eeaf8aa6b424619f04cb76d209fdf47062ca7bce3215b827715ccd7ad03ec8a4f10789662b2755dfabbc510c55db4210bc2aeed3a3491d47200a95446896985e409f659e56554eade6f2db5c6c4b7dbe6cd6ec0e156e2929b63616d01f99d98d7f3713e88b3fab061b936c228fb40790c703d0a284d341c7416231592cd36961bb1e5354a1d7c5ac0dd8048be77b31be658fd32c01a1622db11fd700fa33e55db9c775d662f7d941b5aee49d483fdedc3274a4857a5d969619e93db3cc604c762a3ee00aa5e67e469c76f413759395f1be372418611020488e99c24b370078d15075a1bd9599e19079c31fc41c43aa9a45a71b1585e95eea36d2f5e8e4620e919454d0b5229626b2adb15b888262c143d27894f1344831e1ec59c2cde626280d26dd3f439ce60e03a038b0534633dcf7c0c72a438a81ef699ff7f79b9bf4d36cd9a5c7ee2d5f01d80c627920a974419aad71f54d9ec50529928112f8ba9718303908d37687dcf47bd70c02363b98fca9805d7325795b09a75534ac15f102aee17eb1cdb67798322fb1ebaa93ea953ed4227ce30d9c7a0987ca8e885549e7ed2a5286730d51fa860202d9fe391cfa91e34240b69d4fba089e2c6e0c23b5d51197d3edf43d103bf432da61da56be0f1c1cf96290c69a3b37be9a84c0d461458281eba15b5f5ea86def92c2a43c556cc09fa65eb2b0c6b51544d57278bc1752b8675acf90607facc845cf693c728eb91d6982862c704f0e1a2936fabd4cb77ea59b4c321e56f8d06938e6af02ce86f5de6bc105b10321cf357ad1f2b835a0f182cc48bec4f515941b09842d78d4703e1ee8122e314e320b88551122cee8b1ea555a852a0fad5e0808813322ec77c8041c37ad136c37a5fc2bc331f0f2c8e690b875e51f9a5825a4e60cad6afcef6e692856db2b9bfb71b2a36ad5f101a0d867eb3320315c6d62f7aad4eef88676760ac83c1a3bcb158b82400a024fdca58a06beca3905809784affe99a5b34f177d2c00c17bdbd50fac52196376319d64bd7ba954a090b88d5d9276e14bb59c3b52c747f9149d96cf28fe0525277ec3d6f5adfc5efd524811c05d9cfbf7dad64f4eb63141986ee0e355bcab1592583a6a57ba9bb94f74f39705b8b3c3f9b30809044228375a19adea0568286c2a197710bfb63fd25ff6c0067767bd6351aa1277b6aad6112ae651e57933654e04e64234ee7a3a9e4cf14a5497acfe7cd360cc7eb4e1a8c217a6cdaefbc14debed2e47c0442ba9d59485bb0b53e4a35309d2a6afc13b943b249fec2eafb693245f337a018d659a93cdb0ddc6902d61d4c7f611a3384f5491c1b2bbd5eb21fb756a1ca4cbcd4a2b59970b9bdb72269b7ab05da27419a9d11c8440f67d9476639c7430bc9c8d42003b6dadc7111ab0e10372a8c1870125a830cf6ebddda9bba67ab761e32b2b5a6fc0558de15a6793d016feaf61eb21bcbf659fd1cf54da1aeef76a63e555cac12d5a6d083b4c15b5252c521f92515b045c81ec71df030c50d7917edf79a0f23960b4fa7868dc061d63cd52f692e68fce51db297f81e217e2d8e5a5262bd06ba1e5e31d84770b85ce4aa251dec6c30fe6f1559bbe03c2310cdffbb1112041287a30e492a06ff801a5766c5510fab34a72d913b72d20667d18884348192a544a49d995b5617acd5fab084353cc4772dc91f277f3a83bcbe7fca5e6da37c3d658ece0c7dd6e59c7f0584dd51ceb68d25afb13946c2fccbfbb59bf741ee4aa4f86756a479a36ac991f9125bc776b731d45901afb0a22010cc1a4346a0c6785a66337e736576ea5c16bb69e36d86ab70a27ffbec4fc4ce5ef6f17713210d75a7a5e51e58d4a9b0112970cc0f44ac918e465a301542b40bb552c9eed2924d049fb77f04df36dbbb51a346f50aeff53f99c3ab22d8f9dbd9c16c3d50a39e0bb6a3eb293e4d28822b8046d6b344d37a2f210b947f4baf78b3381c870c149b0ccf496f17de74c14af71d82270a406bc0e5e78506ee9c03bf50bd1627d462ebfab18055ccef756947a9191558952383327a8f861b4c9d1fc5b30ea36b6e2ad1a25c4be91b91a61b818956b326e066ff21759686c736f2153037a5cf4e9c0aaaf757c6c6cf8c5f3c59f98e1fa46bd9e35c28a4bd8b7e6d02777f848859e7bdf40534d0584469d72e8969e308154b61c493f9fd67d67ea8292e4c157211f120ea31274d6b72371feb9f11d7845c47273683726df290e1c81ad11463249f2b09ee7a9219f2a70c2c9f4e88d0e62bad7d7f7200e0dab7a0adb68dd6f8f906e875d420676ceb643c9eefb2c8ae4663b2690e5a5b7152044d16016ecfc6ac952e54a5875846f5316b0533c78c1f7c1e7cc67a2543e17b76525ec53f8124f6578a23e32819cba36f6c1e0456ad0f966a3550d49e634f8b9802bbc5196c7cf2fe05ed05495cd375b95cf349f9e61ade55b9686703de3b456f8ccd2f98a22dda51a986b9c0a79880a40b4051b959d2e6973a70efdc91f40fd722ddfc75c0226c439283c367239c51c436a52cfd57b1689815dd6531d8b998fcab5fc8eb04375324329048ba70ae849ceda530a8ee5119482789680e9e8bbceb4b1fcd93b27011478240bd32fa0ace34a0ba62ddc9cd3a66efed51840bb665c9519fc200c0cb7733c961c80dd5fc00c646b482bb7ecb55295ac1aaf1944baa2931ce03bde78aa184a4536e6fa83fb0e19aa715f9f85c7c820b4d8545dc4b1ef6b32681124ddb6a8e18286a4b2051c8e1b2f3e0ce3be41fce070dad92e4b9773c2a2f68c73802eb3a5e9803d0974f8c451de97a61185aed8d15168118c785f526d26071110b56055f27520b0aff0b61a65e79227daadd9958bd71c62819083a501e55d4b6b79477982d0edc2c984272c8586afdaf29b1eb4934767b6dffc9be233b91ef93dd7b46616790cbdd6bcbc73c7e7a777f790a3b0b0266008fea1e448af7423027e80178597af0039687ec1d6eafb0bb795539797dc98a2d3f6b7ff2149d5154bc4b44e2e631111ac810580abaf20ea0dddc767db82b24e7a67fe578f4c8311c3a64f05c3209ab9cd5b36b797b8a73291ca349018c7835e74cc60e884619abb92ed4447cd5774bbe75a6bf807f103735793612eaef4270d9e1f73cf7179873879341bda59112bc76fcff9cfd03658ab8cd0da193634debf6126e231254271abb1a8f3a161d85e12a2c7f1b4af64f6f5ea4b9f0fa5e3aa5a8a719eac0bf08ee87665e56399ad08d5ee48002a307881d6fd48b702470d30a9126572e2ff346126edfbead51f9d7e6d5c216779e5a07efd72a21742ce44ce46262ede3dc6ab207d2c9d76154ee64c74aa5c67e5697d5ee61b387cc271d610e9229f01d52d0ba78f37b8eac8a3ade8b61a4d104c00bacac674287dc409cdf25a366e8b7b0192cd588c77fe691abfb2d2fe4938c428b7b445abb25022d244d05f33a6fb2dd11d2ef67cb22e2d019f86a66bc4a4acaa12b3b38dfb127a24edb1c2f2e8d16815ae3fd85e1e4cf9bf394b45024907ce9321e09dab2c40062e555b67ed72b0b31ba381daa5d30776fee27d356861e177f88b1234cb07d3e9e11da5fdcec403a0ff8c36620d2669c18ae535c059d8e1790fa0d218336e3d64ce81eedfeac7a773223cf4954a8eaf4d97e108f733a35168f43f77b96ab9f765818bdf0be76e384e0778c3d4853eaa699ba254deeb3ec4c8c2b2c9c174144bbd52b39bdfc60168ce36224a9c2d6e37708540a5f329947f8a10ce4965dcc612c181e597865c4185b7cd20b944c8983db8d793c0b765831d449ef5cf4d3db64326a924ef84ed364abb6fbc36e3934efa9ba412e366f99436b7dda1d663671917d6e7aaaf1aa4c744e625b1c0b69a5092897cf39da85d112d2ee05651ad1563104d85f4a10e2b28a027bd8e2383da1920f256b3b27990679daaf4d08650e6d6ba83b1cf4470596761ad058c224c5bc363d3cfb2172f459ac2631bb2eb161a1807dcf5f7f12e193f2436ad01650044d14cd63ec445c27b26aae828e179388dc5e444929d1eaa4308b47631f0cd1ab9793e1a066727be6f42130cf31999d8044501ee24ff7308d65fb12b40568121cfb9cce1a61cc8b28a1e2722689cc6326acb894ec766fda520fef05f041c1d71821565679b060c863817c842c586356a3510ccc934162dc692d3e0b6e5c2faec23739146c9222a47ef8ed04b3a5f1bc6b412aaaa3c244505c4af33980fd990f622874073618b5357c351bcff3c5538532198d1234fb92c3745e6bec44d26fd1aefeeef6b620110cf1acd3565c09de515f9e0815492e0b0d793a8dea42df23e6e0d441e695ea50f2c3dbd02b9c97fcf506a84f148c873b1a39f216e2cff52a67aa8a074f59b09351d20689e6ad0f9ad6997b02b858bec2fc42748b413a86ae408eb7043f574775a6db57f527b96ec5a6f7e96b9726d6c208e71d3e7f53dbe8df9ef403272a42b738d67c825eaa68015f26b985234dc93199c1c3755bec90b137129f120e9eb9aa800d2a487022f688707c166081be4cd5c72257775a175d5668fb989ef0dd4528040e43d1b206b1c43864b43ce8acba5bc47b38dfe28c8f20e6a1dca1bf94a618953d6c2e04e2a7a09da58078a1f84b3e586a911612e92dd7ec27652bbb3cd566422a602648b843d070357ed1358a1d784a0551e90d760cd0f4655783f3ff8e661047df65f549c503f22723a3531c466205e6400ebd1228919685a62bfeeb9d835872dcea6eb86f399eafa35f27630235ac4c66dbaf2293a51b2a2f8b98d63296131ea2960b48f53bf4f82d5df0a13a398f8288f65f0587a7864dcb2f9ded94b0a67639f58c683b48a2c74c772f45b41fcc3c5484aa561c3ab64c17bc8a26a43e7ea1bcd25270929cc9b7cda2c2c1ffb7f0cd6b822ca44082495e16c569f64279e55dd68fc017901fbbd9d1b1b5a4eadf6fb5e1a6eca313f216749c44104abfcb7c9ef10ba5e01fcf6d489dfd21d655dbfab8147c953e8224de70465e07f26f0894a29cb42a94d171ef613429100f2a94c798af8bae11ccad26a57d66821016fff8dee94ecfba1a864f7791748cde0a07b46735378db16cb356b51fbe815c99b3f8c38c7c5abbd1ff53f57f6df02790f1b1244185b4d7d743c5b67274119d29b80874d170fe7d081fdfb0665928236f82c004dd837c25704385c65e5f80d108fbb5713afe8ebec4ea9800f8ecd992b351220dc39899a8b34592e399d23d724ad6e6b62896829e0eaf664f420151554189414055186c7ba0a3056810316ae1d43378bc954a9fa6166cb3f92e45e2723a4442b382ab222843b232a783f6d16c1cdc2616475f50b4394de229af36966e06837714006144233621d45d18b4927067b3dd57799c154dfaf3a933f759afe80444e56776af232ea916a6c6e696c4eb85b1027f69fbed0e3ab5e5ee9d8e5445380ec644b929397e916be04ed757a94e1a613c4467b151ef916ee5361aedb5c29dae0f76f8e182c886ffb6ac96f2f1c57c2088f9669ceafd23af61993e83ca2ac152b0f3415e41fb23cb1250841e04f9514734436075b58a75dff7e3ed03106e1b990c7e752aa7359a1007c440f96d77df3f3332da811c017c33a3d17346b69fa8b853d0cc16e14a9179b822808d1cc6bfcb28b013a6e0c53004968601314a99ba6da344112cc2ba4ad201ffc9563e95e7300b0929e6e7024c61821110644d238737db9fba4bc9334f06961d1f66c827df5692e403e36f8ef459fda927c05fd270cd6f8360ee1213f5fe0eac2e5b009c77e05a0b4a05f9c42814a9ede9059c205c8c3c8e1cd51e34ac6b9e0e8d2cefa9baa33e0e32908b1b74527f43c0b0c96cb73f2217e21ade7880285036f377cf13b131662451b6e20a9cf9810502d7bd214f565d6aaaa780f2163298564818553120655e43f4928a454183cfeb1266dcd69ea0aa2ad080a70fd15c0958cf2a699dbc5b923ccbffabbab8cf3e426df73d948b06bdeef59145699d5a39af1a9de3d0b873f6dad79ac84ccaf0a8e552b91a667d57aacadf63e0643bd3a0d60856f09419deb9c7af9e69a0f36bb2fc8d38a1b6153980a1afbed2d98cf7037a1240125279a0421608df0b1970f2ade027d3392760d1a702d17912114ba766c585d54fee634b1baefd53d24450c2e4c033c86efaac10b6b0f8584ca898d79e6625b373940a36c607f326c684638d0292ca88363b87150d975ba9b218b75c66447b8932e50bced45a8efc7daab60d87df93277429c5ce19461abf426034b023dbeb3f8d640963fa9640bc99c1c7c2a0a541cbfd82295d768fcbcf111a285ae60fa38c44c5e71f8b31595f5bc632e04e3c74059fdd8f94598a74265017d18470984c0cc85703523c7a4ab2234ec1a10920a92b69b4b7845660f1783c27d6dcf663f7895a562c5610713424efe47f1b946f718c6c156a54c392bdd905e7b4f5758c5a9251f666ac7a1d91b20e3457d4dd8b803240709dab88d7661d73521321004799a0b62477bbfaede0fb651b3958575f8b6514d4d28bd859ae4b4f45843344608c4a9b24c618aff66e7dbc6c2cde095cbc47951bec664740600ef94da1aeb61c7ec30c9b7f10c641f74a02f3957255df98f252ce8ae3d1cd4f9429f01bc8c03777d009432dd3f20afb217a8a7fac865104fa0baf0581daac7b8f34284bbfea6871e76305c6a98f934d9955bba672c0d52db0dc59fc6251c967aca1856757878777e03919e4fda49c66be5a8a1c5d4edd43a5aeaf559c6283820dc0860f73258ebe391a7b500382ab5353ed60aa6191b1e680fc2ba63fd9c783691646860b6868f9ce12cbe21191cd0ccd4978c099ac0d4174230913e9bf81442be1cbdb9a67f4abcd1f8f4c43bcc0cbe6e015d126bcbb63c4f9efc55a5eaff78d2ce219a5242c81c512b3a77b7797e76a46c6c148675faefb5e6168bdc8b933b252f1627e6044d247eefa35e782e9c34c5d9be07c3b73ba43d7fb47d31b5664d77bec16cc1d882eea3ad17f74bb9281a43faa194bc7b89659e69fe022902ec32c8ec1c8e560261a668a947d2451705434c69aa1f6a42b7189da7074a64cd2cace8d2d115542f503405fa73e8905eb9e34908690c84d111f95fd7505fe55249bfdaeef01c5500553bc7a1d1d8514e2bb86eda610f408a1cd6261ad3ebe2e51a8a4348ac4c548142f4178407e89349ce8de0bdc129bbe1794d309984139fd66bca9dd6cef5b34c5a826dac1f9b4fa8ab98c1485267f0635e905b399a6c9636a58fe99d0e1af32908dec672b071f1070dcaae7598aad393b182d1372aed538f3c858f15a66f43fa9f0cf932c7567399ea98f83baa03ea5869d36d8db27a30fc106300192a1080ad000132429806421a80dc7bdede4b2ccb615ab9e8e271bfa260728ec4847768ca75d5075845ed7fe24aad01e63787a6ccc2876bc1bc9de4c1826b0f27e71c31d200a47f9dbdb9f78eedad2626e9b3e9bfc556add50ff8f55460525f66d92117237fee008c277b8cdca62f90faaba054095a30828e2d50712b559a294fe9b5b8730b856a3c8cf9ea856efcf02163a884d2b1ca9d84f4bb8e474cdef25f7abad51295fdac7a6d3f26a92536a438e7ce4146a9e929f1e808482868784f02050114536148612761f8fdb9a312f7daacd36c046f50a13e7c02d9a7284164c15b0bbeb422adc94c3574b4f4bbfcb4bb981e83f2667e9a1115ba68ac655a4a95b65b57d4156c433e31698c69e93b7f7f24389c544e91d045e6103bdfd28eb961076881ff347173f8382c7fd2604b3c7e32ad958b0f0f35f7a6f17e65aa1a4cf45062fb73f6c104837a4153c4bd8e62b5f05ad5bb2d8548e1a75046597d417e52da289bb1d24697a87798793fb23a4b5f7d064781fb779196f630f781d7a0bee8db8f7a65c46b4259ee3b4c35138aec0753276c841992692517f94b10953829d0499ca0de7919766c2d38a6b40d748a0681b7c648a2e60f9a2728e42c34af85f2b0487a626f8a08780fc406966c2cde28db6a6cbd274d5f70a4e32e04b2739ac1cc88ddf74d385546db03c1577c418a001db3b63506ad945b153fcb892a22c8040368bd21b1b5568ee03fc240b7cf97eb4a61e1e244db17a5725ae132df5c4cff84fef73d372d685fb7f7716b3c01f81de47fd4afbb31659f9a1c43f6bf6870fa2c788233d82cbb637f46c99816be81eb7ba7da4aa385e9ca675e7cd4187001241f9b934b37e7005ec37b0fa4aaa558d53491f0b3f3a38f7820052ce425b270fe9b240d11278153382e01bcae8e2b52b308002fa200f54a5a35994c5701778ce830804b006dc2b92f9c0b253a556febabebdd3e1ad871e6adec414c0575dff716308ab9aa619993b5a04c9c98870f8bd01fba6a4a4387410bf4938c0c3cacf2436a152d3e10fe04aa2b1931ee86db4dd739358728d5f3dc5d4292e50147e956d261d39219911ad9532a74e3f6ebdc157bbe99a14d777628e65b7ad08d7fbd67e8424e734de64a7945d939d176297dee86669ccb575293d8a56df10a2f39ba6ee983a893e052cb0cffd6c75a55fa3e42579323acfd870ec32a8448196aa6a2531b44f5ac7e04f365764810a3b54b46a4e235747693f9cc3ecf44e511743aa9439b7fedd6b8dbabd6c6ab572ce31310539038dea9cab421ceee327c586cd546924db692d83fb0b1110532db88a4bfe4274bf4e0e3a4316e8569e196c03920cdcc135ec4ee62a16c8a61c234dcfc86d66746fac4e6b5db2cb38ce28493e6ada02d12dcb5feffc3f2c3a16a8ca4d7715fd2fbd6e1911ae6cf6f1366393e35749f6b491ab662cde39ea1b00195d759fe78422e02ec744e82b9b7967d69808bb6363ae1d8e953823515d9aab077cdba7380c6e3698c183082e2205de79bfada7d0042038a727f64fff19b647bc957e0856ec1fc6b28c89a913d392ec16461c362ed1c407f4a02bad49644ca677c461a8543080c16d25a325b4ac51a9dd4c7986647666819a478f61dafb81eefcd4ce11f440042622b520a30e3382b70ac0b9122b7b54cf5e9c5cadfe3eecace988b0d9b034ae5fda973e83fc741468c0530eb63dde970b8ce44ee2d91ab1fb025c416665e2eed201fc7fd72a4ab7238f039b84a3b29c18cde63c6f2cf6b1176c460a9212d1315941d3c12bd2c0bce9c8b023c968f07e5eb31f50725b3e59eec6b0fab3dc78ba7fa2102ff100c2828917b0b3b1ac7a944e180b9507ec5ab2bfe5527ca217eb7ecfb31a4606b2b8b4db646333e18e03bab396cfb92a47cb9e97009bbac394b6cc2e2f04cc4f79645e8d0b2e5355972ced38d0487b6bda7bde7b100963c8e8814e52494cb126f68ceb3ad126e1e5b65db5949203a25e5ab0ed622936694f9fc7c47d12f8e2a0ec0213fa237f8e031f061aecae822be1deda32ad7f4983e98b1cd42ad4bccde28b7e0800054c6f9d69713b98df272b489bb163e3aba03f3617be79aadf0dc93e5e84fda09bb66475c0876246493d3f209cde6139791d2124c07273641d3e42023de47bdfcb6e484e04777ce59a90eebb435713b12d4998f21e8ce3329d376d2beeabfc231c44a87d77f3f4434c023d547089a2badc9fc64fe200df1c27b40fe3c8e0d81cb27d616e658dec49ec712ca70fa21e485cddd11a3fbb00293a3241f90bbaee8c0f847315ce9bf7902c54c2a5b0ba9b0034cf61c55f055fadfd5c641acdd5334bd37ed4108942e84d414ac962db71ba8ac26f355f08258cacf8e0cd6df75133091006b208f6d0b5b8f097fd19b6336d60baa6162eb8be917d083f787eca9a0283fd6641e11d664abbef3524d756995fcfc78a76065c3cc66aa90b88cdbd186adcd819a920daf4ddcb92e9719c7235a6552661e12cd219c4f229606800b7d431fdcab6ad4659503fffd9a7a4d0a519633228495e4015d86cda6542c610a6b921028f339b867b2a6513d6149394784883b5c51134f4f07fd5a3299c2452d31fd33258b2cc5b3bb1671470e5d2f99428ea22ff42fc9de6f0613f15824ec56335eb4b2f91b6eca7516e4ff943924dec2cc8c7f45f4638d88940fcb83db240fd1475f25a04afcec19cb73ad60674a35cdfef74f5e5b55128924aed0f92b3e93e5b794d148e55169994f041deeb640e6260b999d1ad9fab74e5b2229af048d62ebcbbc2a0d72d2466fcd2a614c7cc8722d37d78e2a400184920af77447fddaf79116fc1ab9c5a75b2c9d8aac103bc863300a75e86bb3cad7637ef0bd58282a378ec16a3b57567266af2deeb2a6dcd8f41a402d0fc55689cdc996b8d551b7af3b5b298dadba63e3ab0cac2239aa9c267d7b471f19811b37d0cd3da2d92b7dcc00dd513332edce1145ab07dd52a15558f6e562a156b2d868400bcb1f5b01e5f76857a7aec982b3c163e83d6275dbce688ce57fde2b32556f13c6a89abe4bbaef6e0c8f8de8e47f6e25e8a6962dd6a5c42fa4624f4da3e2fa0fb28891d3ef99144af31242e07b0d43a46ebdb09cd7dc1c95c6da50f0af2763d74a94dd3ca177599d4d2a13fb0011433e5f6863a82c2cdbf03149b8b038a89b9c96608cc75551eec7b3562c46ef8eeaab945746db5588507cc818d892e06d26a2e464202b531976954ee1b21d9ebc32e4285769e5f6888216f86c9140f4f1feddf015de7ae9a240456cd756f6ff2ce260cd1a93ee511f7be8b7eddfb5649e772264837ecdd31c46c3c9cda2d5eeb0bea16c2d8086f176e3749efc9ea1e8545c10534d86a3d2ab2ade053f20176a7f83adcc36e1deba1ab5765e1262487803adbfe1c41b6c89a668bef9aa41b9122eb3a6aea0834f03c23f3bb29327d0da1d184823c47b2b8beb0932bf484e7bf8805d56a79471637f0a8d69b6cd61f9650c5b5f50b3b5b0d539d76e622479b18a6ebafe53bfea1a65bd5d3ddbb62ad4b6ef071b546aef5ad50dd6b65e8bd2aed36a592e7e4fabd59075e06dd309512ba60f1d2cfb7e8c7b0a32e526b0dbfb31891fc7026f8033b3bf40e4e0958f050ac6645bec24ea2aaa0e04e63d942086ae83a0db16534f936bc3c616eb987667e227626586e4a9964cf2f4e9502673285a14fb0bb6ac083e0f372c946314b7b6f95d3509140e13ea2339ed2918d4fb5cd70f09743a268c752b98ae6fd0d357c589d5f9f3c45e8bb2cce6670ba43d2b55b35a97a17ebc149f288eb733a1f40b6f9301cd0704e2c38d6fab9c8c8ffb705450ccd0465a949b39c4a643c8da63e525a0ccf850f5b5739fb3460126ec3782940f30c38a9e7acf00bc630fed2578c088f3e58804b33729517fa30117141dcb7898e85b583e73f03a2696e5d0040f4e081ee76ef7ed2b9dca57c2661430e086c357be9c15b8d21dbde5045332c48e9b45af4ea8410e44be39b1cc37a9a9dc058d8a37f09b8055368fab4d01fd71fcc187ac58413ddc41b81d0372ef91255f502027240ad1fceda6b909ac5ab5440ff13775d1240aafa9834c07dcfb68c5998fcbfb19f0592366596532c5199d75b6da6b9ff28e338f7a89f099535cdf42600a9c91865acbb3152180cc57cebf1ab98d307574dea57a19781ca6e18cebe53e9d83ee1e7e9ef7ed4ca096267dd11e316c4ba8e2c0d048509392efc1e1fdba489586448652d4ebc72fe3ae0bc04e729fcb01f616c417c4cd965dc4e57018ff2d8ea39f5047006bdcf494f418bc9f6c23380fdb50af7a20cde87b1ddb703130f7ab88fe0b1f0ada89201c7d3e0c375c51356493dfef491eb70331d1c18b25787ee28168dd3caebe5304217bcd94763a79042039434031154a47327b59a313717ef154c24db275b791f5bd727e954b4d18b5e187edeae01d869df3d2a7e33a44c2569052e0e486c596c71a697f1e1910f446bac53b4fb6b37897da19b804f7eeae73bae43080028d7a320a0ac82abaf442cdce3a30c29575372296555a2523f48f48c8878c4d8ef0e7be76813e439de61c7b05e2b92acfdf4494d4efcf89f66e55036e39519731fdb705753c0de2a90a91d6a072395052c27fee05802dcd73c9afc9786feb3e2598978efc9818886e8ee08fdd0b8810e1d9abe55a0211eb9db4bff20a1e279961df11d93b057c3d7c6ddb83c30289fe868ca70163b0dd42e737c2d2b2a73b82e669acf656c6fa548356a19e10f5ffe255e34232cc33e8de8c34e276bff2c72bd263138d23f3cd69b2b91f5ff7bed6325e1dab201c1a00417dbac94a48039fa4bf2a96a46341f888064a1455b6cd8234423b847b8407b88da87dcef04f7f7d9d7c7812ddb79a571b6c93fd322bbf9815125a42e1766240fa81fab0b4dbaf13141781973110d1ad57d94681b000a60b83ff250843614f6a4e182f6357bb822806992bf0904763552f84d278bf4750ef68b614e22841e90c1cbd7a9e373f4cbf63531fd8fca0423510f1d21679956fa2fbb7c3c9f0e52a7b11f42de928b2d2d56ddc7d7b698e7e0c85b11fe7d78bcf46eb3d1534b8570476642054229e0281914d8507f99148ef18368870a2420bd60b8501d1dfdb9420cac5d52eb9a4f19b6a8ff8932cee0d8c77c69c0ed452f8b5aa337bff90387d6cbcdddd094347935ae3a2322f48a63880e2da40b694a78ffba1813d6279dcffe6d0507edc28a36bf2f8115411008cc444efe362749b385565dd54ef0df025e3816ea107f683440cf0c0abf1a88546011ae05984a406adb5d03ce18138d1dea933b0ae9810e415888420b5972467e0d4ba1aeba09b0c3267481026e9cd10b03db9198ef357d0bb5df1c4fd9f34030e63f4b102b7c6740d0f082aec7d86300ea52827f1732335b151640f1c0cc5af37277b8c562a9bd50425673958dc716f943c0bdabc4181bbfdf10bd4fdbc12660efcd1a6ffb8a92016598d38d240da1fcda7278cc6bfef01abe5f4c1e1dfd8dfe6100143874ce585f4ac046c990ba837eb8ea1caf09e378050db47d89958c9ffe2f5826027dba43fcf323014a338a48e7d77101eddfd479e682","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"acc933b7e4e62ad7a191cfd44fe9e9ca"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
