<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>DPBuddy</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #F46C36;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #F46C36;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #00818F;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">DPBuddy</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Sign in " />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"43cc8ef05a5e2bdfdae110bab59e724e6895027975e96f9b289ab50f63302c0c6a49d4e3a1792c802d087a590e29a9b037c716f5127d257b2fb989ad7d7c4e393165e6d7efed46d0ebe84d5d9c4c66cb2fd8fad4193c4c07371f002d099092907d33677d7545ee56468cfdd000a39f90754df0733d36643560ec197235b5ec93ddbe6c89bc570013ee685efc637beb54ca0be98aed3a3fad4ce2429d4a9a1d1996ebd380ff1436c5af7aae4ea35d126eaf89aefdaa56323534c478b2c5ef587d17bf80bf8cdeba963306f109132856dd92df65dc0e9d285d07095cf18d4be7763ee71c4cd4bb83951cebed36b074991fa4da69f5f0ba1f87d2f7f080c98b47d399e81d93a44c998d527ee05b28abe9bc56a879d70fafba91363019a521ac5dba73b5fc47e22301f265878e86fb0dbc1f263dee44184d75e62c2ff5d8eded864940ce13c888c8262a31501bb8b816bdc5a22d46e70799f23abb56bff106dd63fa03ea114887f3ed33547ed45cdfd0a0d95af6decc71e34d8c9ee4e79e45273951f4e6efc97ceedc64f560c40e395575cb9de5d12237aa48782645f3222b25e11d17b4d99c9b9157e9aca76a6ab976ea991db28f52a7c210625b79a2213c36df8a7cec40b37d1fc3dba98ee33ee953d25ec5e4381a40b67d46c7075c8115cdc6ac868c90f9394b0916bf3795aa91a344e5c5e60d163b84aafbc7f9a0006d75d232e39175ae8c569b918613ec286ee7cb9b709fadbe814479f9943d0b496ecb0b94d36e03d4840768c984f66451699ba5365e16da0f0f30718e479c1c404fbec3a90f8dc0f25d588973dd7c81965ae6d34b55c10577a3e92d11774d042bdfd2970043d788547bafa6ada7ed814c607c71da24f4530dd1c9e903f6efa3c728ea3a6043117d6f8f509b5e587fc085eebfaea09c320f553bec192f7df0a7c1c1cb86571879e2469f59128dd086706539adf4434b83fcfbdce988981039c73d1d1da40e8b0bae9a57ce2135fde7f981b3167befc84e646af47663406cf97473f214b5568d80e25b6f7926268b87c8488f68ad7e0408deaff85231481668798b22cca6985f0474b69a65bb712be2914e076a882b5ec5a53db67a28182067e236d04b274a6bae9a678249eab5c2cc9d580e8fd646c498c52924577331087997db598c0a879d9b0c310973f448ea09b1bc13584681dc1d7878cb72e56c277f8092fd6041b4b9c0ebb71e5f67331fe6b399982f137e7713b2df8cc14259d85125932c1569fa3dcd0a1c60682b1d3f998687cbbeda9d527e6292b1b17964331445c06c9c6bf6122a3ba013905d6ff798c32d78c17b12268279a625a1b9bc7d9d81bcfea5060be4f7589427bf027d878a708434706e955722ce325052008fd4d5b98c0edac64d3108c07ae079cd0aa01cd1d3a0b7565fdd10235c5f0104eb21da759679d9b85d5fd7120ed93b32691b5dab4da22f6cba420783450b5ff1f1c5145b56da394a5f60919e86aa685b47370e4f8a8f9bd5bd63a780044ead170541c76c4d8b0540b47b6e51ff4564adcc14fba4f36903873923dc1f824ea9a6d90b12ba3d74c3e10b4b074002de78d48bad178736f20169f022881d3b19b369f806badc02bdfb7171169bc042d7a1c15f5957a76f98fc99d569e9db15ec0bb3e905d7e7b178126d1b65f5dfd59885bcb4bf7ff07734f2661925f595ea98c1ca6c5a4cc6899ed788b50d054e6ae05bd14e6d669f5d5a3510093bd5670f517238d426ba7ef5811223b5ba2b2cfdedd54f1b742729509d9487634fc0a963ef92dcfe6207cd1ab3c7ecc9feb55cfb947a73da80882ab7e35c25a164e7cf3945c22e71ea131888b2ddee1a2c750c752e925bf317f2e935b947e67ed5320ed137815a1bbcf5844067f75a745e71dbb47edb28521b5d65937739c11fae8192ce84772b4c1dd5bfddb0fd2cc8a1ff05b33645391d9c2cd72d0b8a2ecf7f05c2858196ec95b65960f08d0c7d9b746347549a778b7bde440f0bc3101c14efca932db08006ee231fc4d822c6e9e8893bda1bf472115bdb21c423b48e3f246c6601344c8962085fe607f6c654cf31f2b4466967db1989d6c1849a5486e8092a5e2603c3916bdfe65a18e471a8a1d2f7266a3bc2ae9c56d07d2f93b004d8fbc639268ebad285d720fdb68585e2406b11504a16b7dff792ef07a9cdf41144247f147a07cab35eb6c9e0c0a61003a4ca1536f80697b463be32e8478e9ac3eb06980cb69fd99b223fb9538ecb8648f77e370870c098690420c9cd2cf86364f1ab462362bc380d53e68a25066faba83c4d4c815d9292faf603fc30c28a304237a184eea75c8861eb880ebb008dc2d1f841ef58816d3a2404b9a790cb2e7d2097d6636d34fb1bb19c7e62c08a0c01e33fe1c1bab952e856d9f149b90d21c5d137e83bc63e372a82e17c7eec8cfe9ccbb22bc54a0f8b1218d181d93a1a789a017969065e6716ef67bf6ac74f0a0ea8f38697952e873bdb172ac7f6228d49a62eeaff06a37f65d086202092eaf9494d4f9b29802356cb963c5fb0d8c37903ab4db124cfd822116e778aca11e0e158d9c713d2a60bb66d4769f82f51c549fd8d3bad57751c06443013febb70693083479c79cfad191c8921045431ceb1a2e906199a4e1fa50ea00ba0e9133245746768bdef290731e771156d3314620f6686f0ab1b8b1d589970b16d1c725ab33f671583ed04f213a9908b26f3a19178d925a4614128c1af18b01109a0a1c5c538680829f0add762c52f96e121e829bdc581921e97f2772821520b439cbfeb086789f9e0ee55652e5be8c0f246ea2346c0674c894f63a962f7f106a82732b1beedbb73a04b568557f7c1c616dfb8b00e37f2f846de7aded7c6752fa0f47ed18a5f8d835c23889dd55c91d73feb232e4e82c638916ae4ed022cd5708d561035a1a1796dd2062756d2a261e83bb82be40a7551cc7be1ba91316619c7ddd2e0007e8b4b16fba2b7186855aa09d888fb28ef6b6c6eb970bbddb60ea065de3f75e344e13b96523cc0784cf14a77e8196bcf1119092489a9615003289b03a46fed525b2748d953341dbe7f238e00bbb7e49357661aa5b92bfc329cb7b70a18beb5796d621648b7ec31cbd10e4a0b0729e83dfc282045ee794e575778974d11eaa3972a4d67a6a506d97f2b235eefde2caf0f3a76cff92264dc19fc677fd9863e844ad8f4128f0169c49053de60c39015d75b9f124bb5754f7d26962a234d424415fecfbfcfd8b6d54f16fd28ec749ebf27755542ceaa00c6f48dbb1b4fe3862c554e3595de74d3150ec3b3e44dd8ff06918d8952830629742a468d6e4a9599cea4f5eaf13c54f0d81310ad16b6ca2914dba07998744c2ca23aad75b7412a7ab4e95b565f8e4e6d868959f38400a41dd381a43e8c915a6e98133a49b44a6fff42499cf89d17895e72e1aa1aed0dfd26ebe613bf1c26a95d1f24365c6d1960eb8b748e9812c53bc7844b47367869676582d3d0eca4cd4ad009db697b64133cc38450f42f8422622d511fe347f5624fae06d9492a0c5f0da23c114b227b1623b87db5ee451fef3bfafff1770612ba42fff29fb227d6f4d0aa3d445287217fbdd4dcb6368e1006edb5005f41d2252b3802e0ca37e0572645da3f08fbe60df5c721f5cabf2ca7683837beba181fdd01f743e71723a5e6a6a64055eab468a9341af1d885045497eb7f5744a33e4a3234bb342a09104ec8576f82145ee764f566b9517f764d456f16e1d1affecceeea8f2d843d568b560e64a31024f08053f74f0c00adbd5550de09f274b2f6492efcb5f28b131712d0f6e2240e20c7a4964355babb14a7175104948fbc0e5a9f6cb86300246153bd7ccf09b9b668127d3b893e19d7489bdd4dbc2641810e4de5ed3e941cb9001b30b1faeb58ddf171f36b780a1d3b74c905080a4ab6cdd6414a8e83b62700d2a7bc9c74dcc55f45e22dc0d861dff4a46694be13aa44ffb3068413c4d2eed93a514005122383f43c3b586b108763aca83adfe834599a905e2f3626431ab20517b37c3a1b2c4658a5e7f20664c1b2a2a90a8178f0c54696c03738e8eeff6faec8fd85c60219c612a25ac5378e4d690d1c415aec529fecd2ec00c29397868341d3472a5a49070f8a0b20e4435eae0af53973ec71d4cc0e6044205d90cc613e24daa78f6d58f06456add4be22132243c01f91217b4f85e82c375e27bece6cbbcef17668959b7cab46e14de8ea8d6033e1a139e6ef1362f6679d6e47f6c5ece56118be4a1ecef49d0cefcd33f4bcc5f021d9b987349e5c501159b56b6d675b6450e73d0fd07341e28f4d01c22c1e890f24e0f4ea2aed39c0d7cbcc557def98a3ba5a3ee5d66d116e450a2d95bcfba0e1f0f918f9e49e887c7b86532a6ecfcd41ddb97ab4ce7763f84dd7a0c263ef776f4fdfec66de4ce55278b59ae0066513127513fed47b33e663b5043fa578a7be8013777e299ba5754acfb1ae402d479b4c38c7c60a78e4dba8d4de3c46630af9b8363cc1f4dd4bc381a25c55a1da207ef81a6272590b6969d620a3eedb5981fa487ae5dca7bacbd2c4c7444c201facb10391b281e3e60c077453936ee7d683ff662cc9ec16b04d682f1887cb883e0e4338ff59f04d95e76b486911865f933ed0903737c84797a31f21704609216d1df2b4a4d508041c97086ec26279099cab9eba93dfd9519fd31c408aa92f4409fed6ed579d6bb7031904b47d7e9945c5dc04ef46def586b67a48538cf0cbd9a960a9ffdf43d35cf5ff12b9a5c219633f46a227c0af42b786891471a50886fc17202fddbdd38d8c867223a5e823178f72a01f910532e0efdabc7c24fe0c84b8d1331bb3d7770fb45e523a0aac89e83d9a8dfdd1a3a6dd591fe40cc7ddf133222c460fd2af7a9f554a22a66e0c402cd14af590f4e96908af470a935b34f3d0e356120ec65f96f401eb03071faed98a1a8049879239ecb1e8b568d97ef71a8caafabd854bfc6c6cab170aff4ec9914613bf87d3c68f28c2d7d2a516f849b36f4f6d0e6d5d31d098e566aa5359c17eff19e38bebf131bdd5c0c7bd9b96612ceadb249a27a09b1139e89292a5d6dddd491a8c6ca1c49c596c4794c34967609d51eb72e9c5320a000f68134ea47f20f8b1ec219267c88dd91628d195a1baf436ccbe31bc5a8586e5a9309a593999ddcaaea598a388d759cf24a74dcba6a746fb28aec311904f50cd7da921f6f2084bbf2456cfceff255eefb6fd5490080195bfa26a690ae5345d269dac5e95ead95688f4839b5a50f03b060396709d7937e831126432ca2f90ed049176e353d385ef6bce1d98d5902ee2aad145ef121fee1e24a66fbb64ff64c14754d584f1cb7d0f70d1f71d0396c8434bc4059d2fd68c0046808f1bd8446968a079c82cde09d0ff6543901b9cec1e5822165ea0be509ff52991e85b7425a6c8528ac7ad436f5460b926e941c0c9c4eb8ad8fbb7faac894fed82b2e3d1753de92966fd222f01e742f503d7cdfcab56be225029d7b2a8b566dd6af16c49a951fa54a036e399c533544d302baca0038365fd47d05ba54e0919841bab01e09aaf643e499b5e257b689892873e36a2c8f33cee75f06d53dc5b7a930ebfee7fe6457b1b70a9d79622a9633aec458beae08ecee1d71f754751b1b082fda6ef72fdcf6252a8972d4f00a065d5ce2ae05d58304a5ac55f168e78213d024272de463de61363690ac6c5ec79398ab3104ba3f90b4bd6ae23746e6e311d66a72962d3f2e1bd5e4d26df94595207f188cf5863b97fc75eeca0e969420f0ae55739622c883c0d1fb48d43695115be231aa49f741eaa58c2360f8dd9076663c17995bc47aafe6d8689de20a06169398feeaa9cbf120ca2bd74bf2200ab286fcf117b9ad157e7baf3c28d3e22b7ff678eeb7d4c5aa17fdd429a0c37a7d5b34533e2c56ef16abf93526a4cfa473fda8440f48131338589236a94cc2a010309928c86a31c3f1c3103e3af573aeebc816631e1d184db6742121217e2d417742ecfddf06573922e265de3293f6510f945bd78f21769b8bfdc7876af9839fda8bcaa12f19adbd8cd12d91f453a1e564cb4e0959e100b9ea9d099a82f90d02993e9215dec1be7c4e617806890dcdc73b0b3f9e24056ed619104fc2f162e9ef253d03531f01fe9b0b842068408e327506c4fab9c72022612246e8164280643112e4e9f98d7e4f153e9be96dcf99242b174e7edac8b11e8a4c51bd8eac563c21284f905aaed7e11937ff8129baeccaff4337e087df27a8763a2341726934437d2c6006d89da84123247b66af534ba291fff80630146d9cc0d7adbba001128a139132c633bee39ee98fc1a44d5efe68f5eefa25ab7327899afdfae149c6d64795144e3c3133fcd589eab200bd45cd038c0dc5e99385646d13bc2227cde35ef43e2f7d48fbee3e8614a360fe24804b8178847c06496f6e39fbea8e557ed0a84e5db5d08b20b3e4dad63a9550f02a051ecbb5fcb8f8c279f22605c2227104de1539ed9be1e8f213fb98fefe7f80fa946080d5038daf77421105771a8187838f2483c549352d5ee2e6042e60bd8474e889f504bd762b7104c6cf4c7bbca14235f529ffd782f5b25f7b0ecb6c1d7ec3831ef2b1d84f11be40c3e34fe49717fe3851b56a8dd19fe9ba6ec75bf0cd42035a7e218aab2db1fdce11f9bb68df41d7a4166503c454cc2c22a616e5136908f3156fd559ad7e5fc8df5fd940f075880ad1052a958eaed39a37f86721319c3b2e2ff873252baea84fa11e0bf34158be0dc13dcd925b6ac818b924d8141360688dc1845dcb516ec739cd0070cb477e4d9f2e93f1422cf241dd1929b4bd9944a78d95e8b725549c6e28b20f30587ea1eded2a0f6035bafc45b6dedcfd0053d8b6025908d0bfac11a31395cd41a5b86b0b82e6c039bf683436ee6d09d7d2d5b5f873322e1009609ab47285e1081ce95ee2ff2927faaa2e0f5ec1bf7d18886cc7a6e66d930e4b4a17d3ac6f30ca4060c3e48908891f901733ed20a8d044012bf85985f73e1d7dae995e6e5c13dd2a9ddc9d8b6968013143b7d32b8e984fb91fd0ff07fe161079dfaafc3f29094f11e515ed36dcadcc26b37ee42edd96e3e7f75470fb01f695d6f540b7405926754bb0da3baf29c6bb575a043c07079e6b88f5ec15e709f83b880a688e856c6acdd784a75f9949406c697e7648deb0d628981c220b4d975de389ed2f94db231cbf443e116bf231dc32de2cd618398a6f53ffc39c4266924d57151b0716bc1ef1bba973c130d7a8ff72c97ad35dee0c589fa4328316faecc96e2d6637371bc553c27d5df09000aec7076ebec3aed143f8e29538f49974d0fcc447b218bcf09278f20420f93251b67f927635ce594f900c5d3fdf4f9d63d7ae3d09ee56d6cce6824fb814a1806319f203afe0476de3170dc45bbe0c63acf889227624309780ec66cd27ed36526c8d30a1b885daa02266efaa0b46829546f802177c64797385d40b4067b177f63e5ea3b0c7f0c147839652934ca12d04f5d6de66250b100268335a4f07ef0d5e0b6ef4e0b6ab918920b00dde04557e98ebbb64bca4b7e93df39987b2ebf80a3dc41cc69d0a8551fb48587a6c25a6a878a4d7432569b3a2088ef17fc33948b422aec1721ce16866eb8978cc0ccfec5a2d067af6b25f4d1d83b78237fc651ddd0ffe83aa7b00bdf00b5fe5feaf60b694ea104d73f868e98d61d5549beda6a343d82ddca91756e0affc4bec54afa97199b419c8499d97fadd3c4952ddd4fd01b63086316f0980c5f7c7b05fc501b64ab86f13d98a60b0b4fc73d93aa4c62ef3c2beab37b9157d88033a42cc255ec11308d94d8b66013263c55e5aecb0a30476d5b71ebeb5e41c2397a4d56d7f16580131b45227c22f09f4a7f43619fe28a944d38d7612bf45242d71cb8008d3ee198a65cd79e75aa671d4015094364dd8cd9dab6c9b95a20322b119543f4075e9c009384949b6acb7a5f07927dfb59f91af67e4a4265939b251573900eeafba1e508044473b8d87992bce84f491a0c58a539e38870a8eac8c4292b91cbca1c591bf86cd15ac22f03e9331ccaf93c57a48182641226044a7f17481330e61813d3704d5a3423ef7e91000fc5724c1e2c7d6b296801356bd76503c7bbb1a10fa831e9db140303d2e8ef78485fc483c7cb91da2aa791255c63f6eb404bfbc77564fafc587e082df73761310de4b036bcbc8fe2e7480bfd2f42f1de529b15e8871b734171e2a750191c1aab8ba54bd137a0e7ee6ff1b588473594a4d7a67813853dd6b689e3dd21f1b59427d5d34932f197077f3759c3b1832a0e98bb3f000fc98b67eb0b4c8afb4ac0181d02d43823100c84214e1055fa5b636574db9280527eec309542b0304ed170fd4bbf4eecdae3db83c47b1ae6290d99935a5b5ab593166817a60d3039bbf399b7754f17d0205110f6edda310e91c96d8b7727d1e4fca656b9d79b0d688b7638a096ef01b7b662f3b23b9157d7d2a676e1469570f303c6b7f566c1e5cb705da96560f36ad4f867200b10a4687df9831b32765a7f07f8698431acd0665476eb541946155dc3334e4d6fc490ee7ea2eea27ed71ced5479bcd1da84bcad356a7eaaa83844e34b507975d7b3f73eb04a6d7343250cad4cf0d4d2dbf1c9d98442b164395589b9a68a5a180b680e30615209579a5ea1aeb79dd65c48d5f2e3e87dda2d6fee15ff22f94972099fcec663b3ce4a6e1fc9da0d40df9cd6e89342b27cbbe4ed36686f8c788c688f26370cd301a56ecafc6babe328fd4c334d40df16ec3aa4a1ebd7c1c2aca7a613ea1160afaed992f08533d3c2a13a0354fe84b364129cc963653721b3162106b39e6989a2b7f4a525bffc6e3bb301e56cc8064a22a6bce4e132ab5835a87c65bff90b9ca6ac9c654abb53faddab84d896399efe1f6d6adfec86ad8722eb3e2bdd588e06526f182d051a25584482bbe6560f376bf2c92136823450fa2626051bb6b6743ca57ff0622dd6468fab2f932d0a7dfb497b7237bcc8581df6879f91a1ca2a00223b5e2b5c4b7b893353683a2c649840cf45220a6cfec311205725cb4c45e204e6c646cb756e62310ea076141ad723e70a82c8ea6b9ec65935e82da0adee33523b42092abcc16bbe916ed6d3a48495bf9f01534ec373715d4f1bd6f4aa69cbf1479ee8f8a61696df9a9264b3b7f3944331bcda6426f2802d3f43fbf1e63351dc3b4e86a604ad3aa2fa3a16539b62c27ad5069ff2fcbfc6cfb63f2fdfa272852c613b50861e8807775e0f3a3bce8a9990dff0374b7a2e598c3b8d84ed6ad293748f5c8219dfbb565693de2e26c1c03b87906d34b1544494bf0c6788783bc1cfe24bb5f80a0669d86d3eff8fe62c3da0570c9cbf2bc9308d2cc1d6a882894079208520c866ce9ee2ffcc4cadbbc628c6571b07db95116015e8608e2a38eb5904f7e56003448a7afe0906cb81c278373c848e0e1bc8dfa5109619fa3f99cd23b70a06d05bad8512bd6ecf7fb41bb8a0bea9d7697e404f93cc49712851d3d75cd82873c3d6a8322f560d50de94f0b9e6728229356d31d73f30cd88166796a21be6efd3708ca6be5bbe563c39ac9e7daf2de64a39afa49a7b6625e9f7280881819529a245577d159cc4f95d5c23cad6b132bf7331959f00d797112c3c075c84315041cee57e48ef96c5cb4ce25f8541dd423cc010140041f8df553f5f6ed0d05f58fc889868c61ca2e724849617f35e5f9d55af02cfbd5b332b379ea8cedb8aca15d339072353254e2e9a87a374bdf001927dec7b9b59e77a4964fca91df7fc5343b725c1f70454e812bc8da6adda1e59d287d8c959d4d5e7ae2ced062a5442a4ee460d23abce0cebba6bffb39002f5aa3f7979f8ca72d7bd4d7f5107560e9c68d0f4d05e90dc1cc71d339ea8c732bea0af66aea7fb93da589b9d4b67d37f844de6ae82b577b92ae75a85942c76dba7621e58c997a6973dba214adba9f1efdc3d78c8da861ab314269e843a3b16d3220711494c77ad8100ef05ab9b4977218d70019a965e49444fc4014d1b00c3f1315f0c7f3143bc826ff4e06aa0820a161e5e0225ae51d5b1a05aa896c12e0c00ada855eb4f88633ec2d0b6a7590f3f45c112f76e6d8a8cb35830fb08e656859f2afce2a43a94fbdec13b3cecc1c515629b2f3cd18be79986800e5d05c8b782d2e4f561b71bd646fa0f6f86613bcfc065f8d627ddc316a0ddd0a66f7883798017eb31cfccf42c56e5382085d43337d2aa58d3c2e890f83553e6320cadb3d127599bdd7aa8895cda8c58e96146806f3c70d2e543a5ef0c70008d08380b3a7f8a281b537c783dd74c2f91f286d861976cea117422dd952f54af08567cfdde944495a771b88db3e18ea75da407ba79c84007be4c9d8662b29654f3148e73b050593c4ca3147a499bb4cad8fbf27e1f428b18319da2f8dd4b1ac8004431dcbce613c198763a89433e109fec3b9f83eef2e6eb0eebc324fea03da9bb6ea217edc31dc84bbfb4c3dc5916d444e3fb137d07d584c8965742a3e323b8d6e3a8ef5654d2b106b04b196d4e6ef5af744d8e802d159bed7d899d8c9ed5c4b62f686d221500c3cc6519a524ca6d114e2302c885aac674b6dc5e678b92eb2148cce7eb8107d3798900a29ebd8b465ca76e37d031ffb282ab39ae7f2ac5b87edaa9d3da339332d853f6a9ff3bfd68a90ce3dea4cd67c7332979fff8c8be583850a0d1d65c6e12945179c3f240044d15e87b676cfef58d344c2e6884e2d71e8c7a747ca5d45eda832b839cc92573076cecbab23a8a4660dada3afb7cbfab314b70552ee599dabfe784435170a471ae254ca93dd082b1afe2fc36c2806f1abfd48f0a81de7229e436db25e09e8e66a78d68eb82da2054afcee7fae1888974057758786a8a934ca54b01f372e0a0bcb72dcddac5e55411a36beb25a27045c2fd9228ec937b2d9a989e290d5f52c44456799b9c75c6274bd294a617a644d34af255f36b21cd95d60a2dcc84906ea286ff5e1f719d85edf3bfca58d77cee94852a0823d683f146390011b84bc31a8b3378e36f3073f168a5ff40429efdae869437aa6770936eff9f20df134c7cbf629e586f872fb63afc240e48ab97aeb00c593080933f291ee995ddf49fdaaa14539630dddd569a360a3747d0c815705b15a4f143c115bda5ca15eba17433d6cd8a502b55d0c1ddaf06357176a386927236fd201ba75adfda78b65d32f17a265ece3295b6c4b1102e91ab80df6ddd17bb8aebafe66eb088ba43073b2791f2a167157e6d2d4e7b58f3155b3326bdff89206ea36bd982db29d1cf0866312eeefd5210f83413b069782cf16a018c7070e7658fc5402d518fd98dd37dcaec326fafad93654ccaa4336e5263fb98f7ada9307b967c4e5c29f6963e54f929a1dd5ce46cebb61c76408cc18934e7966fde43d35385061bb1d4f9dc70ba6d05cadfcad6bd7fa9d5754f7820e65e1ee3aa7b966f91620b39809ec0fd74617e84b254363c3a9045a3d88403c61c7aded2c3dd8eac642f45cde7f31504bdc248f336be18d46603e16696ce74eca3254511cbd315da4f1e3d23b5d26b61749c7a00aa7bd548d90d749b8a66000fb5e4b29823f57bd62264bc8a64df6eb629403bfa1507669fee476b1d16e4c1c1e07d7bab4eac8c4545484eb9b54ba9019dd21f800113790c452b9f57455755bf0b3e29c40d54076d09e791ba57489208fdefa02140e2e111fb2ea61b784921daafde4b08cf46c38bddc03d30cd543d19afa502429c34f94a45c5e0aaa435c007899ef89f19967783d03e97b14f2c4457875835d13b6490bd3ef7ae6bd5a0e49b9acff4d9a4b7b6b623ca635a7ebf3e8c56a9a9f7a8418b05dd0129083eee655aec77622621642cb160b4bc7e2da6260757f40dd8aa941dad3a52e96e4cbc757f7a763c5d13258dd36a5546682a73b90af892cadb052f2adbd08562c32d7cd99a03625abdec62e8c52ca283e1716c4607a5d3b0eec3ad0c1f1c210dcf9e9b86ac3b55be6bea0f201b30b26e4c9ee0a81d81cd1be070a57a1b06e57b5e2b22b278016346d0eee899977f5173f0b52ce122b264d58a8964d30b723f455f3ab1fa5f8c1f488b0c4121b894eba5fe7d93b361c8d20e166914e7f5811c04fe748dbd1955ff410aaca60448f6551f3ea3fd4ba3cb375fa662dc752e823b1bcddb45d345ce5dac03ac7ab3909ee57350ec8956411c37eb0cf9ce93aec0ff9eced673084375fb6f5984d2e48c85fca1691c40a57b0358acefd80b12fd29eec53e5920075bb310cbb226587ae634429306b57f8ba212611a3c6eb37671bfa9cf7c2ca1d2ac00bd8e587f7b15203d2cfd6b050f0e00601df84dca908a79d89f6e910fad2606a4fbfe0ef632600c6e8f098a995cac5d4d80b5bb3bde5f6c77bf155399955f9999cedec74a3b0d88d47c5607675a0f7ba38513109db4b06e1cbc25acbd4bad833e97b117dc0aacfb07fa36befeabfc4ed97d5839518b0ffa6036851db553efe84cda4f8dd0fa9209b81dc22b25eba50bd65afc100f9d4834cc41435897ebfecd39152b39a9e03da7aba5009c39c907a7710dbc37775a3d8c6e7de9fd7a4b641f6ef4b418ef9f80028befde31a913a5e6714528590b1c18473f7a3b292ab408bbaca9d011e3e306c3564ad88b0ebee02a57c71e92e336969d1d265c3f0966ccb0fde78b593a8fc4e69fdc9b57c92963d89114c06dccc43a0cbe9d46d7de3d772ca183986d0e742a81be92a54c86285e5e791a34474c52f909467a822dc90cabf151f135e72239da4ec795ebe8316e148977ab3ab9ecf7b7f26ece93fbcc3ecd69f39a3a7045db8530adaa4a45e13d9105f3abc13c519acd070b1c5d8e69819edaff2fbcf448744ed1b723b5e402e8e9e2e5a748ceb66f237b60e1859b0c3eebb6e9265ddbf28dd9fcad5af5802e91ad0d5f4108dd7d34ca87706e8e48dcc3a7148a3c8d6f19501fbdb97d187e7e0e144749abcc4db11b98d40cdaff5a638d30cd75196ecf2a6f83da04e3ff8e3c841253373439ea5c9d88dd21f5c2416d19d99d6536375379b8fa50e14a082df1a5d9a938e841929fc18c1afd13ad174bedc30b92822d084a8f950ea396f768308bc5a807cd34f62c2a356ec7bb55a9e9c2eeb6e21b5671f9b373bec24e07be1dee2ca0a7fea2f9ee1f6a3ab7fcbec064a3bd81258b873891cc786ac0475cc1cbfb12d5064bcf34c1976cf223a0d22a4c2518e947fc781d00b001d5a3dc12c74810fe244c50d34337eb0a1ce427a1b11e4afc507ba63c19cd41a2f647fd9edd5a7a3969c9ddf4cdee326d7ab31be4d7ee5be7a717905daea0f469f7a375e17aca587c570e83ffca0a48e9af8f319bd5ba2e81292c150f3be191b2ea0b98f809780d8593a0d698228f44636954c86e7767e0a9b4e0c12c50a68a7282ca95c27349ffc4dded24dcf6a727b7817a0e64ba04f7f912f8bcea48b34d1d96556ffac1e1c0dd3cc9afc580fd576f5a8b36078c1534a27b0273c3211ba929a90e3986ff5de3eef1bd10fbd109eb96ad8792e058e75d93e42f0ac2375e4a69e615665def6f23fccff91374289730ce3ce8ff376bb7476381dd58ea5d53d875613f3cd746d035a0d8bf91184f7f2cac227f696f31adc1ecab68cd4645906ac05df902a098f611850455b2dc121560ce914730eaed3fc6d9cf78bf83c73a27e39a9601ef4cf710413337a4a34cdeccc0ee55d91cf70a0fa2c28b17b09dea73dab8b7d9d8a5265749eaa1227be8d605088c461358906b4baefb4b6d3609e53a0276bea894fe685ee9185ad6f624b09391e81047d10b43def33e07bfd0d414249f5117825695263e1b48397e8b8e44b169553dc6d5644aa07c568c3b4a6bc8cd37f238dbbc9f7a9fb1ccb8cb58c80200510ebcbcbf6194c067a1ba764d866641b6a3c31b94714b5e18ab1e42d2ca79d557be1a6a0a7b806d16c18bbb3f749159e9c2b597ec53d114594d894a36a2bd3340d33a2af9c93837c702e29893faa6fbd7df582dfc8a997a8082b051dbdceec765978e1a90527e68b087d4c6cf45b8bac8c8561b078be9a724a6a662f51672f0acf297a70c13822ac1c62681f204baed31ed043539bb592995cc9b8f265ebd9847b78e0f6bdec397b194204d42c4dcad211fa8b7266e9a0bf3bf71cd27992a360c4d5da11a6556a27556632f2415aa202e67bdfbde21850cecdf8da4983b54cff98972ccf90779754ce9af1b64bbb2aefb2b6ef3258fd519d90deb8cc8f899e7cd4d0c2b3cbe0e07fae4794f8df6ff28174e52b3d5427b379f42c7efd2d1f8aba983e3bb38e333e1716139717d7607190d6c5e74b875e33e60f9d99e01aa86de47e3f949720cd253daad2aaadd7261236a5a29dcbf49f7131b5cb0ec385ed4140e667627187deb04bf38bb401c68aa26bb8b76f6585eb5434011b459a7f96e0c82fa9185a3da867a7cb6620bdf6aeed9769985fff040b66601700da525a6e498d4edc289da03b441003d4579fc5b2d1961bd897ca284bf5099dae87b2bde737c408a42f4a97876a1994a5a96855134086ef0bca480c034165b801f785bc4f1c18fa0502bf24b308978090d2c7e2d3d538937097f57de22236fa55790a1b682ff40b34343b428b67c97801cd008dbf5427afa8ce06fe358eb4857967cdd7378b3e617be81c8c719b92fc43b3fde871bc490b8f056189f16761c444e648857cff669cd84f2255da45c6658ff7e99f076d9581b5ba1e84e7194e39ebcae0fe4d5c9e6ea35347174b54088b9f3b7a8754885a435056813c5356fc0199a5ab6e7045b0538a3ff8b9f984d093be6fda62b81d6156134221fd7c75a6ba61ef2ff8e612afc0476e2f564ac25ecccccd19417492caaeeeff47126642c75186ac0bb1966b04a8ca240ba814acd9bf0487b7e717b9ec566389265acf08f093d72bfe2a6d12bdc85edad139bf5e6d85bebfed236eed29ace7a83a95aa72c2c40d4ce88691e97b9ff95b2d02c5f1ba95d00d0e9f79c48fc9963a6a04a168f37b35591e3b324754c1bb6bcbd426a18f02a4f5124ce41f3f40dafa8e39f4344c97bf398d89b9f6ce197b23783918c95cfb4117bc24e2377b6b97207bb716fa2a325f406915081f50b05662a89cc9614aac21dfd5c99c95c86531467e5ebf52da2b1ad9b911c78073faee98c54595a1051d5969952932cec2810ba57758b87b0bba9324a5b41ae689d0408da170f370f618560f9f78de3566ff702c71bf0892c155ad656b1a1df3eb52f7b2f5e89990c6604f95d14d1ba73f5c3c5acd6faa44775260141aae139ef21f1dc8604893a9cdb88990e5a3f446141f20e9a9b6910bad2283639cca6ecf799dac1178c7e18122bd72d96014fe7684752a4056034f090d6b43edbec4a142431de973fb4184271d7179efbbd22e453f1b7928ff61f3033b58adcb43f46033a9e7f9e02ce9f11a9c4cc94fe97f3697cbdceb903eaab97869716c1ff8b6ccf3b4f3ec877f0256801da41c08c76a936ebf7bb2dd8ff3dbfe87936d546557eb988ea9bf2777e605e6cd70dbeddafca7b73d9c08b775148c62d6babd5d03323538995c11656f243299902e91ca3d42beb9ada1c37b3e06d7d31f4b57a4a51111b04b0caa5ea79936964a4befa820428e69ea5c02d44c7425275564093f3bd3bfaa6dc4f284de3e897e32bd373d6f4f3264482c06c9a2e96ddef8f3aa066e35798a0e2e1ae8ea43e198efdcbba1a0d00ce08d85bc7be404eb0e898bb0fca50e12bd9c33c7726006ff7f23a9c67bc0098a699fa16af58cf3016cb1860c960d0ea4954ea0ee7db82a480fae578638ec54e848ecf6e74132233c3b5a5db26a2a9865aaebabca21090cfe4ac90a94c31b02d7e05a0662b3fc3d018367320190e44dbb21a2f1675fd83bc910a8af4fdff43d8f753067c9e85eff0af5d8473ed57fa82ae5c52b17b8653000e11b403b6ae4cd6890c1561e4b2e954c41fabb7e13cf3c39bd85e3a8bd9bb287d71b79eaa8bcf36015b5c0571946760b1bccec65a2d342925917d4b10fd976665463c3f63caad17a7119eab42369f653036f222a0063310574366dd958e7ccbe7575d953244d4f36a75b86aa731f8542da95c6295083965200f7b4bfc3d7900c770be07981590f43178f24349387f6de3d5b2430d50b8b82fd90c9cb0373f11fecfedeb52070e48cc33ea7706baa7845a53534219cb010441bb146f31b29d95b19913a7ad1f176df9423456ccf83171196154751769549ad17a946b1755fe2ba37fcf39ee993aaaf74803b4a8d19511eadf195974abd343fe701bc17597bc02ae5fe23f334f6f4ed4f8307cda539824530cb89be6c0be28339a06342cc8c6e36861b003da77bfeebbf07bdad1a661a0747df643811a4d472d9123897f2c36c5207254dc67d530d00bf1cc6434c3f53d55d287a444a96e8edc84b31046ca47714f5866b2f0be927a6bce9b25f74c3de2e6de64c62f5330d18d033bcba26d55267f82f9def04019a059e1ffe3a4e16e7ad3f084acc853610030ed87f036cb5289ba6428f47b65f1ab0581d961b40add159774b108c3f98994d9069c800535e245b3aa752435d2ea53dee4b3467ca8602807e5a565c7e97acd528c30e2d751838dd0941a466809d254338593e68bdf731bd21e8fa8a4b1bd5191c493fc952588d165f8a83b9e7a30d1a021ebc87cfad9c31e29764a577386200d6e4f8cb86aaed41651fcb5b7e2e860222049b7686001697d57ef1f2e6128deafb90859c6362bbe70b7624a9cc610cc221c591da72a4dd4f6154c5f1eb23d0d772cede41b64ca74f0ab47a56196e3d7b804ad68ccfb74c95428e4050946661788bb0cddddb7c3e17ddc07c8e3f33c105838833b1984805780085203023d5a675317572067a5db1d3e3763fd39a410063c1e82f36b609c882673de46de422ac10983c8b1ece0a668c864193ade3110eb123c536e00439a5821d982b037dd6ac13247017a20fcd80f8bbdb60a25b94d6f5f0129367e45414387a21704f61e70d260993e4ec19bb2058e9d87bd27884d4e572551e15d3fdfbf9016067ced5b1a58adc96b20a04aacdab446eabb72db1faeb119fa313d777066831f5e76473f8c5b4b32cc3f9cc0da3b32f58a243d3903d35a97b75fa20959c9b2e03b412ca4b2a3dda6a1efeb7d2577764f7320bd6e331cd6edb29b0f4e2bc5dfaa130fc0ca82e6c7f198d86117db59f539f70cbfbb607310cf6d38fd5f7f5f49bc11ffa65d3255ff68ff17919ace925075d81a9b7bc7344dd4d4eafa5bb6f2a3785855a66ec84628bc2d3518cb60076ab3d78ee339d733ba47e0d02dcfea93d3e7228a3f44bd367f1a49920174a659c8d309573d0d0f986a24487f63501a134f470e1b5b8d01d50835ea3fe29817b5a41aad165690e5409f3a51b23c5812031ee217d6eae8d02fad9e5ae325b03381e598b95d6b8cab0816206635dea9bbf6181bccec601258578c2a8f3853bb7ba5e616f891e1e0b5a40d9c9ee98f212cf5cd4ec109661261ffcc9df90ebb75308a132fd5c1a6bde2f8629ce3d17dbcac3f5068bec6925d22168ad0d29e71f6f1dbdaa208388bbef4d8083c8139f183a7fd24edf6413a0f436545c57030f228d1654a64441f20fe854320fb16fb26f20d926a7ca2693aa418f48925856ab67b08d19f680a2ad818073e42d6723817efeb71f9af1e6424533cfff794006906276007076476c59716555d0c49711ce398c4d71c291dd172bb3a00382485f7df28805a20f31056f1cb55463f94c6cfb18ca8c247927ae08ba4078cb62d28e97a86aed8b1ab5f7452331c7fea2f9e9459994ce8f81aff5331fd9002b116ec9e78b4fd1ce8d71c87ec34fcbcc576829feca50e62be36a0c7c78487d2d8a5eb37b60cd56956d8595002b9324c6a0735f28ed2c6e39b8981445ca1b9055379db8212c3a4ce2b6289951fe12d36c4d48191178cafceaf5c76869c73d5c55e71241c94877b62d21170e83c6fbd1d77b9c59cb89741d1856adc59ac085558d9148795f03ef1a3743e9433c45d6655fd0719aeea7ab3dab87f9b52282d0180a8291f198eaa21240d5176542aca75c9b0054c4acaf4af7eb15ffca31fdc49e4ced8c2e28977b2fe9d8025c5c16518fcde1f94523abf3710ba142aa4e55e709bec5e4d40113f74bba71fe82040c0518e9b075bf0c6c9db29887696df04e72acf281d66a3241afb7731eab192698b177bdd3bfb4d06b0cc937ac8328fd7baa5a3cc9c3ab031963332fe5d205c0b49c6f56bf653569af5416220d28bd8342c1e8b36a1920c393d2d739f07d6bb791d5ef3e4e84e5f3395b1fef347388fefa593f4597e33ff1c43c5d5d863b6cadcf6fbede65e28fb8d92952c044fb21648e0b8ff949e1598e80544da7b98e2bab7482c496ce0013c0b851e3486e7b56feee0896a9a6cda26fd418c43b5c75dba91a2ff5296bb7b017b0a95a05dfb1fd96b322e656b93a1e6bb0067f9a59abaaa083b05911d66442d4724d4e27101ad73387b5681bc7685760788439b69cc0f57bf095b8e39bac3a0af9c69ad616295d951dc6439c5620b8ded0669907bfd6cba5e75a691554b12947a750c8bb8a0c7adb04e72b5dfc412749959953514f09a80395f4a84192db2fe39f07ba9d6b6732719ee5d48f9b0cf13f1366f0f6fdf1bf8f805427719920cd720550cba53c9929afb1aed90004ca8f5187f44fa18bbee3ac9aa7b80244b21680da2d4b9b7b526a8370174439b367398cba5f9117d5f22427766b7a4613e8fc83f429b2c31579bd19861be7e3e9f635970e9da1191af7dd319a626e9eb13e8d736fef0996294854af4786e0fac33adb27c8852e2e5a3400bc09e6093622dd7040e9ddbf8e5b723aa61dbafdfe4f1d98d5a8c04a21e263806138c292633c6a0d54392c89ed3c0b7c01840ca2b3df15c322eab8da73dc191e3d7822cdccb91a32707078ac698852d1ef3b8b221f224bde5883ddeb57770c40f08b0bc1b7916478796ab23a6a11fa0e92eedbf3164280ec9ca55e732f062689e1fa926fd6acceadd25d7059e63d1ab6dbed8169b4d1ca1aa357459433744507a0fe17e39e5876c043d3e175d28f9cd4ccd4ac380be690ee8e8d455095a954e3ce896d8bb1127ce19484c6179b3b4efe8203072917c39407db646b1a5ea0ccfe5396d1b41f99ca7c8df697051933d438f20d171a7d66c6ee94bb04babc46520f530bf436e7fc6df1376c5add15b7152e56f5ce3ee3ff62d6b7b1c2372dca7adba0ae59a512a1ba6ae4fab8f7e0199b3d9a16a39df5a4f1e662127abf400d918668c1b1ae6e3ff0b18ef26820438f1bdb93deea9d698b1ea4fa0089248159bc4a28c0132d710ede97a3c5110f6fc31d9333a1c7bf5ea46c011724bca641a41c58aeffc0d3d84904d7a80321c7a90a6ad7289e14e8eeb83f7bf0fccc597be292b9079e40a94e608af390b1680363f029206736609bd142180220242f7fef1f661417cdc4bcf9424731b4f5829a40502fd94a7d83246502d1aa6339e6a53f6196e8d963b0f5abfff62de04a428829bf6d3d1ed7e92a46a443429daed0ab7a02e084265101497e3abe9788459f874f880012bbfd89e380b05c5af3fd360cb7a81f1dbe3104d9631520cf24d4b746a492ad84380b53a284f3534bb068817500b7c5b2a79f17cca87469609a11f3e7c78947c754b95d53b7eb7931f8d16f18656393ae754fea3347a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d9012a8edc918139797518b126e63b87"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
