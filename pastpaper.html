<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2658d5460c7453ca4b0d775a0d783b731b67924a5b7c5bccd18ed6e7dc77814fb123785441e97f9caebbdd5f853adb603339a14b1a24727a1b65f8832297b587a3dc82e91b06ae5590ffc4847ee1cdaf855dd75eb118fa32a4891e25d43a9374190eb6b799cd33610e143894feeeeca3aea996a825eac18bd50dcc0b5f6bdd9e8a189a85dc0a38b61f0129bad6760aab5d79e18533ffeeb4335eeff3aada0f202e2d4a80957c7e94769d67f744366b39a3d9efe18981aad2b13c192b9ea09e3f5a50bc467e040c5c5ddc2e5272df91b8a78c6211b9a61e0067c11a16fd9ffb151ba36ad6755bf473c4653a62d495f2ef0a3cb96698b232d807c023f3f0906b5f8411e6e1698ba8980f1bbe6c6fb40d5e59739400f79f4c03dac8b2f495ef5bf647d44e540dff59beaf3826eab373afa8963bb50f3898cc32dad8829dac63cab86b6588c784913b855a94bf0e65de47170acc37977b8d59408ab591cf9ee3a9ea30127aa2cf234565a4c2e9bedc3a56b6ce18de30bf926970acf71ae820c3659ef0518134ea6992aa3895aeb4bb456487eb57f13fca01e3c59b9fe9603754dcea6254c7ef040194ebb938a8ebcae86d2b26cd59435ac9a1bba9ed96964a653b1886bb8e0d58720e7d3e1888ccebfe47481bb99a87937c8ab47c99d57c389f0a1395d5e209fcfa946ca4250cdff816536e87536febc57b21a75a7f58ed4c8cf8b5857aba385499073b471eaa0eb90cd870eb1442791706a17539f75103e1bf388426bdb28a90c909fea290a0090a48c328de8016beb4ee29aa1c2f864f465046ec8d6d4e05a43cc9155c7df1794be8566e42c65d61fa830fa0daaa9018075aa79369c08fb8e38c58550cf12f0eaa7888ca2b1ff5c7baec3f8da4e262487659553e36a48cf7698e204b668d2ab0a7fecfbe4f96bc985aafac1fb7dc91d1597c4f7da7280356e5e6cfd92353df96c4abe6f42be6d14ce72012596290d1b394b6ee7cfa5a5436cd91ed99e4bb4c90cfad3db244dbfe204700f01693be16e9fbadd053d7540f81e8e3a9d6fa647cbb0293f464bd3a55bb4ae526c02407d82678b68b3f88858dc341436dfb8f1089823f7caa947530253b7c246c0e30207071ec6bbbc1d2f31a80ad3fc98976b67384968ea08ec2f0c5f73925cb923936493f69ed2e474ec193398af5fb092153600b1e8c5b8c1597ac04c130c549a3172328838c769f234b1bd6c58eea92b80dcd51c09e4913e800a5a6b7cf58c5f9b0b6836925bd878458da30fa6f9a72f0ea0dc95b8503d15be5696301d69d2683dbe99dd14d92ce2aeecdbc2fffced57522cd38f235bb3c086d9fbeff48ee0a0673619cbe5b9358c54ab9586ef1e7a4243c0d129b9baab0e4501feb7f0110b8431aefb8df8b8cdc73a0247be01e8433fd49ed3b4d418525975bcb4f03e3369bb49d42a370171cac625d532c5fc9c78ea3299a99a7779acaaf8c1afd70ab6e45bb8b4def11fa8be74e991d4b6ec68dbe5274ae3ae3a97f69474eb2507809bdfb0f420c6519326f26425f82c783df92658579a1326d50974231edd0619adeaa0f3f6994af98dbc34a673fe3f3b783f8bf042a61d29d2cf09211a91590380bb41462cfe1a8ee3fccf9bcf481e6402f45c1b6d530aebd51249b849adcc860cfaaa20c3a15635240f7817d04b67954674bb82f48d8da3e72ff33152461f51c3bc24b120c7b06e8aadf3dd5041e5ce0647547dbcdd00cd5c9f88a82dee43af2ab8cb0017a36c544bc676b31732a4338c90ce204f81838e4b437511eb0159f3a6fe984c3764e6f41e265f8a578d65fb9a631359361657ac0c2d43c799df050b63004c61f384e344d55f26b4281d649c97111164c1784d6199c6e898c519c48beb75af99da3b2f91c594eac99139734788ec322dc8460d4037f4be8d9cabfd439d3eb217c01893c9391646a8b13276c9325123e1070411fb742fc48ab642fa092272242a23beb603a66608e4296849e53b51807f0cd2fb45c1c717012925436474c2adf40cc9d645588a18c8e941bd0ac34f24b2d2abe2ae2fc96789d85fe8e0c9a5e9773ca180fb4e4c3afd25b864a6461786713d888bec807b6dda43a2466cb6b201163e0e9a6956adf5da380ac60f1ee7ec46ec6869ed9618c6c86ebd4948a432193918a45cd2040ce3a25f6cc300c9f3d49c739ac72c47237e47284e76268c8e460124534496a6ffd145bc5a021ca06f519a158188dd4c940e8d6536b4f3e458df0df1d7f80117c1bbc07f8d69119d9a10a50caf26d526d364722058d77f9ec098b3727a7d72532ecfd6f7ab39d10cd6af27a35c5f2156d606a3ee06d68303b5c791123104848cd3f8487df437dbbf2bca09a971f8f6091220004f65a24b871f091483789e255b64a21302e8825b62908ae70358bca58ba1bcb85c532b3906aaa6b04a294012ed12addcc4acada2907ced3ebe2b69c85fe20102c16d2eba72cac7895b0afc9a75422429b8fc89ed9bfd0531987c554864811f7997556dca204110b084b0a42114b5d3c843512ce4d05019b54f1feb5c23d933597960f589250ed1200db1052cc7b5ff260a8cd256e3d27e54399654bbc36efff01aff030b25429ba87bf5af54dfce7ad2e4ac7f21172fb5ba2c1948c60147a9261d1487315b1e512a66c6b70ddb431414973a84ea379d85013f0440dd01d9d63f72ef974d45878f9b981de5c664a3bdf3fc47db0198a773c8f5ffbd791e605b14c6a9c7fdb052c51e0a0d61426eaf024c714da44343e1f526d6f6837f83b54d321c43eaf4feed7b942975f1959c706ef3158610363fe0bc0ee112a8623938e3f8752de92161d07ed9e969451081c32db1e50818617c6bc23135705ff1f2fc70399c58ade7bf725f557b20265c6f8c45261c761ec29daa193c718ac7a948fed8987781e61110badc489d7fe7e0e3ef2224991acb060494ee615952787653c484e7ca5f116ee642d9e2899c83140672809e6d158250a07caaeb3bfad2848363a3f82e7dec1756676cf336f2adb3316104de757b2e649aa6e40711fed5499d664956e0ba8e16b4ffef95084bc0024066aeeb31592c9aa69b64fd7720dc9578f99b724921034c9a051e1790d3c3c17a5f9c7e756273582876601a25aca807d56c6490b01f08764e602b9665a4b266293ca7d4c8bb4cf364a488d473845f3b569be8cdd55bce279da427c586a7437b83b23381d9792822f8280399681bd03d38b3ebbe0463fb1b4c939000637cdd82968980512c60cfbcf8a7cc087152d2af2a3b7efedd30aea316967501ea7c4a38c56ada6eb1e35578ba0e902cb47d32af840afde5a09b67a105c93bde6983abcf29aa25168f4abdeef9b768f5d7cba1bdca7b65d57215de0b54f4445c1a2fe800ad62df262409842c8c3cb1d1df2927534aca7b3f4542ac8422e5e6648e4252ab30ffba14376db6445df7c2b279c6971d0b149a5333854a3b719e946b49287458e95ade829ae0a4e44b178378a83f62c415fc1ba76a2d25e8c6f5be03aff1177d17d49c3738e1696bcd03422d7ee40d50d02ec7e26f5baadc217f988fcac7dc50ea02e2ca425cf8f083be42b7ca1a077970ff29ab20081a8d922114727d644dd43448b16edfbeec0d818cb80add473eebd8cf6ceec38af1bbaaaaa642ad98b1dfd60b2138abda395ae34ee6741e4a2582aa74bdd0b4797fc10ef3c17406dcea5c8d01d5e6805c236df182ab39d63d8710c793c8ef9644d1a058c9ffa0d68fe94574372b5ddb07e6d14a1caca761284ec0aab2fb495615972d3fff3a4e096e42183fb9570c295d5f0120cf970234985dafdbf49977d58b013b991ead2a3155b0bec466d5265d8243643e5188db844c6c838dd4e13790d8b2c3c6cbbaa3a21cae95c909a9b839aa181f65010e69b518698014b449794f1a58c317e330d58b3043413ed3ce49f890bac4bf32322904a8c14211fc30c3fc6ad5b5c71d1fd042e72830b1d1b93369bdd77370a74ff81d46b5e05bbe5f311256bda177af226aa51d36da2f92bb345e813e4ff6d1521540f68830541e14cb489b8f2af5d8b01dec8c165ea28cd25866479de7480315d0e377cae7c519a6639cd0a56590e521e0729604fecc6afc315001383b06768be4fb52d7f0a3872b6982e31e0e8a2b49592c5dfe83ebff54d71858dc330e1746bc65ef56de33d67492671f6597e19c758634a268a7d96399f551ef9b43694c4f5773ca84cd37740ecbebc1571bc5b0094312125892d965a9b65cf0515a1bfbdc777e0a64dffed35470922902c52a96331ab5644717fb89908b23e5830b74dee45ad6fa8ca42ee53e0d236c9ae9f7370d0cac9c758b771f5150d1a636bd9d6a7022ef9eafa53be3329f687f94ef23812c25f05edf116799a6df469ba0abc63b0fb29449b400a83ccc4686095be38ae7afead5abd2e193900218f17bf9b08b149973be890bab090c17a5a4738760c51ae3edcc7fea38f84e0770d8927b4edb86d12a0d46026ba1783eb0465db6360acea44b7bc3ba500b37f71321c6635fb3504381545b3f0db527824ad8302bc9944409609362b3083f3b58b043c88b88f8a55db78e7fc6d984c9cbd76c9cf837e08e390608005241b6aceb0d87c7e99ec022ed6d4f48dada36f015129ab5fc945e8333358363c2044d58492890d6f8c7e98cbf1536cb79ae5e04b9cdad597569d3e9cc85075146835d63f270ee25162ed5d9fe04bbf13e0e6abc1174006a8469833aeec9133d6e7fc94ae2ba53820184b0be65d0ecfc098c364a688eb62a7495cd208068a485431e371fd85ddf26784771c9be52d68d2a40abdcbb655d3b500874f6fb58d18e974090cb8a253c4b4746ae5b0090dd40461998c7efb7ef05dd18be0aa805885469a7dfa8fc2b86afa5fe064e68428a9bc2e1963687e27caeb815e1697aa3e9126f66ecafdd771713ff3464b17eba6f083e2e14bcc4c13713e668d8fb8f9231c6ac6dc5b4ceb1ce96ae8d50b0c9e416980fb13b2005eaf84bddb3780ddd87063c374fb56dc95d8e5ad76ab1737344f8567855b5b51f71f2cfa112743e1e7744f4bd5b4c2fb1eafad27b5418c53a4ed4a09faa4769acb475f243b5541695276bfe2d8ece2a0ccccae32ef25c9b5891c4422f704485a4fbf3be348072040731b971972524ce77ea3a4596c4237f9995c73baebdf24793d995154deaf7d96f82980211121c1f4571178b331250207b1794f3abf9e59bc9e8b1340ba40700048df1c004ebf8c53eafd78540972c650cd415991463f673f64f17ef790eb8e374355b8269519fc871a12d180f0b34ab6fae4badc653b3fc760440f7a7ad894055b819608369684bf09717b092ebbab82fb876ebc0fef214d040ccf81fda0417d334f09fd9a86958390c114859778ba1fe6192a543715277d96833d09d651fa30dc716ca7044b798b09bc27bb9ace4263181fc6d845f54740f15795757ecf00d2cebe038cc74a27b5840d625460576943190396b16fbbd60688bd4fb1473fbea85c0a83f362024ea1957bd408c29524845081996d261e9ebb8dab821cee8bfe6288575987c19777d613e8cb6581dba327359d8496c13e7998b129789f05be47e1167a8084289b4c620a1df4f1af26f96b92dc7826aeb1e7b360db2e5fa72518db8de10b30d9b0523579f235afba42abbfe446311dcd933f269e77284c2ba41a39cf518d52871fbb2b4d23f78a27bd7f4f60300fa917c0fc929bde235e28ead011d919011521480d6904044320b5d977b7c9f0395d3250fbbcc72506b1bd54e0d3a9e9e0dd13f7d67473965fb3f89d6b44a69398f68a141f482dfb38b763a042a302a8e2c9adb2a7c1e8092aaf609b361bdcec2bda352a277ed659d4ce5e818e6cc3bdb32682b0c8387acd27f3be1bc5f525b38b7034b066219f05c03b3862105ebe8f45d31c9dfd26ea46e3f3902dec4718b83cdd9fe18e6b6c68e1acb31b3991b0eec850f54d478603c3c95977bd423086a84fdfa96e8fb932ad81bb932319eb390625b3d68d5d197ced9a24e9572d094076e0428b2abcf6674ea34f4e519904f48150318046b04647a444ab36d09aa5ed69b5acfce694938a8d852f842168cc187e970aaaecc7a329769f2b3421e49dd5a77226ed2464434e11bb184160d8da504c69da4133dbfee5fdf014985f871a3c9a8f07e4084fc2ab7da719839b2604c91c1fcd4cf468e36214af234b42d93ed6b43d786a0142078756594cbaa6a33215f492c6feef76da65b730a8c6b6b30783c1251ca46d823dfe6e5d13e8b006df063b04c436db8743f9e8cfb282148560e2f751703d966c7e34f70203e34c9ed4856bd3fd04ee7dc40aa0272edb04a880040cd1af067c9cb1ec199778e3a74caed59c44e5926a92679abdad963139b0d23690f8ed7678c2cf740fe415a21414f7786fa47ebe068ab5108bd31c9b8ae02e4ba37ba8eed91cd7893f0181b06117a2c202c64068472f123185b95e1cd798705836071716ef8cb30bf57cf6b9517eb1eb5b13cd65e0681e1f9dc7af3969fa40163b5537b1ad38822f5d4068e0caece446ef6951a15e62ec9e9afc3e46ede23307c964ab3320d9f32735c810929cc067b2d98470bec246cd95a4bdd6fe2cf8a1ba5e911b23bdba2813517130b65d486a5312705d0bebd4bcefd4a0b52fcb5676bf44a4f8f601ad57de22cbc6a1d0f202d41a7af5e16dcfc72001d13b9e0d8a23298a8fe65cf72a978c361b4a68883391e098b1d2bb960daad3233a23262ba6e4d4e8d83385c9461282f00875b4c5769996d5a35ba807805f62af658c207737e16ae03d753b7f304c79e1ff6acd6a365b64dcfa7d526b70989b43adcac49b9ec4f44c2813dc0cf7279798fd64e87ee666f5d25a8d98f63546052223919941f4f1f363299988454df721276ae7b7c39384fd8675ac4f53b41c8928c1dba4bd5c218a742f2f769a93b791b48a39a441bac3fba6fb482607f508d2c867c98bb899ad85604372628a7037f760b2e65cb8bf78c3097542d986eb279a2e2a2c468b8589b895640c44d5aea64d8df85b027a498e5cf2d62c63b8fe284ed4a0e9d9bdc747fb61113965b695ae8ab550958683c74e29a07c3f9d21801fa0eaebfe66c706cc3a3865fa90c9edf99f2d7dc02762c6be934a002805f0b275b24970094458419fac3215dcc5e5a47e53f8aa980ac10b260e291c1dc6d8b76cc2421e55236382c12f7c401cc83cbf07c788eaab894c0c7f49ee258571dda71266cbf8a9f201156c30d2a93334063e101e8a7ef9b800ef516c12ad71ac14d40ab536a8c46738c45fc88619840e7cf60205bcdd3a5a843e5f04634f47c7efe67a17be5aa73b7192c3d7d44edf2c680701a4dd0a3d68c183f7b7e11e929367ce6e423c7e30d739f03114a7a626467fcb829f6b176effbdf0da1bd40458cd9d52958fd87ca8c9b236d0cd1dbc92702f76351458246cb423e6c806bea684d74ec94f850347a43c1de9a728130415bedaadffe4d3d815c4337c548ab309b9b74f3e4e9db95758d3e6161237f1fc7011a28cb260249f78a5e6113fa7f916dd669918135d5b295f4b0cff2db37af00a19cb6a4694c1eff9365d7185dbeba04413e4aceb356f331b03b194b754eeecd28e45c5a409a77d2668b234011595fd82235c4ed50244ea92eb973e1639ae6923b642a384dec6b159d77c810f0785d723c41510bab6880dd9c6000a04097d0a55e8acb4dcb369db6ff0fe13982b2127530c1ab21495719a06fa1a2ab41951280803e0f71491df40c6c143f1db96932ce905938646fa9ce66a6e53d8849ea78756e7013f7b2f79b8bb76779430f06a7533467a4324338988e9f5ffefc97e6645204905ffff9f17844c03a2749712843fbd0d896ecce4402090561259068c4b0e09cc2defd89cf301deb0a2171cbd3c90fb5116ed99e265c290fa583f91a6621668327a63d17c80d8180583331b19da44621b6f4562a87177c43c18656db7f12bd0371902b9bf74aaa378669a1a2c9180a8ee598d9cbc166c7495a3db4b4ea2bd16ee335ddc3c0adbe07090bf7ac297fad4ff6d018e492bb4537024efad5e236515a20940d67b2de3f756052248114395e553675ace52f753e12103306a088198a82868bb86bf92cfd6f7fa6ba64403b67a18ccb21ce37ed4b36d51f2e4d0a503efe1ed9aac0d13a544846faf3a46aa458a4ed834c8e21f821aec882dbe1c24238808cb71b61087d664e08122fb74b735ab05f0654f9b492561abed7bcc994a1ab556c0a64852d4f00c79cacca1a699dc78c9edd900183068909df43ed8329a97d5a29afbbea5a4612ae89bbbc83f7146f19b37dc1621e41c3d09ffc789dcabdc9dd1a5fe6902a45b1af321f57f3e34aae12e943fc50b85e755ca203efe4c62c4a9f56a6bedebac239a303af020d4e2c7738494aaeb0ba4bba177ca24826394edbacfd0d5298578b63e852b99431f8a280890b98497dea1041a702c7626f3d8a3bacfe6c4e4d4009c92ad4e5ed904f7060cdef434c92134093f2f751db1f17f67e38e31a18e6f28f0a6dc4fe38088ba5f83ec7f36e59b6b2171be5a7c8064fc71b45eb65a317071c3c6ca05d8d01e2e5fa2f328d95ecb64a2a51d246dc24c62aa7a4530f8d198188955311264cb6ddaab9a4691c6bc313f1f0bf1825c2858b5009997ea7ef0a521fcf4df1d3f9e60ceefd1777e942da450a9f1e115f1aa35789d08ff6630aa7934aeada15d5c494fcf7dec05c2ccacd0e90fadd0e12bc8f1a0d6ee73f69e794ef76600f12b930bedf4604552f319382af104e7a156219eb4b75b68f5aab51fa1db3cf1534d5776a5c6b89541e7afcc5c3607a51a4ab69821f421c9be1ecbda520fd4552b549cdb32bc397959c425dbb2d4cf0a5e4958a0f4671174049909722402243a5576fda78acb09956ea98f17cb46a85788ca7bd0d5bb6e851fe12d62eb99511005b3805677c7aa8dae31acc0c40e65370474c33a25d8ba8b8b96f969f6850728478fbfd3c255c393da0da39589ce5cd00a650821785284ac2e80102d6081a9ce80317cbad5d598b8bf7ef9f4c0f6d49077151749d686c5b3fb60bdec85ad2da72f8140e268f0af85f8409b107ee58c913cff8d25f0a0acc6092da48597294db4b5c9a0e47c0e9693bf8931f19047e32f22362190e35739ac5f211390aef50ca26b42009b5be6c93e358c3dfc9bc93a84aa4603404d8ff1b846fa3e71d45c68817b7a53467ca53e7ae480fe7757a5168050be87054f9f5bc2e344d0202d301789ed08657687fa3a57c90c21ecb932c5031bbc5bf9f272ed0aeb23e081bc0bc68fcfed074592179593cfa965e3cf9c09c10d1f0c66344cde0ad245ba19f078df2731b84ff024754a604c32c41e2c0c219c866986167c0b529eacf0687fb9cce405fac9a0c329c4fe349952ff623f159b01af8fe2c85cb72cc3d3403d34b5214a0502e30a0d05b47c7374f55f81177a0c9f9cfc47fea7a20c0332691ad7aff0cf6c02a77dddfe650bd0c4a50f3a22a6e28e35bbed278be41149efb5ab2145119dcbb5d9dc86c0316fb1a9c7b35f219b225a175cffa352f68c1377e7df9560e642751f98077022668fd822d741e757a6031ab44918e81a4f6ef2c916d2c2c430ee9601edc2904cda7cd331a6e3ac64cb2f6e3a39696277ec12c230c96c41cc5ead0209ca112b6a380a69af09da6a25e6be8b2d92df3d7737bb7afd4c11f3c40defa937f2c111ab0346666dd88fef80ebc42d6e4f773e03cdf5728a6893d92658b5c803680fb8192305e52011d984be379c0aefc27e4b35012328acb9341c79803ec5185184174a3ed54da60be552461f5d6eb785e659d1ed2ebd7cc305ce84acec547587c1d1557b4e24377dde9c33eeab9970ff28d9da36aba9e32338f2a36cc6298bd1cf390dff12e71fa5f0ea8168a1bc63670e3164e3c8b04463fd86bb6c6ff724d35dae328750cf827fc1ff3389d327611aab8237c08c7975ee4a49ca100ca02eb35fdd8c14d3c4a6ccbcd0e79c4d6d3cdacaf7583f32f7ba190e37f12d1ca720055e1f21b6fd4a6eb8cded7ad0a6befbdccbc87984e34b0e2b28aa0672094ea43935345d033c0539e7f92391606d2a33f66d8e946bf18bfeea1c837c8a5d0584b9abd22ceb996eb18b56546529679281dda633fa4575840006afb911c0a5a7632f641d91e715250355add431d2736fce3f7ee0fbeaed832b11429462742eb67715ba98e40c9df469eb66ed08e6099f5288a5c3812d3a5c5f1c39d37723bad5f863a40fe59fb2e9ddca720e67fa1f3afbf8638d604e58d174e69d548a9726393daa015acd4c08115f6032a56815737b714dcf44e5867df49de2938ba66be94e15774220000f0ae62078557bb0eab7990cabccdba2db1ed49b077158f5aea5673bacc8569b369b2969304caa63195beba0e803319203ce3a8aec35b32ac2a126ccad45a9ae12094d4928de9e496956e09a5838ba62994f71357f6652ffc7b454923180d0c1c73fd7a168b255064ea28d7b22ae69ddc5643017bb0dd00594bd5cc46b15eb2613dfad984f1baed079d81cbc05be507a6d8212b17e05abe425e0b34592443c38f389dd91ca1211e53ff3fa79300818d8c2c44a18112df2ac5a067d0e73cf7f552f5652e8fd21084ad5ee2bc10a3583e53dbc95da0c5d47e2105f5c0ee94bfa3acfc1dd50f4e27bdd02019daea06491ba2275ef0cbf6657055f38cfc3d827d8dfefe38a3e3f19f9a7e3c781645cdd6be657a97319315919095748daf02ff8e9d6a27b7ebeb1e2514e62ed97603a3e4780a0c5d314d829ae1d90d31d14f407d34f9d8d8e3cd83407356f66e93c8b5564786f179234f8c8cced6ceaf90a426c7e6f73b78c5629e35b80d759c0d2366f8795501aa9a6463d9901f76c21f3e82fe73726131f6899ad6c45bd5158c75b7ed3548e0ba001f37dd2a4645f734f1a8a4aec0be695307dea188b1fb8a2d528541bd642c853973e874e8777399d0e02f91791925f42dd19dc9d93c4a62b3875acbfaa690ddc5f2cefc2b3401aefba17f626b3033948e6863baeb40968b128552f5f4dcbc10ebde02601f21b2d400c6bd7c7073d650ef5eaa6c290981c5f93d13372e3d00f50e7083655b52eb56bda851d91d9327e4b90fdda2699e62889f01e37958a5f0364b416672bbdcca6469786616820c706b9437f1babd1f8b342193b35f4a924b247050ef3235ab1b96eec97fd5387912911e015488071cf9ce3fcc021759e45a17368ba5f0decc82a1eb89c85ab0678aa2a693d4719dd54031fc518f926b55459b5b6c657042ca0db3c07fb2af603f41f94681e51cea73b19fe3271d48c2c99000072bdce97d10d1180d958182e6bef2e3146a5a5eaa87d117670aef20b68dfbb62d43bab4ff562a496691424b23ef57c8e0f5b1eb013156f9e166ea053294c2551b3b1e9d01c073990ffcbac8dcec4d9e045284261b30b75e1cd5b2b48d7494f60cc808439926b110cbb69b70a2b837991562e72b6ec9601b432071a354e6c9d5d54e33b79e60956644cd6e9eab9e42e872b04967faa75eabb94ae188ef2e8e507dd357694ecfd2532ba5dbf9bc38edee6ea9d638df19bbded6edc81512ac4c671f112915bd5f0d11676b437529947d388e1aaafa3da68582b83c5df2b1bebb07af970a6a990d2da76c22f750b8717ddf50fde1bbd3c5e8b46fd71ad23158650156f9ed0bdbbf3573f765b78dfc572f31e7c6eb60b15429d285b7181ed0db0e65f51ed525902f670cefd15db955ebf66145246d45f1ffe1cdb442c461cbc9a17a89ac799461b3fb5da0c02e2a99afdf915b1cd09e30d1b34c7d1a3c4e2deb0756bb096d955aff5c3057fcade159564b820d50bbd7bc9b3df5697db86c4cf36fa34e7ca6b5ee3590b4d840b71ec35563b8c67a06f2840e20be109d84c4241ce2fb299f86f44d528698de09f0c8127f48ac9c2485c58f4ceb62735e32e09c6b5f27b98ddfc9ae4c666dab92446f8d56139b23e778a648f27e5528d4fbb0960168e21a7e6a835cb649bdbf05fdfdf1b375fc74739e153c08a82d2fb14c3d1798ea7c80acacd0dd7eadc8780462e22a7302b031d3ad590cc169b27fbf0e9224cab1e8ceafd66a569a3942f54ada20c00762c818a99e2c93790e94778c45461fec899fd519ec59090b49cc353d83e6742ce957a9463309ecc8c05c2403dccae8905e3b96b5798bd16718468e93bd3a218ed040d26d7da9a271270aa92070fda44fca8348ee024230814ca992ee44338e9753193ab576f77b162467359ebc153ebdb0930345f3c8b937e4a1d34049fa81960e73551a23c828259fae1c674c202e59059e0511583d82c7727b3d45b15dab89520d513f8185c4db2d2efb6b52b64d36641b8224c43c5218a9787bc4404c3cf85ff76ec7203a34dd83aa43e0b902794a108697e5e2a370238f72a8e58a27b7cf622af2504bc360c04edfe6c0dbd7c6e44366a70918fdca51a23d2cf359ed2da91dd723d57485a2acd4356654a9fa963cb4f868b5570a4c5580d2b1e11a50c3d199f283849a091a8a14fb4a51ef596d2c0c117c93df8cb62ade6aa375e0c382ea9cf84f5f734ccc08b1c03f024b3ec485b76095d994fd21fabcc61fc084a816028789a07fc0cbf6710740b4cf7ac238ed1666b2250cbd5da39a3ca256653d6533bf66603e15d80fa19d1bec940ec5d9dda5c0a5c5c0ea40892cd3dcbf3fa83177ee250f5c01603fcf8f5fd6ca5d7c37375bcca175d82debccb11fbcc18eda49559167faf986b635f51b7e7abce8dfa3e6a4a10952dcc4d7e2839d1b11ba9aaa1bc5bf3287a4f45b25ce10668751ee559a465e971ef93d2553f248d4645a0ada7aeef0b9bbed8799186b1d540557d389922b8662c022ed6d4fe257092d980d983385f785d3f656fa734b0ebda2e8c3e2faa324d0c05a81ac62f697d7c1fbbc3a17a8d0efeff5825a82b7d81c28510ef356ab62d33c8c8de215db071d5714f6f39acd600452da38bbeb9ae6ed6e596c38799c48a676625874837223fdf374e4162f3d531af285af8713e915113f6490743ae01739feb654a5550ae44cd9d995ae4eb6832b2e9e2bdd9f48145ef59274bf8081773fb9ad031cc85623ef7fb387869a1c08eb6bbf3655ba2708f9e9787212709dffc688b31c87a52f8025d83d4e352b6845d539babdc3d4c17d07494e1bc01b8cdb1b5cd3a0b855de124cc52c8e53e168dd130ef9c1d86ec10fd3bd7cd94de976477bff2e93a0f12ea0c34bbf74d49ee89c807001cae4c7b8c670940bb3cb89c50fc95023c90ce78ac30da3fd11a512df103f8270c38b51ba9c9681210b28aab01ee2c7f5158716fb655b25b44ce6cfbcd0730ed7e446e62c51bed32810f5c4fa7a57449f007328c477e7d2163891d679f267df90621569ebc65e2440bc6128bef0f047d2b4f53c02c1904521f241017a447177c130f25038c2b0ebb78cff1f11893caf5907c8d7783b673857bfc5ee2e02642e94ac90cb851cec1998c3149e04e6fac423d1d653f29f66114f484ca6d82638317124cf0c1fd85e74e430b3802f5d979ff10a3697f7ff2d675e9b11562948242b617ecf13236106e91a4ff12bfd057eaee1148ca061904038b794e3c27a7d6b2a8358095642091a5a191f928ea7c9b69e088aacb179b270b69339fae827cf9b977d245974e459d73e7ef129dadbed42b04c70f80","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"0a2e67dd99690e1785ebe9d00356b588"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
